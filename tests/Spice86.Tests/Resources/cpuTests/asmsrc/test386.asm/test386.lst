     1                                  ;
     2                                  ;   test386.asm
     3                                  ;   Copyright (C) 2012-2015 Jeff Parsons <Jeff@pcjs.org>
     4                                  ;   Copyright (C) 2017-2021 Marco Bortolin <barotto@gmail.com>
     5                                  ;
     6                                  ;   This file is a derivative work of PCjs
     7                                  ;   https://www.pcjs.org/software/pcx86/test/cpu/80386/test386.asm
     8                                  ;
     9                                  ;   test386.asm is free software: you can redistribute it and/or modify it under
    10                                  ;   the terms of the GNU General Public License as published by the Free
    11                                  ;   Software Foundation, either version 3 of the License, or (at your option)
    12                                  ;   any later version.
    13                                  ;
    14                                  ;   test386.asm is distributed in the hope that it will be useful, but WITHOUT ANY
    15                                  ;   WARRANTY without even the implied warranty of MERCHANTABILITY or FITNESS
    16                                  ;   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
    17                                  ;   details.
    18                                  ;
    19                                  ;   You should have received a copy of the GNU General Public License along with
    20                                  ;   test386.asm.  If not see <http://www.gnu.org/licenses/gpl.html>.
    21                                  ;
    22                                  ;   This program was originally developed for IBMulator
    23                                  ;   https://barotto.github.io/IBMulator
    24                                  ;
    25                                  ;   Overview
    26                                  ;   --------
    27                                  ;   This file is designed to run as a test ROM, loaded in place of the BIOS.
    28                                  ;   Its pourpose is to test the CPU, reporting its status to the POST port and
    29                                  ;   its computational results in ASCII form to various configurable ports.
    30                                  ;   A 80386 or later CPU is required. This ROM is designed to test an emulator
    31                                  ;   CPU and was never tested on real hardware.
    32                                  ;
    33                                  ;   It must be installed at physical address 0xf0000 and aliased at physical
    34                                  ;   address 0xffff0000.  The jump at resetVector should align with the CPU reset
    35                                  ;   address 0xfffffff0, which will transfer control to f000:0045.  From that
    36                                  ;   point on, all memory accesses should remain within the first 1MB.
    37                                  ;
    38                                  
    39                                  ;
    40                                  ; WARNING
    41                                  ;
    42                                  ;   A word of caution before you start developing.
    43                                  ;   NASM (2.11.08) generates [ebp + ebp] for [ebp*2] (i.e. no base register),
    44                                  ;   which are not the same thing: [ebp+ebp] references the SS segment, [ebp*2]
    45                                  ;   references the DS segment.
    46                                  ;   NASM developers think [ebp*2] and [ebp+ebp] are the same, but that is true
    47                                  ;   only assuming a flat memory model. Until the time NASM authors realize their
    48                                  ;   mistake (any assumption of a flat memory model should be optional), you can
    49                                  ;   disable this behaviour by writing: [nosplit ebp*2].
    50                                  ;
    51                                  ;	NASM Assembly            Translated               Assembled
    52                                  ;	mov eax,[ebp*2]          mov eax,[ebp+ebp*1+0x0]  8B442D00
    53                                  ;	mov eax,[nosplit ebp*2]  mov eax,[ebp*2+0x0]      8B046D00000000
    54                                  ;
    55                                  
    56                                  %define COPYRIGHT 'test386.asm (C) 2012-2015 Jeff Parsons, (C) 2017-2021 Marco Bortolin '
    57                                  %define RELEASE   '??/??/21'
    58                                  
    59                                  	cpu 386
    60                                  	section .text
    61                                  
    62                                  	%include "configuration.asm"
     1                              <1> ; ==============================================================================
     2                              <1> ;   CONFIGURATION
     3                              <1> ;
     4                              <1> ;   If your system needs a specific LPT or COM initialization procedure put it
     5                              <1> ;   inside the print_init.asm file.
     6                              <1> ;
     7                              <1> ; ==============================================================================
     8                              <1> 
     9                              <1> ; The diagnostic port used to emit the current test procedure number.
    10                              <1> ; Possible values: the 16-bit value of the diagnostic port of your system.
    11                              <1> POST_PORT equ 0x999
    12                              <1> 
    13                              <1> ; The parallel port to use to print ASCII computational results.
    14                              <1> ; Possible values: 0=disabled, 1=LPT1 (3BCh), 2=LPT2 (378h), 3=LPT3 (278h)
    15                              <1> LPT_PORT equ 0
    16                              <1> 
    17                              <1> ; The parallel port strobing delay (lower is faster)
    18                              <1> ; Possible values: from 0 to 0xffffffff (emulators can use 0 to disable the delay)
    19                              <1> LPT_STROBING equ 0
    20                              <1> 
    21                              <1> ; The serial port to use to print ASCII computational results.
    22                              <1> ; Possible values: 0=disabled, 1=COM1 (3F8h-3FDh), 2=COM2 (2F8h-2FDh)
    23                              <1> COM_PORT equ 0
    24                              <1> 
    25                              <1> ; The serial port speed as a 16-bit divisor of 115200 baud.
    26                              <1> ; Possible values range from 0x0001 (115200 baud) to 0x0900 (50 baud)
    27                              <1> COM_PORT_DIV equ 0x0001
    28                              <1> 
    29                              <1> ; Additional port for direct ASCII output.
    30                              <1> ; Possible values: any 16-bit value, 0=disabled.
    31                              <1> OUT_PORT equ 0x998
    32                              <1> 
    33                              <1> ; Enable POST E0 test for undefined behaviours and bugs. You also need to
    34                              <1> ; specify the CPU model your emulator implements (see CPU_FAMILY).
    35                              <1> ; Possible values: 1=enable POST E0, 0=skip the tests
    36                              <1> TEST_UNDEF equ 0
    37                              <1> 
    38                              <1> ; Enable PMODE tests
    39                              <1> TEST_PMODE equ 0
    40                              <1> 
    41                              <1> ; The CPU family option is used only when POST E0 is enabled.
    42                              <1> ; Possible values: 3=80386
    43                              <1> CPU_FAMILY equ 3
    44                              <1> 
    45                              <1> ; The Bochs x86 PC emulator behaves differently than real hardware in the ARPL
    46                              <1> ; operation and fails on that specific test. Enable this Equ if you want to use
    47                              <1> ; Bochs.
    48                              <1> ; Possible values: 1=enable Bochs, 0=disable Bochs
    49                              <1> BOCHS equ 0
    50                              <1> 
    51                              <1> ; The IBM PS/1 needs special commands to initialize LPT and COM ports.
    52                              <1> ; Possible values: 1=enable PS/1 initialization, 0=your machine is not a PS/1
    53                              <1> IBM_PS1 equ 0
    54                              <1> 
    55                              <1> ; Enable some additional text output on the output ports (useful for test386.asm
    56                              <1> ; debugging).
    57                              <1> DEBUG equ 1
    58                              <1> 
    59                              <1> 
    60                              <1> ; == END OF CONFIGURATION ======================================================
    63                                  	%include "x86_e.asm"
     1                              <1> PS_CF       equ 0x0001
     2                              <1> PS_PF       equ 0x0004
     3                              <1> PS_AF       equ 0x0010
     4                              <1> PS_ZF       equ 0x0040
     5                              <1> PS_SF       equ 0x0080
     6                              <1> PS_TF       equ 0x0100
     7                              <1> PS_IF       equ 0x0200
     8                              <1> PS_DF       equ 0x0400
     9                              <1> PS_OF       equ 0x0800
    10                              <1> PS_ARITH    equ (PS_CF | PS_PF | PS_AF | PS_ZF | PS_SF | PS_OF)
    11                              <1> PS_LOGIC    equ (PS_CF | PS_PF | PS_ZF | PS_SF | PS_OF)
    12                              <1> PS_MULTIPLY equ (PS_CF | PS_OF) ; only CF and OF are "defined" following MUL or IMUL
    13                              <1> PS_DIVIDE   equ 0 ; none of the Processor Status flags are "defined" following DIV or IDIV
    14                              <1> PS_SHIFTS_1 equ (PS_CF | PS_SF | PS_ZF | PS_PF | PS_OF)
    15                              <1> PS_SHIFTS_R equ (PS_CF | PS_SF | PS_ZF | PS_PF)
    16                              <1> 
    17                              <1> CR0_MSW_PE  equ 0x0001
    18                              <1> CR0_PG      equ 0x80000000	; set if paging enabled
    19                              <1> 
    20                              <1> ACC_TYPE_GATE386_INT  equ 0x0E00
    21                              <1> ACC_TYPE_GATE386_CALL equ 0x0C00
    22                              <1> ACC_TYPE_SEG         equ 0x1000
    23                              <1> ACC_PRESENT          equ 0x8000
    24                              <1> ACC_TYPE_CODE_R      equ 0x1a00
    25                              <1> ACC_TYPE_CONFORMING  equ 0x0400
    26                              <1> ACC_TYPE_DATA_R      equ 0x1000
    27                              <1> ACC_TYPE_DATA_W      equ 0x1200
    28                              <1> ACC_TYPE_LDT         equ 0x0200
    29                              <1> ACC_TYPE_TSS         equ 0x0900
    30                              <1> 
    31                              <1> ACC_DPL_0 equ 0x0000
    32                              <1> ACC_DPL_1 equ 0x2000
    33                              <1> ACC_DPL_2 equ 0x4000
    34                              <1> ACC_DPL_3 equ 0x6000
    35                              <1> 
    36                              <1> EXT_NONE  equ 0x0000
    37                              <1> EXT_16BIT equ EXT_NONE
    38                              <1> EXT_32BIT equ 0x0040 ; size bit
    39                              <1> EXT_PAGE  equ 0x0080 ; granularity bit
    40                              <1> 
    41                              <1> PTE_FRAME     equ 0xfffff000
    42                              <1> PTE_DIRTY     equ 0x00000040 ; page has been modified
    43                              <1> PTE_ACCESSED  equ 0x00000020 ; page has been accessed
    44                              <1> PTE_USER      equ 0x00000004 ; set for user level (CPL 3), clear for supervisor level (CPL 0-2)
    45                              <1> PTE_WRITE     equ 0x00000002 ; set for read/write, clear for read-only (affects CPL 3 only)
    46                              <1> PTE_PRESENT   equ 0x00000001 ; set for present page, clear for not-present page
    47                              <1> 
    48                              <1> PTE_PRESENT_BIT   equ 0000001b
    49                              <1> PTE_WRITE_BIT     equ 0000010b
    50                              <1> PTE_USER_BIT      equ 0000100b
    51                              <1> PTE_ACCESSED_BIT  equ 0100000b
    52                              <1> PTE_DIRTY_BIT     equ 1000000b
    53                              <1> 
    54                              <1> EX_DE equ 0
    55                              <1> EX_DB equ 1
    56                              <1> EX_BP equ 3
    57                              <1> EX_OF equ 4
    58                              <1> EX_BR equ 5
    59                              <1> EX_UD equ 6
    60                              <1> EX_NM equ 7
    61                              <1> EX_DF equ 8
    62                              <1> EX_MP equ 9
    63                              <1> EX_TS equ 10
    64                              <1> EX_NP equ 11
    65                              <1> EX_SS equ 12
    66                              <1> EX_GP equ 13
    67                              <1> EX_PF equ 14
    68                              <1> EX_MF equ 15
    69                              <1> 
    64                                  	%include "macros_m.asm"
     1                              <1> ;
     2                              <1> ;   Output a byte to the POST port, destroys al and dx
     3                              <1> ;
     4                              <1> %macro POST 1
     5                              <1> 	mov al, 0x%1
     6                              <1> 	mov dx, POST_PORT
     7                              <1> 	out dx, al
     8                              <1> %endmacro
     9                              <1> 
    10                              <1> ;
    11                              <1> ; Initializes an interrupt gate in system memory.
    12                              <1> ; This is the body of procedures used in 16 and 32-bit code segments.
    13                              <1> ;
    14                              <1> ;    7                             0 7                             0
    15                              <1> ;   ╔═══════════════════════════════╤═══════════════════════════════╗
    16                              <1> ; +7║                          OFFSET 31-16                         ║+6
    17                              <1> ;   ╟───┬───────┬───┬───────────────┬───────────────────────────────╢
    18                              <1> ; +5║ P │  DPL  │ 0 │ 1   1   1   0 │            UNUSED             ║+4
    19                              <1> ;   ╟───┴───┴───┴───┴───┴───┴───┴───┴───────────────────────────────╢
    20                              <1> ; +3║                           SELECTOR                            ║+2
    21                              <1> ;   ╟───────────────────────────────┴───────────────────────────────╢
    22                              <1> ; +1║                          OFFSET 15-0                          ║ 0
    23                              <1> ;   ╚═══════════════════════════════╧═══════════════════════════════╝
    24                              <1> ;    15                                                            0
    25                              <1> ;
    26                              <1> ; DS:EBX pointer to IDT
    27                              <1> ; EAX vector
    28                              <1> ; ESI selector
    29                              <1> ; EDI offset
    30                              <1> ; DX DPL (use ACC_DPL_* equs)
    31                              <1> ;
    32                              <1> %macro initIntGate 0
    33                              <1> 	shl    eax, 3
    34                              <1> 	add    ebx, eax
    35                              <1> 	mov    word [ebx], di ; OFFSET 15-0
    36                              <1> 	mov    word [ebx+2], si ; SELECTOR
    37                              <1> 	or     dx, ACC_TYPE_GATE386_INT | ACC_PRESENT
    38                              <1> 	mov    word [ebx+4], dx
    39                              <1> 	shr    edi, 16
    40                              <1> 	mov    word [ebx+6], di ; OFFSET 31-16
    41                              <1> %endmacro
    42                              <1> 
    43                              <1> ;
    44                              <1> ; Set a descriptor in system memory.
    45                              <1> ; This is the body of procedures used in 16 and 32-bit code segments.
    46                              <1> ;
    47                              <1> ;    7                             0 7                             0
    48                              <1> ;   ╔═══════════════════════════════╤═══╤═══╤═══╤═══╤═══════════════╗
    49                              <1> ; +7║            BASE 31-24         │ G │B/D│ 0 │AVL│  LIMIT 19-16  ║+6
    50                              <1> ;   ╟───┬───────┬───┬───────────┬───┼───┴───┴───┴───┴───┴───┴───┴───╢
    51                              <1> ; +5║ P │  DPL  │ S │    TYPE    (A)│          BASE 23-16           ║+4
    52                              <1> ;   ╟───┴───┴───┴───┴───┴───┴───┴───┴───────────────────────────────╢
    53                              <1> ; +3║                           BASE 15-0                           ║+2
    54                              <1> ;   ╟───────────────────────────────┴───────────────────────────────╢
    55                              <1> ; +1║                           LIMIT 15-0                          ║ 0
    56                              <1> ;   ╚═══════════════════════════════╧═══════════════════════════════╝
    57                              <1> ;    15                                                            0
    58                              <1> ;
    59                              <1> ; DS:EBX pointer to the descriptor table
    60                              <1> ; EAX segment selector
    61                              <1> ; ESI base
    62                              <1> ; EDI limit
    63                              <1> ; DL ext nibble (upper 4 bits)
    64                              <1> ; DH acc byte (P|DPL|S|TYPE|A)
    65                              <1> ;
    66                              <1> %macro initDescriptor 0
    67                              <1> 	and    eax, 0xFFF8
    68                              <1> 	add    ebx, eax
    69                              <1> 	mov    word [ebx], di   ; LIMIT 15-0
    70                              <1> 	mov    word [ebx+2], si ; BASE 15-0
    71                              <1> 	shr    esi, 16
    72                              <1> 	mov    ax, si           ; AX := BASE 31-16
    73                              <1> 	mov    byte [ebx+4], al ; BASE 23-16
    74                              <1> 	mov    byte [ebx+5], dh ; acc byte
    75                              <1> 	shr    edi, 16
    76                              <1> 	mov    cx, di
    77                              <1> 	and    cl, 0x0f
    78                              <1> 	mov    byte [ebx+6], cl ; LIMIT 19-16
    79                              <1> 	and    dl, 0xf0
    80                              <1> 	or     byte [ebx+6], dl ; ext nibble
    81                              <1> 	mov    byte [ebx+7], ah ; BASE 31-24
    82                              <1> %endmacro
    83                              <1> 
    84                              <1> 
    85                              <1> %macro advTestBase 0
    86                              <1> 	%assign TEST_BASE1 TEST_BASE1+0x1000
    87                              <1> 	%assign TEST_BASE2 TEST_BASE2+0x1000
    88                              <1> %endmacro
    65                                  
    66                                  	bits 16
    67                                  
    68                                  ;
    69                                  ; memory map:
    70                                  ;  00000-003FF real mode IDT
    71                                  ;  00400-004FF protected mode IDT
    72                                  ;  00500-0077F protected mode GDT
    73                                  ;  00800-00FFF protected mode LDT
    74                                  ;  01000-01FFF page directory
    75                                  ;  02000-02FFF page table 0
    76                                  ;  03000-03FFF page table 1
    77                                  ;  04000-04FFF TSS
    78                                  ;  10000-1FFFF stack
    79                                  ;  20000-9FFFF tests
    80                                  ;
    81                                  
    82                                  TEST_BASE  equ 0x20000
    83                                  %assign TEST_BASE1 TEST_BASE+0x00000
    84                                  %assign TEST_BASE2 TEST_BASE+0x40000
    85                                  
    86                                  ;
    87                                  ;   Real mode segments
    88                                  ;
    89                                  C_SEG_REAL   equ 0xf000
    90                                  S_SEG_REAL   equ 0x1000
    91                                  IDT_SEG_REAL equ 0x0040
    92                                  GDT_SEG_REAL equ 0x0050
    93                                  GDT_SEG_LIMIT equ 0x2FF
    94                                  %assign D1_SEG_REAL TEST_BASE1 >> 4
    95                                  %assign D2_SEG_REAL TEST_BASE2 >> 4
    96                                  
    97                                  ESP_REAL    equ 0xffff
    98                                  
    99                                  
   100                                  header:
   101 00000000 746573743338362E61-     	db COPYRIGHT
   101 00000009 736D20284329203230-
   101 00000012 31322D32303135204A-
   101 0000001B 65666620506172736F-
   101 00000024 6E732C202843292032-
   101 0000002D 3031372D3230323120-
   101 00000036 4D6172636F20426F72-
   101 0000003F 746F6C696E20       
   102                                  
   103                                  cpuTest:
   104 00000045 FA                      	cli
   105                                  
   106                                  
   107                                  ; ==============================================================================
   108                                  ;	Real mode tests
   109                                  ; ==============================================================================
   110                                  
   111                                  %include "real_m.asm"
     1                              <1> ;
     2                              <1> ; Advances the base address of data segments used by tests, D1_SEG_REAL and
     3                              <1> ; D2_SEG_REAL.
     4                              <1> ;
     5                              <1> ; Loads DS with D1_SEG_REAL and ES with D2_SEG_REAL.
     6                              <1> ;
     7                              <1> %macro advTestSegReal 0
     8                              <1> 	advTestBase
     9                              <1> 	%assign D1_SEG_REAL TEST_BASE1 >> 4
    10                              <1> 	%assign D2_SEG_REAL TEST_BASE2 >> 4
    11                              <1> 	mov    dx, D1_SEG_REAL
    12                              <1> 	mov    ds, dx
    13                              <1> 	mov    dx, D2_SEG_REAL
    14                              <1> 	mov    es, dx
    15                              <1> %endmacro
    16                              <1> 
    17                              <1> 
    18                              <1> ;
    19                              <1> ; Initialises the real mode IDT with C_SEG_REAL:error
    20                              <1> ;
    21                              <1> %macro initRealModeIDT 0
    22                              <1> 	xor    eax, eax
    23                              <1> 	mov    ds, ax
    24                              <1> 	mov    cx, 17
    25                              <1> %%loop:
    26                              <1> 	mov    [eax*4], word error
    27                              <1> 	mov    [2+eax*4], word C_SEG_REAL
    28                              <1> 	inc    ax
    29                              <1> 	loop   %%loop
    30                              <1> %endmacro
    31                              <1> 
    32                              <1> 
    33                              <1> ;
    34                              <1> ; Exception handling testing in real mode
    35                              <1> ;
    36                              <1> 
    37                              <1> ; Initialises an exc handler
    38                              <1> ; %1: vector
    39                              <1> ; %2: handler IP
    40                              <1> ; Trashes AX,DS
    41                              <1> %macro realModeExcInit 2
    42                              <1> 	mov    ax, 0
    43                              <1> 	mov    ds, ax
    44                              <1> 	mov    [%1*4], word %2
    45                              <1> 	mov    [%1*4+2], word C_SEG_REAL
    46                              <1> %endmacro
    47                              <1> 
    48                              <1> ; Checks exc result and restores the default handler
    49                              <1> ; %1: vector
    50                              <1> ; %2: expected pushed value of IP
    51                              <1> ; Trashes AX,DS
    52                              <1> %macro realModeExcCheck 2
    53                              <1> 	cmp    sp, ESP_REAL-6
    54                              <1> 	jne    error
    55                              <1> 	cmp    [ss:ESP_REAL-4], word C_SEG_REAL
    56                              <1> 	cmp    [ss:ESP_REAL-6], word %2
    57                              <1> 	jne    error
    58                              <1> 	mov    ax, 0
    59                              <1> 	mov    ds, ax
    60                              <1> 	mov    [%1*4], word error
    61                              <1> 	mov    [%1*4+2], word C_SEG_REAL
    62                              <1> %endmacro
    63                              <1> 
    64                              <1> 
    65                              <1> ; Tests a fault
    66                              <1> ; %1: vector
    67                              <1> ; %2: instruction to execute that causes a fault
    68                              <1> %macro realModeFaultTest 2+
    69                              <1> 	realModeExcInit %1, %%continue
    70                              <1> 	mov    ax, S_SEG_REAL
    71                              <1> 	mov    ss, ax
    72                              <1> 	mov    sp, ESP_REAL
    73                              <1> %%test:
    74                              <1> 	%2
    75                              <1> 	jmp    error
    76                              <1> %%continue:
    77                              <1> 	realModeExcCheck %1, %%test
    78                              <1> %endmacro
   112                                  ;-------------------------------------------------------------------------------
   113                                  	POST 0
     5 00000046 B000                <1>  mov al, 0x%1
     6 00000048 BA9909              <1>  mov dx, POST_PORT
     7 0000004B EE                  <1>  out dx, al
   114                                  ;-------------------------------------------------------------------------------
   115                                  ;
   116                                  ;   Real mode initialisation
   117                                  ;
   118                                  	initRealModeIDT
    22 0000004C 6631C0              <1>  xor eax, eax
    23 0000004F 8ED8                <1>  mov ds, ax
    24 00000051 B91100              <1>  mov cx, 17
    25                              <1> %%loop:
    26 00000054 67C7048500000000-   <1>  mov [eax*4], word error
    26 0000005C [C715]              <1>
    27 0000005E 67C704850200000000- <1>  mov [2+eax*4], word C_SEG_REAL
    27 00000067 F0                  <1>
    28 00000068 40                  <1>  inc ax
    29 00000069 E2E9                <1>  loop %%loop
   119 0000006B B80010                  	mov ax, S_SEG_REAL
   120 0000006E 8ED0                    	mov ss, ax
   121 00000070 BCFFFF                  	mov sp, ESP_REAL
   122 00000073 BA0020                  	mov dx, D1_SEG_REAL
   123 00000076 8EDA                    	mov ds, dx
   124 00000078 BA0060                  	mov dx, D2_SEG_REAL
   125 0000007B 8EC2                    	mov es, dx
   126                                  
   127                                  
   128                                  ;-------------------------------------------------------------------------------
   129                                  	POST 1
     5 0000007D B001                <1>  mov al, 0x%1
     6 0000007F BA9909              <1>  mov dx, POST_PORT
     7 00000082 EE                  <1>  out dx, al
   130                                  ;-------------------------------------------------------------------------------
   131                                  ;
   132                                  ;   Conditional jumps
   133                                  ;
   134                                  %include "tests/jcc_m.asm"
     1                              <1> ;
     2                              <1> ; Tests conditional relative jumps.
     3                              <1> ; Uses: AX, ECX, Flags
     4                              <1> ;
     5                              <1> ; Opcodes tested, with positive and negative offsets:
     6                              <1> ;
     7                              <1> ; rel8  rel16/32 mnemonic condition
     8                              <1> ; 70    0F80     JO       OF=1
     9                              <1> ; 71    0F81     JNO      OF=0
    10                              <1> ; 72    0F82     JC       CF=1
    11                              <1> ; 73    0F83     JNC      CF=0
    12                              <1> ; 74    0F84     JZ       ZF=1
    13                              <1> ; 75    0F85     JNZ      ZF=0
    14                              <1> ; 76    0F86     JBE      CF=1 || ZF=1
    15                              <1> ; 77    0F87     JA       CF=0 && ZF=0
    16                              <1> ; 78    0F88     JS       SF=1
    17                              <1> ; 79    0F89     JNS      SF=0
    18                              <1> ; 7A    0F8A     JP       PF=1
    19                              <1> ; 7B    0F8B     JNP      PF=0
    20                              <1> ; 7C    0F8C     JL       SF!=OF
    21                              <1> ; 7D    0F8D     JNL      SF=OF
    22                              <1> ; 7E    0F8E     JLE      ZF=1 || SF!=OF
    23                              <1> ; 7F    0F8F     JNLE     ZF=0 && SF=OF
    24                              <1> ; E3             JCXZ     CX=0
    25                              <1> ; E3             JECXZ    ECX=0
    26                              <1> ;
    27                              <1> %macro testJcc 1
    28                              <1> 	mov    ah, PS_CF
    29                              <1> 	sahf         ; don't use the stack (pushf/popf)
    30                              <1> 	jnc   %%err1 ; 73 / 0F83   JNC  CF=0
    31                              <1> 	jc    %%jcok ; 72 / 0F82   JC   CF=1
    32                              <1> 	hlt
    33                              <1> %%jz:
    34                              <1> 	mov    ah, PS_ZF
    35                              <1> 	sahf
    36                              <1> 	jnz   %%err1 ; 75 / 0F85   JNZ  ZF=0
    37                              <1> 	jz    %%jzok ; 74 / 0F84   JZ   ZF=1
    38                              <1> 	hlt
    39                              <1> %%jp:
    40                              <1> 	mov    ah, PS_PF
    41                              <1> 	sahf
    42                              <1> 	jnp   %%err1 ; 7B / 0F8B   JNP  PF=0
    43                              <1> 	jp    %%jpok ; 7A / 0F8A   JP   PF=1
    44                              <1> 	hlt
    45                              <1> %%js:
    46                              <1> 	mov    ah, PS_SF
    47                              <1> 	sahf
    48                              <1> 	jns   %%err1 ; 79 / 0F89   JNS  SF=0
    49                              <1> 	js    %%jsok ; 78 / 0F88   JS   SF=1
    50                              <1> 	hlt
    51                              <1> %%jna:
    52                              <1> 	mov    ah, PS_ZF|PS_CF
    53                              <1> 	sahf
    54                              <1> 	ja    %%err1  ; 77 / 0F87   JA   CF=0 && ZF=0
    55                              <1> 	jna   %%jnaok ; 76 / 0F86   JBE  CF=1 || ZF=1
    56                              <1> %%next1:
    57                              <1> 	jmp %%jnc
    58                              <1> 
    59                              <1> %if %1==16
    60                              <1> 	times  128 hlt
    61                              <1> %endif
    62                              <1> 
    63                              <1> %%err1:
    64                              <1> 	hlt
    65                              <1> 
    66                              <1> ; test negative offsets
    67                              <1> %%jcok:   jc   %%jz
    68                              <1> %%jzok:   jz   %%jp
    69                              <1> %%jpok:   jp   %%js
    70                              <1> %%jsok:   js   %%jna
    71                              <1> %%jnaok:  jna  %%next1
    72                              <1> 
    73                              <1> 
    74                              <1> %%jnc:
    75                              <1> 	mov    ah, PS_SF|PS_ZF|PS_AF|PS_PF
    76                              <1> 	sahf
    77                              <1> 	mov    ax, 0
    78                              <1> 	sahf
    79                              <1> 	jnc   %%jncok ; 73 / 0F83   JNC  CF=0
    80                              <1> 	hlt
    81                              <1> %%jnz:
    82                              <1> 	mov    ah, PS_SF|PS_AF|PS_PF|PS_CF
    83                              <1> 	sahf
    84                              <1> 	jnz   %%jnzok ; 75 / 0F85   JNZ  ZF=0
    85                              <1> 	hlt
    86                              <1> %%jnp:
    87                              <1> 	mov    ah, PS_SF|PS_ZF|PS_AF|PS_CF
    88                              <1> 	sahf
    89                              <1> 	jnp   %%jnpok ; 7B / 0F8B   JNP  PF=0
    90                              <1> 	hlt
    91                              <1> %%jns:
    92                              <1> 	mov    ah, PS_ZF|PS_AF|PS_PF|PS_CF
    93                              <1> 	sahf
    94                              <1> 	jns   %%jnsok ; 79 /  0F89  JNS  SF=0
    95                              <1> 	hlt
    96                              <1> %%ja:
    97                              <1> 	mov    ah, PS_SF|PS_AF|PS_PF
    98                              <1> 	sahf
    99                              <1> 	ja    %%jaok  ; 77 / 0F87   JA   CF=0 && ZF=0
   100                              <1> 	hlt
   101                              <1> %%next2:
   102                              <1> 	jmp   %%jo
   103                              <1> 
   104                              <1> %if %1==16
   105                              <1> 	times  128 hlt
   106                              <1> %endif
   107                              <1> 
   108                              <1> ; test negative offsets
   109                              <1> %%jncok:  jnc  %%jnz
   110                              <1> %%jnzok:  jnz  %%jnp
   111                              <1> %%jnpok:  jnp  %%jns
   112                              <1> %%jnsok:  jns  %%ja
   113                              <1> %%jaok:   ja   %%next2
   114                              <1> 
   115                              <1> %%jo:
   116                              <1> 	mov    ah, 0
   117                              <1> 	sahf
   118                              <1> 	mov   al, 1000000b
   119                              <1> 	shl   al, 1    ; OF = high-order bit of AL <> (CF), ZF=0,SF=1,OF=1
   120                              <1> 	jno   %%err2
   121                              <1> 	jo    %%jook
   122                              <1> 	hlt
   123                              <1> %%jnl:
   124                              <1> 	jl    %%err2   ; 7C / 0F8C   JL   SF!=OF
   125                              <1> 	jnl   %%jnlok  ; 7D / 0F8D   JNL  SF=OF
   126                              <1> 	hlt
   127                              <1> %%jnle:
   128                              <1> 	jle   %%err2   ; 7E / 0F8E   JLE  ZF=1 || SF!=OF
   129                              <1> 	jnle  %%jnleok ; 7F / 0F8F   JNLE ZF=0 && SF=OF
   130                              <1> 	hlt
   131                              <1> %%jl:
   132                              <1> 	mov ah, PS_ZF
   133                              <1> 	sahf           ; ZF=1,SF=0,OF=1
   134                              <1> 	jl    %%jlok   ; 7C / 0F8C   JL   SF!=OF
   135                              <1> 	hlt
   136                              <1> %%jle:
   137                              <1> 	jle   %%jleok  ; 7E / 0F8E   JLE  ZF=1 || SF!=OF
   138                              <1> 	hlt
   139                              <1> %%jcxz:
   140                              <1> %if %1==8
   141                              <1> 	mov ecx, 1
   142                              <1> 	jcxz %%err2      ; E3   JCXZ  CX=0
   143                              <1> 	mov ecx, 0x10000
   144                              <1> 	jcxz %%jcxzok
   145                              <1> %%jecxz:
   146                              <1> 	jecxz %%err2
   147                              <1> 	mov ecx, 0
   148                              <1> 	jecxz %%jecxzok ; E3   JECXZ   ECX=0
   149                              <1> %%jecxze:
   150                              <1> %endif
   151                              <1> 	jmp %%exit
   152                              <1> 
   153                              <1> %if %1==16
   154                              <1> 	times  128 hlt
   155                              <1> %endif
   156                              <1> 
   157                              <1> %%err2:
   158                              <1> 	hlt
   159                              <1> 
   160                              <1> ; test negative offsets
   161                              <1> %%jook:   jo   %%jnl
   162                              <1> %%jnlok:  jnl  %%jnle
   163                              <1> %%jnleok: jnle %%jl
   164                              <1> %%jlok:   jl   %%jle
   165                              <1> %%jleok:  jle  %%jcxz
   166                              <1> %if %1==8
   167                              <1> %%jcxzok:  jcxz  %%jecxz
   168                              <1> %%jecxzok: jecxz %%jecxze
   169                              <1> %endif
   170                              <1> 
   171                              <1> %%exit:
   172                              <1> %endmacro
   173                              <1> 
   135                                  	testJcc 8
    28 00000083 B401                <1>  mov ah, PS_CF
    29 00000085 9E                  <1>  sahf
    30 00000086 7324                <1>  jnc %%err1
    31 00000088 7223                <1>  jc %%jcok
    32 0000008A F4                  <1>  hlt
    33                              <1> %%jz:
    34 0000008B B440                <1>  mov ah, PS_ZF
    35 0000008D 9E                  <1>  sahf
    36 0000008E 751C                <1>  jnz %%err1
    37 00000090 741D                <1>  jz %%jzok
    38 00000092 F4                  <1>  hlt
    39                              <1> %%jp:
    40 00000093 B404                <1>  mov ah, PS_PF
    41 00000095 9E                  <1>  sahf
    42 00000096 7B14                <1>  jnp %%err1
    43 00000098 7A17                <1>  jp %%jpok
    44 0000009A F4                  <1>  hlt
    45                              <1> %%js:
    46 0000009B B480                <1>  mov ah, PS_SF
    47 0000009D 9E                  <1>  sahf
    48 0000009E 790C                <1>  jns %%err1
    49 000000A0 7811                <1>  js %%jsok
    50 000000A2 F4                  <1>  hlt
    51                              <1> %%jna:
    52 000000A3 B441                <1>  mov ah, PS_ZF|PS_CF
    53 000000A5 9E                  <1>  sahf
    54 000000A6 7704                <1>  ja %%err1
    55 000000A8 760B                <1>  jna %%jnaok
    56                              <1> %%next1:
    57 000000AA EB0B                <1>  jmp %%jnc
    58                              <1> 
    59                              <1> %if %1==16
    60                              <1>  times 128 hlt
    61                              <1> %endif
    62                              <1> 
    63                              <1> %%err1:
    64 000000AC F4                  <1>  hlt
    65                              <1> 
    66                              <1> 
    67 000000AD 72DC                <1> %%jcok: jc %%jz
    68 000000AF 74E2                <1> %%jzok: jz %%jp
    69 000000B1 7AE8                <1> %%jpok: jp %%js
    70 000000B3 78EE                <1> %%jsok: js %%jna
    71 000000B5 76F3                <1> %%jnaok: jna %%next1
    72                              <1> 
    73                              <1> 
    74                              <1> %%jnc:
    75 000000B7 B4D4                <1>  mov ah, PS_SF|PS_ZF|PS_AF|PS_PF
    76 000000B9 9E                  <1>  sahf
    77 000000BA B80000              <1>  mov ax, 0
    78 000000BD 9E                  <1>  sahf
    79 000000BE 731B                <1>  jnc %%jncok
    80 000000C0 F4                  <1>  hlt
    81                              <1> %%jnz:
    82 000000C1 B495                <1>  mov ah, PS_SF|PS_AF|PS_PF|PS_CF
    83 000000C3 9E                  <1>  sahf
    84 000000C4 7517                <1>  jnz %%jnzok
    85 000000C6 F4                  <1>  hlt
    86                              <1> %%jnp:
    87 000000C7 B4D1                <1>  mov ah, PS_SF|PS_ZF|PS_AF|PS_CF
    88 000000C9 9E                  <1>  sahf
    89 000000CA 7B13                <1>  jnp %%jnpok
    90 000000CC F4                  <1>  hlt
    91                              <1> %%jns:
    92 000000CD B455                <1>  mov ah, PS_ZF|PS_AF|PS_PF|PS_CF
    93 000000CF 9E                  <1>  sahf
    94 000000D0 790F                <1>  jns %%jnsok
    95 000000D2 F4                  <1>  hlt
    96                              <1> %%ja:
    97 000000D3 B494                <1>  mov ah, PS_SF|PS_AF|PS_PF
    98 000000D5 9E                  <1>  sahf
    99 000000D6 770B                <1>  ja %%jaok
   100 000000D8 F4                  <1>  hlt
   101                              <1> %%next2:
   102 000000D9 EB0A                <1>  jmp %%jo
   103                              <1> 
   104                              <1> %if %1==16
   105                              <1>  times 128 hlt
   106                              <1> %endif
   107                              <1> 
   108                              <1> 
   109 000000DB 73E4                <1> %%jncok: jnc %%jnz
   110 000000DD 75E8                <1> %%jnzok: jnz %%jnp
   111 000000DF 7BEC                <1> %%jnpok: jnp %%jns
   112 000000E1 79F0                <1> %%jnsok: jns %%ja
   113 000000E3 77F4                <1> %%jaok: ja %%next2
   114                              <1> 
   115                              <1> %%jo:
   116 000000E5 B400                <1>  mov ah, 0
   117 000000E7 9E                  <1>  sahf
   118 000000E8 B040                <1>  mov al, 1000000b
   119 000000EA D0E0                <1>  shl al, 1
   120 000000EC 7134                <1>  jno %%err2
   121 000000EE 7033                <1>  jo %%jook
   122 000000F0 F4                  <1>  hlt
   123                              <1> %%jnl:
   124 000000F1 7C2F                <1>  jl %%err2
   125 000000F3 7D30                <1>  jnl %%jnlok
   126 000000F5 F4                  <1>  hlt
   127                              <1> %%jnle:
   128 000000F6 7E2A                <1>  jle %%err2
   129 000000F8 7F2D                <1>  jnle %%jnleok
   130 000000FA F4                  <1>  hlt
   131                              <1> %%jl:
   132 000000FB B440                <1>  mov ah, PS_ZF
   133 000000FD 9E                  <1>  sahf
   134 000000FE 7C29                <1>  jl %%jlok
   135 00000100 F4                  <1>  hlt
   136                              <1> %%jle:
   137 00000101 7E28                <1>  jle %%jleok
   138 00000103 F4                  <1>  hlt
   139                              <1> %%jcxz:
   140                              <1> %if %1==8
   141 00000104 66B901000000        <1>  mov ecx, 1
   142 0000010A E316                <1>  jcxz %%err2
   143 0000010C 66B900000100        <1>  mov ecx, 0x10000
   144 00000112 E319                <1>  jcxz %%jcxzok
   145                              <1> %%jecxz:
   146 00000114 67E30B              <1>  jecxz %%err2
   147 00000117 66B900000000        <1>  mov ecx, 0
   148 0000011D 67E30F              <1>  jecxz %%jecxzok
   149                              <1> %%jecxze:
   150                              <1> %endif
   151 00000120 EB10                <1>  jmp %%exit
   152                              <1> 
   153                              <1> %if %1==16
   154                              <1>  times 128 hlt
   155                              <1> %endif
   156                              <1> 
   157                              <1> %%err2:
   158 00000122 F4                  <1>  hlt
   159                              <1> 
   160                              <1> 
   161 00000123 70CC                <1> %%jook: jo %%jnl
   162 00000125 7DCF                <1> %%jnlok: jnl %%jnle
   163 00000127 7FD2                <1> %%jnleok: jnle %%jl
   164 00000129 7CD6                <1> %%jlok: jl %%jle
   165 0000012B 7ED7                <1> %%jleok: jle %%jcxz
   166                              <1> %if %1==8
   167 0000012D E3E5                <1> %%jcxzok: jcxz %%jecxz
   168 0000012F 67E3EE              <1> %%jecxzok: jecxz %%jecxze
   169                              <1> %endif
   170                              <1> 
   171                              <1> %%exit:
   136                                  	testJcc 16
    28 00000132 B401                <1>  mov ah, PS_CF
    29 00000134 9E                  <1>  sahf
    30 00000135 0F83B700            <1>  jnc %%err1
    31 00000139 0F82B400            <1>  jc %%jcok
    32 0000013D F4                  <1>  hlt
    33                              <1> %%jz:
    34 0000013E B440                <1>  mov ah, PS_ZF
    35 00000140 9E                  <1>  sahf
    36 00000141 0F85AB00            <1>  jnz %%err1
    37 00000145 0F84AC00            <1>  jz %%jzok
    38 00000149 F4                  <1>  hlt
    39                              <1> %%jp:
    40 0000014A B404                <1>  mov ah, PS_PF
    41 0000014C 9E                  <1>  sahf
    42 0000014D 0F8B9F00            <1>  jnp %%err1
    43 00000151 0F8AA400            <1>  jp %%jpok
    44 00000155 F4                  <1>  hlt
    45                              <1> %%js:
    46 00000156 B480                <1>  mov ah, PS_SF
    47 00000158 9E                  <1>  sahf
    48 00000159 0F899300            <1>  jns %%err1
    49 0000015D 0F889C00            <1>  js %%jsok
    50 00000161 F4                  <1>  hlt
    51                              <1> %%jna:
    52 00000162 B441                <1>  mov ah, PS_ZF|PS_CF
    53 00000164 9E                  <1>  sahf
    54 00000165 0F878700            <1>  ja %%err1
    55 00000169 0F869400            <1>  jna %%jnaok
    56                              <1> %%next1:
    57 0000016D E99500              <1>  jmp %%jnc
    58                              <1> 
    59                              <1> %if %1==16
    60 00000170 F4<rep 80h>         <1>  times 128 hlt
    61                              <1> %endif
    62                              <1> 
    63                              <1> %%err1:
    64 000001F0 F4                  <1>  hlt
    65                              <1> 
    66                              <1> 
    67 000001F1 0F8249FF            <1> %%jcok: jc %%jz
    68 000001F5 0F8451FF            <1> %%jzok: jz %%jp
    69 000001F9 0F8A59FF            <1> %%jpok: jp %%js
    70 000001FD 0F8861FF            <1> %%jsok: js %%jna
    71 00000201 0F8668FF            <1> %%jnaok: jna %%next1
    72                              <1> 
    73                              <1> 
    74                              <1> %%jnc:
    75 00000205 B4D4                <1>  mov ah, PS_SF|PS_ZF|PS_AF|PS_PF
    76 00000207 9E                  <1>  sahf
    77 00000208 B80000              <1>  mov ax, 0
    78 0000020B 9E                  <1>  sahf
    79 0000020C 0F83A400            <1>  jnc %%jncok
    80 00000210 F4                  <1>  hlt
    81                              <1> %%jnz:
    82 00000211 B495                <1>  mov ah, PS_SF|PS_AF|PS_PF|PS_CF
    83 00000213 9E                  <1>  sahf
    84 00000214 0F85A000            <1>  jnz %%jnzok
    85 00000218 F4                  <1>  hlt
    86                              <1> %%jnp:
    87 00000219 B4D1                <1>  mov ah, PS_SF|PS_ZF|PS_AF|PS_CF
    88 0000021B 9E                  <1>  sahf
    89 0000021C 0F8B9C00            <1>  jnp %%jnpok
    90 00000220 F4                  <1>  hlt
    91                              <1> %%jns:
    92 00000221 B455                <1>  mov ah, PS_ZF|PS_AF|PS_PF|PS_CF
    93 00000223 9E                  <1>  sahf
    94 00000224 0F899800            <1>  jns %%jnsok
    95 00000228 F4                  <1>  hlt
    96                              <1> %%ja:
    97 00000229 B494                <1>  mov ah, PS_SF|PS_AF|PS_PF
    98 0000022B 9E                  <1>  sahf
    99 0000022C 0F879400            <1>  ja %%jaok
   100 00000230 F4                  <1>  hlt
   101                              <1> %%next2:
   102 00000231 E99400              <1>  jmp %%jo
   103                              <1> 
   104                              <1> %if %1==16
   105 00000234 F4<rep 80h>         <1>  times 128 hlt
   106                              <1> %endif
   107                              <1> 
   108                              <1> 
   109 000002B4 0F8359FF            <1> %%jncok: jnc %%jnz
   110 000002B8 0F855DFF            <1> %%jnzok: jnz %%jnp
   111 000002BC 0F8B61FF            <1> %%jnpok: jnp %%jns
   112 000002C0 0F8965FF            <1> %%jnsok: jns %%ja
   113 000002C4 0F8769FF            <1> %%jaok: ja %%next2
   114                              <1> 
   115                              <1> %%jo:
   116 000002C8 B400                <1>  mov ah, 0
   117 000002CA 9E                  <1>  sahf
   118 000002CB B040                <1>  mov al, 1000000b
   119 000002CD D0E0                <1>  shl al, 1
   120 000002CF 0F81A700            <1>  jno %%err2
   121 000002D3 0F80A400            <1>  jo %%jook
   122 000002D7 F4                  <1>  hlt
   123                              <1> %%jnl:
   124 000002D8 0F8C9E00            <1>  jl %%err2
   125 000002DC 0F8D9F00            <1>  jnl %%jnlok
   126 000002E0 F4                  <1>  hlt
   127                              <1> %%jnle:
   128 000002E1 0F8E9500            <1>  jle %%err2
   129 000002E5 0F8F9A00            <1>  jnle %%jnleok
   130 000002E9 F4                  <1>  hlt
   131                              <1> %%jl:
   132 000002EA B440                <1>  mov ah, PS_ZF
   133 000002EC 9E                  <1>  sahf
   134 000002ED 0F8C9600            <1>  jl %%jlok
   135 000002F1 F4                  <1>  hlt
   136                              <1> %%jle:
   137 000002F2 0F8E9500            <1>  jle %%jleok
   138 000002F6 F4                  <1>  hlt
   139                              <1> %%jcxz:
   140                              <1> %if %1==8
   141                              <1>  mov ecx, 1
   142                              <1>  jcxz %%err2
   143                              <1>  mov ecx, 0x10000
   144                              <1>  jcxz %%jcxzok
   145                              <1> %%jecxz:
   146                              <1>  jecxz %%err2
   147                              <1>  mov ecx, 0
   148                              <1>  jecxz %%jecxzok
   149                              <1> %%jecxze:
   150                              <1> %endif
   151 000002F7 E99500              <1>  jmp %%exit
   152                              <1> 
   153                              <1> %if %1==16
   154 000002FA F4<rep 80h>         <1>  times 128 hlt
   155                              <1> %endif
   156                              <1> 
   157                              <1> %%err2:
   158 0000037A F4                  <1>  hlt
   159                              <1> 
   160                              <1> 
   161 0000037B 0F8059FF            <1> %%jook: jo %%jnl
   162 0000037F 0F8D5EFF            <1> %%jnlok: jnl %%jnle
   163 00000383 0F8F63FF            <1> %%jnleok: jnle %%jl
   164 00000387 0F8C67FF            <1> %%jlok: jl %%jle
   165 0000038B 0F8E68FF            <1> %%jleok: jle %%jcxz
   166                              <1> %if %1==8
   167                              <1> %%jcxzok: jcxz %%jecxz
   168                              <1> %%jecxzok: jecxz %%jecxze
   169                              <1> %endif
   170                              <1> 
   171                              <1> %%exit:
   137                                  
   138                                  ;
   139                                  ;   Loops
   140                                  ;
   141                                  %include "tests/loop_m.asm"
     1                              <1> ;
     2                              <1> ;   Test of loop, loopz, loopnz
     3                              <1> ;   Use: EAX, ECX, Flags
     4                              <1> ;
     5                              <1> 
     6                              <1> %macro testLoop 0
     7                              <1> 
     8                              <1> 	mov ecx, 0x20000
     9                              <1> 	mov eax, 0
    10                              <1> %%loop16:
    11                              <1> 	inc eax
    12                              <1> 	a16 loop %%loop16
    13                              <1> 	cmp eax, 0x10000
    14                              <1> 	jne error
    15                              <1> 	cmp ecx, 0x20000
    16                              <1> 	jne error
    17                              <1> 
    18                              <1> 	mov ecx, 0x20000
    19                              <1> 	mov eax, 0
    20                              <1> %%loop32:
    21                              <1> 	inc eax
    22                              <1> 	a32 loop %%loop32
    23                              <1> 	cmp eax, 0x20000
    24                              <1> 	jne error
    25                              <1> 	cmp ecx, 0
    26                              <1> 	jne error
    27                              <1> 
    28                              <1> %endmacro
    29                              <1> 
    30                              <1> %macro testLoopZ 0
    31                              <1> 
    32                              <1> 	mov cx, 0xFFFF
    33                              <1> 	mov ax, 0
    34                              <1> %%loop16a:
    35                              <1> 	inc ax
    36                              <1> 	cmp ah, 0
    37                              <1> 	a16 loopz %%loop16a
    38                              <1> 	cmp ax, 0x0100
    39                              <1> 	jne error
    40                              <1> 	cmp cx, 0xFEFF
    41                              <1> 	jne error
    42                              <1> 
    43                              <1> 	mov cx, 0x00FF
    44                              <1> 	mov ax, 0
    45                              <1> %%loop16b:
    46                              <1> 	inc ax
    47                              <1> 	cmp ah, 0
    48                              <1> 	a16 loopz %%loop16b
    49                              <1> 	cmp ax, 0x00FF
    50                              <1> 	jne error
    51                              <1> 	cmp cx, 0
    52                              <1> 	jne error
    53                              <1> 
    54                              <1> 	mov ecx, 0x20000
    55                              <1> 	mov eax, 0
    56                              <1> %%loop32:
    57                              <1> 	inc eax
    58                              <1> 	test eax, 0x10000
    59                              <1> 	a32 loopz %%loop32
    60                              <1> 	cmp eax, 0x10000
    61                              <1> 	jne error
    62                              <1> 	cmp ecx, 0x10000
    63                              <1> 	jne error
    64                              <1> 
    65                              <1> %endmacro
    66                              <1> 
    67                              <1> %macro testLoopNZ 0
    68                              <1> 
    69                              <1> 	mov cx, 0xFFFF
    70                              <1> 	mov ax, 0
    71                              <1> %%loop16a:
    72                              <1> 	inc ax
    73                              <1> 	test al, 0xFF
    74                              <1> 	a16 loopnz %%loop16a
    75                              <1> 	cmp ax, 0x0100
    76                              <1> 	jne error
    77                              <1> 	cmp cx, 0xFEFF
    78                              <1> 	jne error
    79                              <1> 
    80                              <1> 	mov cx, 0x00FF
    81                              <1> 	mov ax, 0
    82                              <1> %%loop16b:
    83                              <1> 	inc ax
    84                              <1> 	test al, 0xFF
    85                              <1> 	a16 loopnz %%loop16b
    86                              <1> 	cmp ax, 0x00FF
    87                              <1> 	jne error
    88                              <1> 	cmp cx, 0
    89                              <1> 	jne error
    90                              <1> 
    91                              <1> 	mov ecx, 0x10000
    92                              <1> 	mov eax, 0
    93                              <1> %%loop32:
    94                              <1> 	inc eax
    95                              <1> 	test eax, 0x0FFFF
    96                              <1> 	a32 loopnz %%loop32
    97                              <1> 	cmp eax, 0x10000
    98                              <1> 	jne error
    99                              <1> 	cmp ecx, 0
   100                              <1> 	jne error
   101                              <1> 
   102                              <1> %endmacro
   142                                  	testLoop
     7                              <1> 
     8 0000038F 66B900000200        <1>  mov ecx, 0x20000
     9 00000395 66B800000000        <1>  mov eax, 0
    10                              <1> %%loop16:
    11 0000039B 6640                <1>  inc eax
    12 0000039D E2FC                <1>  a16 loop %%loop16
    13 0000039F 663D00000100        <1>  cmp eax, 0x10000
    14 000003A5 0F851E12            <1>  jne error
    15 000003A9 6681F900000200      <1>  cmp ecx, 0x20000
    16 000003B0 0F851312            <1>  jne error
    17                              <1> 
    18 000003B4 66B900000200        <1>  mov ecx, 0x20000
    19 000003BA 66B800000000        <1>  mov eax, 0
    20                              <1> %%loop32:
    21 000003C0 6640                <1>  inc eax
    22 000003C2 67E2FB              <1>  a32 loop %%loop32
    23 000003C5 663D00000200        <1>  cmp eax, 0x20000
    24 000003CB 0F85F811            <1>  jne error
    25 000003CF 6683F900            <1>  cmp ecx, 0
    26 000003D3 0F85F011            <1>  jne error
    27                              <1> 
   143                                  	testLoopZ
    31                              <1> 
    32 000003D7 B9FFFF              <1>  mov cx, 0xFFFF
    33 000003DA B80000              <1>  mov ax, 0
    34                              <1> %%loop16a:
    35 000003DD 40                  <1>  inc ax
    36 000003DE 80FC00              <1>  cmp ah, 0
    37 000003E1 E1FA                <1>  a16 loopz %%loop16a
    38 000003E3 3D0001              <1>  cmp ax, 0x0100
    39 000003E6 0F85DD11            <1>  jne error
    40 000003EA 81F9FFFE            <1>  cmp cx, 0xFEFF
    41 000003EE 0F85D511            <1>  jne error
    42                              <1> 
    43 000003F2 B9FF00              <1>  mov cx, 0x00FF
    44 000003F5 B80000              <1>  mov ax, 0
    45                              <1> %%loop16b:
    46 000003F8 40                  <1>  inc ax
    47 000003F9 80FC00              <1>  cmp ah, 0
    48 000003FC E1FA                <1>  a16 loopz %%loop16b
    49 000003FE 3DFF00              <1>  cmp ax, 0x00FF
    50 00000401 0F85C211            <1>  jne error
    51 00000405 83F900              <1>  cmp cx, 0
    52 00000408 0F85BB11            <1>  jne error
    53                              <1> 
    54 0000040C 66B900000200        <1>  mov ecx, 0x20000
    55 00000412 66B800000000        <1>  mov eax, 0
    56                              <1> %%loop32:
    57 00000418 6640                <1>  inc eax
    58 0000041A 66A900000100        <1>  test eax, 0x10000
    59 00000420 67E1F5              <1>  a32 loopz %%loop32
    60 00000423 663D00000100        <1>  cmp eax, 0x10000
    61 00000429 0F859A11            <1>  jne error
    62 0000042D 6681F900000100      <1>  cmp ecx, 0x10000
    63 00000434 0F858F11            <1>  jne error
    64                              <1> 
   144                                  	testLoopNZ
    68                              <1> 
    69 00000438 B9FFFF              <1>  mov cx, 0xFFFF
    70 0000043B B80000              <1>  mov ax, 0
    71                              <1> %%loop16a:
    72 0000043E 40                  <1>  inc ax
    73 0000043F A8FF                <1>  test al, 0xFF
    74 00000441 E0FB                <1>  a16 loopnz %%loop16a
    75 00000443 3D0001              <1>  cmp ax, 0x0100
    76 00000446 0F857D11            <1>  jne error
    77 0000044A 81F9FFFE            <1>  cmp cx, 0xFEFF
    78 0000044E 0F857511            <1>  jne error
    79                              <1> 
    80 00000452 B9FF00              <1>  mov cx, 0x00FF
    81 00000455 B80000              <1>  mov ax, 0
    82                              <1> %%loop16b:
    83 00000458 40                  <1>  inc ax
    84 00000459 A8FF                <1>  test al, 0xFF
    85 0000045B E0FB                <1>  a16 loopnz %%loop16b
    86 0000045D 3DFF00              <1>  cmp ax, 0x00FF
    87 00000460 0F856311            <1>  jne error
    88 00000464 83F900              <1>  cmp cx, 0
    89 00000467 0F855C11            <1>  jne error
    90                              <1> 
    91 0000046B 66B900000100        <1>  mov ecx, 0x10000
    92 00000471 66B800000000        <1>  mov eax, 0
    93                              <1> %%loop32:
    94 00000477 6640                <1>  inc eax
    95 00000479 66A9FFFF0000        <1>  test eax, 0x0FFFF
    96 0000047F 67E0F5              <1>  a32 loopnz %%loop32
    97 00000482 663D00000100        <1>  cmp eax, 0x10000
    98 00000488 0F853B11            <1>  jne error
    99 0000048C 6683F900            <1>  cmp ecx, 0
   100 00000490 0F853311            <1>  jne error
   101                              <1> 
   145                                  
   146                                  
   147                                  ;-------------------------------------------------------------------------------
   148                                  	POST 2
     5 00000494 B002                <1>  mov al, 0x%1
     6 00000496 BA9909              <1>  mov dx, POST_PORT
     7 00000499 EE                  <1>  out dx, al
   149                                  ;-------------------------------------------------------------------------------
   150                                  ;
   151                                  ;   Quick tests of unsigned 32-bit multiplication and division
   152                                  ;   Thorough arithmetical and logical tests are done later
   153                                  ;
   154 0000049A 66B801000080            	mov    eax, 0x80000001
   155 000004A0 66F7E8                  	imul   eax
   156 000004A3 66B811223344            	mov    eax, 0x44332211
   157 000004A9 6689C3                  	mov    ebx, eax
   158 000004AC 66B955667788            	mov    ecx, 0x88776655
   159 000004B2 66F7E1                  	mul    ecx
   160 000004B5 66F7F1                  	div    ecx
   161 000004B8 6639D8                  	cmp    eax, ebx
   162 000004BB 0F850811                	jne    error
   163                                  
   164                                  
   165                                  %include "tests/mov_m.asm"
     1                              <1> ;
     2                              <1> ;   Tests MOV from segment registers in real mode
     3                              <1> ;
     4                              <1> ;   %1 the segment register to test
     5                              <1> ;
     6                              <1> %macro testMovSegR_real 1
     7                              <1> 	%if %1 = cs
     8                              <1> 	mov    dx, C_SEG_REAL
     9                              <1> 	%else
    10                              <1> 	mov    dx, D1_SEG_REAL
    11                              <1> 	%endif
    12                              <1> 
    13                              <1> 	; MOV reg to Sreg
    14                              <1> 	%if %1 = cs
    15                              <1> 	realModeFaultTest EX_UD, mov %1,dx ; test for #UD
    16                              <1> 	%else
    17                              <1> 	mov    %1, dx
    18                              <1> 	%endif
    19                              <1> 
    20                              <1> 	; MOV Sreg to 16 bit reg
    21                              <1> 	xor    ax, ax
    22                              <1> 	mov    ax, %1
    23                              <1> 	cmp    ax, dx
    24                              <1> 	jne    error
    25                              <1> 
    26                              <1> 	; MOV Sreg to 32 bit reg
    27                              <1> 	mov    eax, -1
    28                              <1> 	mov    eax, %1
    29                              <1> 	; bits 31:16 are undefined for Pentium and earlier processors.
    30                              <1> 	; TODO: verify on real hw and check TEST_UNDEF
    31                              <1> 	cmp    ax, dx
    32                              <1> 	jne    error
    33                              <1> 
    34                              <1> 	; MOV Sreg to word mem
    35                              <1> 	mov    [0], word 0xbeef
    36                              <1> 	mov    [0], %1
    37                              <1> 	cmp    [0], dx
    38                              <1> 	jne    error
    39                              <1> 
    40                              <1> 	; MOV word mem to Sreg
    41                              <1> 	%if %1 = cs
    42                              <1> 	realModeFaultTest EX_UD, mov %1,[0] ; test for #UD
    43                              <1> 	%else
    44                              <1> 	mov    cx, ds ; save current DS in CX
    45                              <1> 	xor    ax, ax
    46                              <1> 	mov    %1, ax
    47                              <1> 	%if %1 = ds
    48                              <1> 	mov    es, cx
    49                              <1> 	mov    %1, [es:0]
    50                              <1> 	%else
    51                              <1> 	mov    %1, [0]
    52                              <1> 	%endif
    53                              <1> 	mov    ax, %1
    54                              <1> 	cmp    ax, dx
    55                              <1> 	jne    error
    56                              <1> 	%endif
    57                              <1> 
    58                              <1> %endmacro
    59                              <1> 
    60                              <1> 
    61                              <1> %macro testMovSegR_prot 1
    62                              <1> 	mov    edx, -1
    63                              <1> 	%if %1 = cs
    64                              <1> 	mov    dx, C_SEG_PROT32
    65                              <1> 	%else
    66                              <1> 	mov    dx, D1_SEG_PROT
    67                              <1> 	%endif
    68                              <1> 
    69                              <1> 	; MOV reg to Sreg
    70                              <1> 	%if %1 = cs
    71                              <1> 	loadProtModeStack
    72                              <1> 	protModeFaultTest EX_UD, 0, mov %1,dx ; #UD: attempt is made to load the CS register.
    73                              <1> 	%else
    74                              <1> 	mov    %1, dx
    75                              <1> 	%endif
    76                              <1> 
    77                              <1> 	; MOV Sreg to 16 bit reg
    78                              <1> 	xor    ax, ax
    79                              <1> 	mov    ax, %1
    80                              <1> 	cmp    ax, dx
    81                              <1> 	jne    error
    82                              <1> 
    83                              <1> 	; MOV Sreg to 32 bit reg
    84                              <1> 	mov    eax, -1
    85                              <1> 	mov    eax, %1
    86                              <1> 	; bits 31:16 are undefined for Pentium and earlier processors.
    87                              <1> 	; TODO: verify on real hw and check TEST_UNDEF
    88                              <1> 	cmp    ax, dx
    89                              <1> 	jne    error
    90                              <1> 
    91                              <1> 	; MOV Sreg to word mem
    92                              <1> 	mov    [0], dword -1
    93                              <1> 	mov    [0], %1
    94                              <1> 	cmp    [0], edx
    95                              <1> 	jne    error
    96                              <1> 
    97                              <1> 	; MOV word mem to Sreg
    98                              <1> 	%if %1 = cs
    99                              <1> 	protModeFaultTest EX_UD, 0, mov %1,[0] ; test for #UD
   100                              <1> 	%else
   101                              <1> 	mov    cx, ds ; save current DS in CX
   102                              <1> 	mov    ax, DTEST_SEG_PROT
   103                              <1> 	mov    %1, ax
   104                              <1> 	%if %1 = ds
   105                              <1> 	mov    es, cx
   106                              <1> 	mov    %1, [es:0]
   107                              <1> 	%else
   108                              <1> 	mov    %1, [0]
   109                              <1> 	%endif
   110                              <1> 	mov    ax, %1
   111                              <1> 	cmp    ax, dx
   112                              <1> 	jne    error
   113                              <1> 	%endif
   114                              <1> 
   115                              <1> 	loadProtModeStack
   116                              <1> 	%if %1 = ss
   117                              <1> 	; #GP(0) If attempt is made to load SS register with NULL segment selector.
   118                              <1> 	mov ax, NULL
   119                              <1> 	protModeFaultTest EX_GP, 0, mov %1,ax
   120                              <1> 	; #GP(selector) If the SS register is being loaded and the segment selector's RPL and the segment descriptor’s DPL are not equal to the CPL.
   121                              <1> 	mov ax, DPL1_SEG_PROT|1
   122                              <1> 	protModeFaultTest EX_GP, DPL1_SEG_PROT, mov %1,ax
   123                              <1> 	; #GP(selector) If the SS register is being loaded and the segment pointed to is a non-writable data segment.
   124                              <1> 	mov ax, RO_SEG_PROT
   125                              <1> 	protModeFaultTest EX_GP, RO_SEG_PROT, mov %1,ax
   126                              <1> 	; #SS(selector) If the SS register is being loaded and the segment pointed to is marked not present.
   127                              <1> 	mov ax, NP_SEG_PROT
   128                              <1> 	protModeFaultTest EX_SS, NP_SEG_PROT, mov %1,ax
   129                              <1> 	%endif
   130                              <1> 	%if %1 != cs
   131                              <1> 	; #GP(selector) If segment selector index is outside descriptor table limits.
   132                              <1> 	mov ax, 0xFFF8
   133                              <1> 	protModeFaultTest EX_GP, 0xfff8, mov %1,ax
   134                              <1> 	%if %1 != ss
   135                              <1> 	; #NP(selector) If the DS, ES, FS, or GS register is being loaded and the segment pointed to is marked not present.
   136                              <1> 	mov ax, NP_SEG_PROT
   137                              <1> 	protModeFaultTest EX_NP, NP_SEG_PROT, mov %1,ax
   138                              <1> 	; #GP(selector) If the DS, ES, FS, or GS register is being loaded and the segment pointed to is not a data or readable code segment.
   139                              <1> 	mov ax, SYS_SEG_PROT
   140                              <1> 	protModeFaultTest EX_GP, SYS_SEG_PROT, mov %1,ax
   141                              <1> 	; #GP(selector)
   142                              <1> 	; If the DS, ES, FS, or GS register is being loaded and the segment pointed to is a data or nonconforming code segment, but both the RPL and the CPL are greater than the DPL.
   143                              <1> 	call switchToRing3 ; CPL=3
   144                              <1> 	mov ax, DTEST_SEG_PROT|3 ; RPL=3,DPL=0
   145                              <1> 	protModeFaultTest EX_GP, DTEST_SEG_PROT, mov %1,ax
   146                              <1> 	call switchToRing0
   147                              <1> 	%endif
   148                              <1> 	%endif
   149                              <1> 
   150                              <1> %endmacro
   166                                  ;-------------------------------------------------------------------------------
   167                                  	POST 3
     5 000004BF B003                <1>  mov al, 0x%1
     6 000004C1 BA9909              <1>  mov dx, POST_PORT
     7 000004C4 EE                  <1>  out dx, al
   168                                  ;-------------------------------------------------------------------------------
   169                                  ;
   170                                  ;   Move segment registers in real mode
   171                                  ;
   172                                  	testMovSegR_real ss
     7                              <1>  %if %1 = cs
     8                              <1>  mov dx, C_SEG_REAL
     9                              <1>  %else
    10 000004C5 BA0020              <1>  mov dx, D1_SEG_REAL
    11                              <1>  %endif
    12                              <1> 
    13                              <1> 
    14                              <1>  %if %1 = cs
    15                              <1>  realModeFaultTest EX_UD, mov %1,dx
    16                              <1>  %else
    17 000004C8 8ED2                <1>  mov %1, dx
    18                              <1>  %endif
    19                              <1> 
    20                              <1> 
    21 000004CA 31C0                <1>  xor ax, ax
    22 000004CC 8CD0                <1>  mov ax, %1
    23 000004CE 39D0                <1>  cmp ax, dx
    24 000004D0 0F85F310            <1>  jne error
    25                              <1> 
    26                              <1> 
    27 000004D4 66B8FFFFFFFF        <1>  mov eax, -1
    28 000004DA 668CD0              <1>  mov eax, %1
    29                              <1> 
    30                              <1> 
    31 000004DD 39D0                <1>  cmp ax, dx
    32 000004DF 0F85E410            <1>  jne error
    33                              <1> 
    34                              <1> 
    35 000004E3 C7060000EFBE        <1>  mov [0], word 0xbeef
    36 000004E9 8C160000            <1>  mov [0], %1
    37 000004ED 39160000            <1>  cmp [0], dx
    38 000004F1 0F85D210            <1>  jne error
    39                              <1> 
    40                              <1> 
    41                              <1>  %if %1 = cs
    42                              <1>  realModeFaultTest EX_UD, mov %1,[0]
    43                              <1>  %else
    44 000004F5 8CD9                <1>  mov cx, ds
    45 000004F7 31C0                <1>  xor ax, ax
    46 000004F9 8ED0                <1>  mov %1, ax
    47                              <1>  %if %1 = ds
    48                              <1>  mov es, cx
    49                              <1>  mov %1, [es:0]
    50                              <1>  %else
    51 000004FB 8E160000            <1>  mov %1, [0]
    52                              <1>  %endif
    53 000004FF 8CD0                <1>  mov ax, %1
    54 00000501 39D0                <1>  cmp ax, dx
    55 00000503 0F85C010            <1>  jne error
    56                              <1>  %endif
    57                              <1> 
   173                                  	testMovSegR_real ds
     7                              <1>  %if %1 = cs
     8                              <1>  mov dx, C_SEG_REAL
     9                              <1>  %else
    10 00000507 BA0020              <1>  mov dx, D1_SEG_REAL
    11                              <1>  %endif
    12                              <1> 
    13                              <1> 
    14                              <1>  %if %1 = cs
    15                              <1>  realModeFaultTest EX_UD, mov %1,dx
    16                              <1>  %else
    17 0000050A 8EDA                <1>  mov %1, dx
    18                              <1>  %endif
    19                              <1> 
    20                              <1> 
    21 0000050C 31C0                <1>  xor ax, ax
    22 0000050E 8CD8                <1>  mov ax, %1
    23 00000510 39D0                <1>  cmp ax, dx
    24 00000512 0F85B110            <1>  jne error
    25                              <1> 
    26                              <1> 
    27 00000516 66B8FFFFFFFF        <1>  mov eax, -1
    28 0000051C 668CD8              <1>  mov eax, %1
    29                              <1> 
    30                              <1> 
    31 0000051F 39D0                <1>  cmp ax, dx
    32 00000521 0F85A210            <1>  jne error
    33                              <1> 
    34                              <1> 
    35 00000525 C7060000EFBE        <1>  mov [0], word 0xbeef
    36 0000052B 8C1E0000            <1>  mov [0], %1
    37 0000052F 39160000            <1>  cmp [0], dx
    38 00000533 0F859010            <1>  jne error
    39                              <1> 
    40                              <1> 
    41                              <1>  %if %1 = cs
    42                              <1>  realModeFaultTest EX_UD, mov %1,[0]
    43                              <1>  %else
    44 00000537 8CD9                <1>  mov cx, ds
    45 00000539 31C0                <1>  xor ax, ax
    46 0000053B 8ED8                <1>  mov %1, ax
    47                              <1>  %if %1 = ds
    48 0000053D 8EC1                <1>  mov es, cx
    49 0000053F 268E1E0000          <1>  mov %1, [es:0]
    50                              <1>  %else
    51                              <1>  mov %1, [0]
    52                              <1>  %endif
    53 00000544 8CD8                <1>  mov ax, %1
    54 00000546 39D0                <1>  cmp ax, dx
    55 00000548 0F857B10            <1>  jne error
    56                              <1>  %endif
    57                              <1> 
   174                                  	testMovSegR_real es
     7                              <1>  %if %1 = cs
     8                              <1>  mov dx, C_SEG_REAL
     9                              <1>  %else
    10 0000054C BA0020              <1>  mov dx, D1_SEG_REAL
    11                              <1>  %endif
    12                              <1> 
    13                              <1> 
    14                              <1>  %if %1 = cs
    15                              <1>  realModeFaultTest EX_UD, mov %1,dx
    16                              <1>  %else
    17 0000054F 8EC2                <1>  mov %1, dx
    18                              <1>  %endif
    19                              <1> 
    20                              <1> 
    21 00000551 31C0                <1>  xor ax, ax
    22 00000553 8CC0                <1>  mov ax, %1
    23 00000555 39D0                <1>  cmp ax, dx
    24 00000557 0F856C10            <1>  jne error
    25                              <1> 
    26                              <1> 
    27 0000055B 66B8FFFFFFFF        <1>  mov eax, -1
    28 00000561 668CC0              <1>  mov eax, %1
    29                              <1> 
    30                              <1> 
    31 00000564 39D0                <1>  cmp ax, dx
    32 00000566 0F855D10            <1>  jne error
    33                              <1> 
    34                              <1> 
    35 0000056A C7060000EFBE        <1>  mov [0], word 0xbeef
    36 00000570 8C060000            <1>  mov [0], %1
    37 00000574 39160000            <1>  cmp [0], dx
    38 00000578 0F854B10            <1>  jne error
    39                              <1> 
    40                              <1> 
    41                              <1>  %if %1 = cs
    42                              <1>  realModeFaultTest EX_UD, mov %1,[0]
    43                              <1>  %else
    44 0000057C 8CD9                <1>  mov cx, ds
    45 0000057E 31C0                <1>  xor ax, ax
    46 00000580 8EC0                <1>  mov %1, ax
    47                              <1>  %if %1 = ds
    48                              <1>  mov es, cx
    49                              <1>  mov %1, [es:0]
    50                              <1>  %else
    51 00000582 8E060000            <1>  mov %1, [0]
    52                              <1>  %endif
    53 00000586 8CC0                <1>  mov ax, %1
    54 00000588 39D0                <1>  cmp ax, dx
    55 0000058A 0F853910            <1>  jne error
    56                              <1>  %endif
    57                              <1> 
   175                                  	testMovSegR_real fs
     7                              <1>  %if %1 = cs
     8                              <1>  mov dx, C_SEG_REAL
     9                              <1>  %else
    10 0000058E BA0020              <1>  mov dx, D1_SEG_REAL
    11                              <1>  %endif
    12                              <1> 
    13                              <1> 
    14                              <1>  %if %1 = cs
    15                              <1>  realModeFaultTest EX_UD, mov %1,dx
    16                              <1>  %else
    17 00000591 8EE2                <1>  mov %1, dx
    18                              <1>  %endif
    19                              <1> 
    20                              <1> 
    21 00000593 31C0                <1>  xor ax, ax
    22 00000595 8CE0                <1>  mov ax, %1
    23 00000597 39D0                <1>  cmp ax, dx
    24 00000599 0F852A10            <1>  jne error
    25                              <1> 
    26                              <1> 
    27 0000059D 66B8FFFFFFFF        <1>  mov eax, -1
    28 000005A3 668CE0              <1>  mov eax, %1
    29                              <1> 
    30                              <1> 
    31 000005A6 39D0                <1>  cmp ax, dx
    32 000005A8 0F851B10            <1>  jne error
    33                              <1> 
    34                              <1> 
    35 000005AC C7060000EFBE        <1>  mov [0], word 0xbeef
    36 000005B2 8C260000            <1>  mov [0], %1
    37 000005B6 39160000            <1>  cmp [0], dx
    38 000005BA 0F850910            <1>  jne error
    39                              <1> 
    40                              <1> 
    41                              <1>  %if %1 = cs
    42                              <1>  realModeFaultTest EX_UD, mov %1,[0]
    43                              <1>  %else
    44 000005BE 8CD9                <1>  mov cx, ds
    45 000005C0 31C0                <1>  xor ax, ax
    46 000005C2 8EE0                <1>  mov %1, ax
    47                              <1>  %if %1 = ds
    48                              <1>  mov es, cx
    49                              <1>  mov %1, [es:0]
    50                              <1>  %else
    51 000005C4 8E260000            <1>  mov %1, [0]
    52                              <1>  %endif
    53 000005C8 8CE0                <1>  mov ax, %1
    54 000005CA 39D0                <1>  cmp ax, dx
    55 000005CC 0F85F70F            <1>  jne error
    56                              <1>  %endif
    57                              <1> 
   176                                  	testMovSegR_real gs
     7                              <1>  %if %1 = cs
     8                              <1>  mov dx, C_SEG_REAL
     9                              <1>  %else
    10 000005D0 BA0020              <1>  mov dx, D1_SEG_REAL
    11                              <1>  %endif
    12                              <1> 
    13                              <1> 
    14                              <1>  %if %1 = cs
    15                              <1>  realModeFaultTest EX_UD, mov %1,dx
    16                              <1>  %else
    17 000005D3 8EEA                <1>  mov %1, dx
    18                              <1>  %endif
    19                              <1> 
    20                              <1> 
    21 000005D5 31C0                <1>  xor ax, ax
    22 000005D7 8CE8                <1>  mov ax, %1
    23 000005D9 39D0                <1>  cmp ax, dx
    24 000005DB 0F85E80F            <1>  jne error
    25                              <1> 
    26                              <1> 
    27 000005DF 66B8FFFFFFFF        <1>  mov eax, -1
    28 000005E5 668CE8              <1>  mov eax, %1
    29                              <1> 
    30                              <1> 
    31 000005E8 39D0                <1>  cmp ax, dx
    32 000005EA 0F85D90F            <1>  jne error
    33                              <1> 
    34                              <1> 
    35 000005EE C7060000EFBE        <1>  mov [0], word 0xbeef
    36 000005F4 8C2E0000            <1>  mov [0], %1
    37 000005F8 39160000            <1>  cmp [0], dx
    38 000005FC 0F85C70F            <1>  jne error
    39                              <1> 
    40                              <1> 
    41                              <1>  %if %1 = cs
    42                              <1>  realModeFaultTest EX_UD, mov %1,[0]
    43                              <1>  %else
    44 00000600 8CD9                <1>  mov cx, ds
    45 00000602 31C0                <1>  xor ax, ax
    46 00000604 8EE8                <1>  mov %1, ax
    47                              <1>  %if %1 = ds
    48                              <1>  mov es, cx
    49                              <1>  mov %1, [es:0]
    50                              <1>  %else
    51 00000606 8E2E0000            <1>  mov %1, [0]
    52                              <1>  %endif
    53 0000060A 8CE8                <1>  mov ax, %1
    54 0000060C 39D0                <1>  cmp ax, dx
    55 0000060E 0F85B50F            <1>  jne error
    56                              <1>  %endif
    57                              <1> 
   177                                  	testMovSegR_real cs
     7                              <1>  %if %1 = cs
     8 00000612 BA00F0              <1>  mov dx, C_SEG_REAL
     9                              <1>  %else
    10                              <1>  mov dx, D1_SEG_REAL
    11                              <1>  %endif
    12                              <1> 
    13                              <1> 
    14                              <1>  %if %1 = cs
    15                              <1>  realModeFaultTest EX_UD, mov %1,dx
    69                              <2>  realModeExcInit %1, %%continue
    42 00000615 B80000              <3>  mov ax, 0
    43 00000618 8ED8                <3>  mov ds, ax
    44 0000061A C7061800[3306]      <3>  mov [%1*4], word %2
    45 00000620 C7061A0000F0        <3>  mov [%1*4+2], word C_SEG_REAL
    70 00000626 B80010              <2>  mov ax, S_SEG_REAL
    71 00000629 8ED0                <2>  mov ss, ax
    72 0000062B BCFFFF              <2>  mov sp, ESP_REAL
    73                              <2> %%test:
    74 0000062E 8ECA                <2>  %2
    75 00000630 E9940F              <2>  jmp error
    76                              <2> %%continue:
    77                              <2>  realModeExcCheck %1, %%test
    53 00000633 83FCF9              <3>  cmp sp, ESP_REAL-6
    54 00000636 0F858D0F            <3>  jne error
    55 0000063A 36813EFBFF00F0      <3>  cmp [ss:ESP_REAL-4], word C_SEG_REAL
    56 00000641 36813EF9FF[2E06]    <3>  cmp [ss:ESP_REAL-6], word %2
    57 00000648 0F857B0F            <3>  jne error
    58 0000064C B80000              <3>  mov ax, 0
    59 0000064F 8ED8                <3>  mov ds, ax
    60 00000651 C7061800[C715]      <3>  mov [%1*4], word error
    61 00000657 C7061A0000F0        <3>  mov [%1*4+2], word C_SEG_REAL
    16                              <1>  %else
    17                              <1>  mov %1, dx
    18                              <1>  %endif
    19                              <1> 
    20                              <1> 
    21 0000065D 31C0                <1>  xor ax, ax
    22 0000065F 8CC8                <1>  mov ax, %1
    23 00000661 39D0                <1>  cmp ax, dx
    24 00000663 0F85600F            <1>  jne error
    25                              <1> 
    26                              <1> 
    27 00000667 66B8FFFFFFFF        <1>  mov eax, -1
    28 0000066D 668CC8              <1>  mov eax, %1
    29                              <1> 
    30                              <1> 
    31 00000670 39D0                <1>  cmp ax, dx
    32 00000672 0F85510F            <1>  jne error
    33                              <1> 
    34                              <1> 
    35 00000676 C7060000EFBE        <1>  mov [0], word 0xbeef
    36 0000067C 8C0E0000            <1>  mov [0], %1
    37 00000680 39160000            <1>  cmp [0], dx
    38 00000684 0F853F0F            <1>  jne error
    39                              <1> 
    40                              <1> 
    41                              <1>  %if %1 = cs
    42                              <1>  realModeFaultTest EX_UD, mov %1,[0]
    69                              <2>  realModeExcInit %1, %%continue
    42 00000688 B80000              <3>  mov ax, 0
    43 0000068B 8ED8                <3>  mov ds, ax
    44 0000068D C7061800[A806]      <3>  mov [%1*4], word %2
    45 00000693 C7061A0000F0        <3>  mov [%1*4+2], word C_SEG_REAL
    70 00000699 B80010              <2>  mov ax, S_SEG_REAL
    71 0000069C 8ED0                <2>  mov ss, ax
    72 0000069E BCFFFF              <2>  mov sp, ESP_REAL
    73                              <2> %%test:
    74 000006A1 8E0E0000            <2>  %2
    75 000006A5 E91F0F              <2>  jmp error
    76                              <2> %%continue:
    77                              <2>  realModeExcCheck %1, %%test
    53 000006A8 83FCF9              <3>  cmp sp, ESP_REAL-6
    54 000006AB 0F85180F            <3>  jne error
    55 000006AF 36813EFBFF00F0      <3>  cmp [ss:ESP_REAL-4], word C_SEG_REAL
    56 000006B6 36813EF9FF[A106]    <3>  cmp [ss:ESP_REAL-6], word %2
    57 000006BD 0F85060F            <3>  jne error
    58 000006C1 B80000              <3>  mov ax, 0
    59 000006C4 8ED8                <3>  mov ds, ax
    60 000006C6 C7061800[C715]      <3>  mov [%1*4], word error
    61 000006CC C7061A0000F0        <3>  mov [%1*4+2], word C_SEG_REAL
    43                              <1>  %else
    44                              <1>  mov cx, ds
    45                              <1>  xor ax, ax
    46                              <1>  mov %1, ax
    47                              <1>  %if %1 = ds
    48                              <1>  mov es, cx
    49                              <1>  mov %1, [es:0]
    50                              <1>  %else
    51                              <1>  mov %1, [0]
    52                              <1>  %endif
    53                              <1>  mov ax, %1
    54                              <1>  cmp ax, dx
    55                              <1>  jne error
    56                              <1>  %endif
    57                              <1> 
   178                                  
   179                                  	advTestSegReal
     8                              <1>  advTestBase
    86                              <2>  %assign TEST_BASE1 TEST_BASE1+0x1000
    87                              <2>  %assign TEST_BASE2 TEST_BASE2+0x1000
     9                              <1>  %assign D1_SEG_REAL TEST_BASE1 >> 4
    10                              <1>  %assign D2_SEG_REAL TEST_BASE2 >> 4
    11 000006D2 BA0021              <1>  mov dx, D1_SEG_REAL
    12 000006D5 8EDA                <1>  mov ds, dx
    13 000006D7 BA0061              <1>  mov dx, D2_SEG_REAL
    14 000006DA 8EC2                <1>  mov es, dx
   180                                  
   181                                  
   182                                  %include "tests/string_m.asm"
     1                              <1> ;
     2                              <1> ;   Tests store, compare, scan, and move string operands
     3                              <1> ;   %1 data size b=byte, w=word, d=dword
     4                              <1> ;   %2 direction 0=increment, 1=decrement
     5                              <1> ;   %3 addressing a16=16-bit, a32=32-bit
     6                              <1> ;   DS test segment 1
     7                              <1> ;   ES test segment 2
     8                              <1> ;
     9                              <1> %macro testStringOps 3
    10                              <1> 
    11                              <1> 	%assign value 0x12345678
    12                              <1> 	%ifidni %1,b
    13                              <1> 		%assign val_size 1
    14                              <1> 		%define val_mask 0x000000ff
    15                              <1> 		%define sized_eax al
    16                              <1> 	%endif
    17                              <1> 	%ifidni %1,w
    18                              <1> 		%assign val_size 2
    19                              <1> 		%define val_mask 0x0000ffff
    20                              <1> 		%define sized_eax ax
    21                              <1> 	%endif
    22                              <1> 	%ifidni %1,d
    23                              <1> 		%assign val_size 4
    24                              <1> 		%define val_mask 0xffffffff
    25                              <1> 		%define sized_eax eax
    26                              <1> 	%endif
    27                              <1> 
    28                              <1> 	%if %2 == 0
    29                              <1> 		cld
    30                              <1> 		%assign off_value 0x0001ffff-(val_size-1)
    31                              <1> 		%ifidni %3,a16
    32                              <1> 			; 16-bit addressing
    33                              <1> 			%assign off_cmp 0x00010000
    34                              <1> 		%else
    35                              <1> 			; 32-bit addressing
    36                              <1> 			%assign off_cmp 0x00020000
    37                              <1> 		%endif
    38                              <1> 	%else
    39                              <1> 		std
    40                              <1> 		%assign off_value 0x00010000
    41                              <1> 		%ifidni %3,a16
    42                              <1> 			; 16-bit addressing
    43                              <1> 			%assign off_cmp 0x0001ffff-(val_size-1)
    44                              <1> 		%else
    45                              <1> 			; 32-bit addressing
    46                              <1> 			%assign off_cmp 0x0000ffff-(val_size-1)
    47                              <1> 		%endif
    48                              <1> 	%endif
    49                              <1> 
    50                              <1> 	%ifidni %3,a16
    51                              <1> 		%assign off_mask 0x0000ffff
    52                              <1> 	%else
    53                              <1> 		%assign off_mask 0xffffffff
    54                              <1> 	%endif
    55                              <1> 
    56                              <1> 	; VERIFY string operands
    57                              <1> 
    58                              <1> 	mov    edi, off_value
    59                              <1> 	mov    ebx, off_value & off_mask
    60                              <1> 	mov    sized_eax, 0
    61                              <1> 	mov    [es:ebx], sized_eax
    62                              <1> 	mov    sized_eax, value
    63                              <1> 	%3 stos%1         ; STORE EAX in ES:EDI
    64                              <1> 	cmp    [es:ebx], sized_eax
    65                              <1> 	jne    error
    66                              <1> 	cmp    edi, off_cmp
    67                              <1> 	jne    error
    68                              <1> 
    69                              <1> 	mov    esi, off_value
    70                              <1> 	mov    edi, off_value
    71                              <1> 	mov    ebx, off_value & off_mask
    72                              <1> 	mov    [ds:ebx], sized_eax
    73                              <1> 	mov    [es:ebx], sized_eax
    74                              <1> 	cmp    sized_eax, 0
    75                              <1> 	je     error
    76                              <1> 	%3 cmps%1         ; COMPARE ES:EDI with DS:ESI
    77                              <1> 	jne    error
    78                              <1> 	cmp    edi, off_cmp
    79                              <1> 	jne    error
    80                              <1> 	cmp    esi, off_cmp
    81                              <1> 	jne    error
    82                              <1> 
    83                              <1> 	mov    edi, off_value
    84                              <1> 	mov    sized_eax, value
    85                              <1> 	mov    [es:ebx], sized_eax
    86                              <1> 	cmp    sized_eax, 0
    87                              <1> 	%3 scas%1         ; SCAN/COMPARE ES:EDI with EAX
    88                              <1> 	jne    error
    89                              <1> 	cmp    edi, off_cmp
    90                              <1> 	jne    error
    91                              <1> 
    92                              <1> 	mov    esi, off_value
    93                              <1> 	mov    edi, off_value
    94                              <1> 	mov    sized_eax, value
    95                              <1> 	mov    [ds:ebx], sized_eax
    96                              <1> 	mov    sized_eax, 0
    97                              <1> 	mov    [es:ebx], sized_eax
    98                              <1> 	%3 movs%1         ; MOVE data from DS:ESI to ES:EDI
    99                              <1> 	mov    sized_eax, value
   100                              <1> 	cmp    [es:ebx], sized_eax
   101                              <1> 	jne    error
   102                              <1> 	cmp    edi, off_cmp
   103                              <1> 	jne    error
   104                              <1> 	cmp    esi, off_cmp
   105                              <1> 	jne    error
   106                              <1> 
   107                              <1> 	mov    esi, off_value
   108                              <1> 	mov    sized_eax, value
   109                              <1> 	mov    [es:ebx], sized_eax
   110                              <1> 	xor    eax, eax
   111                              <1> 	%3 lods%1         ; LOAD data from DS:ESI into EAX
   112                              <1> 	cmp    sized_eax, value & val_mask
   113                              <1> 	jne    error
   114                              <1> 	cmp    esi, off_cmp
   115                              <1> 	jne    error
   116                              <1> 
   117                              <1> %endmacro
   118                              <1> 
   119                              <1> ;
   120                              <1> ;   Tests store, compare, scan, and move string operands with repetitions
   121                              <1> ;   %1 element size b=byte, w=word, d=dword
   122                              <1> ;   %2 direction 0=increment, 1=decrement
   123                              <1> ;   %3 addressing a16=16-bit, a32=32-bit
   124                              <1> ;   DS test segment 1
   125                              <1> ;   ES test segment 2
   126                              <1> ;
   127                              <1> %macro testStringReps 3
   128                              <1> 
   129                              <1> 	%assign bytes 0x100
   130                              <1> 
   131                              <1> 	%ifidni %1,b
   132                              <1> 		%assign items bytes
   133                              <1> 	%endif
   134                              <1> 	%ifidni %1,w
   135                              <1> 		%assign items bytes/2
   136                              <1> 	%endif
   137                              <1> 	%ifidni %1,d
   138                              <1> 		%assign items bytes/4
   139                              <1> 	%endif
   140                              <1> 
   141                              <1> 	%if %2 == 0
   142                              <1> 		cld
   143                              <1> 		%assign off_value 0x0001ff00
   144                              <1> 		%ifidni %3,a16
   145                              <1> 			; 16-bit addressing
   146                              <1> 			%assign off_cmp 0x00010000
   147                              <1> 		%else
   148                              <1> 			; 32-bit addressing
   149                              <1> 			%assign off_cmp 0x00020000
   150                              <1> 		%endif
   151                              <1> 	%else
   152                              <1> 		std
   153                              <1> 		%assign off_value 0x000100ff
   154                              <1> 		%ifidni %3,a16
   155                              <1> 			; 16-bit addressing
   156                              <1> 			%assign off_cmp 0x0001ffff
   157                              <1> 		%else
   158                              <1> 			; 32-bit addressing
   159                              <1> 			%assign off_cmp 0x0000ffff
   160                              <1> 		%endif
   161                              <1> 	%endif
   162                              <1> 
   163                              <1> 	mov    eax, 0x12345678
   164                              <1> 	mov    esi, off_value
   165                              <1> 	mov    edi, off_value
   166                              <1> 
   167                              <1> 	; VERIFY REPs on memory buffers
   168                              <1> 
   169                              <1> 	; STORE buffers with pattern in EAX
   170                              <1> 	mov    eax, 0x12345678
   171                              <1> 	mov    esi, off_value
   172                              <1> 	mov    edi, off_value
   173                              <1> 	mov    ecx, items
   174                              <1> 	%3 rep stos%1          ; store ECX items at ES:EDI with the value in EAX
   175                              <1> 	cmp    ecx, 0
   176                              <1> 	jnz    error           ; ECX must be 0
   177                              <1> 	cmp    edi, off_cmp
   178                              <1> 	jnz    error
   179                              <1> 	mov    edi, off_value  ; reset EDI
   180                              <1> 	; now switch ES:EDI with DS:ESI
   181                              <1> 	mov    dx, es
   182                              <1> 	mov    cx, ds
   183                              <1> 	xchg   dx, cx
   184                              <1> 	mov    es, dx
   185                              <1> 	mov    ds, cx
   186                              <1> 	xchg   edi, esi
   187                              <1> 	; store again ES:EDI with pattern in EAX
   188                              <1> 	mov    ecx, items      ; reset ECX
   189                              <1> 	%3 rep stos%1
   190                              <1> 	mov    edi, off_value  ; reset EDI
   191                              <1> 
   192                              <1> 	; COMPARE two buffers
   193                              <1> 	mov    ecx, items      ; reset ECX
   194                              <1> 	%3 repe cmps%1         ; find nonmatching items in ES:EDI and DS:ESI
   195                              <1> 	cmp    ecx, 0
   196                              <1> 	jnz    error           ; ECX must be 0
   197                              <1> 	cmp    esi, off_cmp
   198                              <1> 	jne    error
   199                              <1> 	cmp    edi, off_cmp
   200                              <1> 	jne    error
   201                              <1> 	mov    edi, off_value  ; reset EDI
   202                              <1> 	mov    esi, off_value  ; reset ESI
   203                              <1> 
   204                              <1> 	; SCAN buffer for pattern
   205                              <1> 	mov    ecx, items      ; reset ECX
   206                              <1> 	%3 repe scas%1         ; SCAN first dword not equal to EAX
   207                              <1> 	cmp    ecx, 0
   208                              <1> 	jne    error           ; ECX must be 0
   209                              <1> 	cmp    edi, off_cmp
   210                              <1> 	jne    error
   211                              <1> 	mov    edi, off_value  ; rewind EDI
   212                              <1> 
   213                              <1> 	; MOVE and COMPARE data between buffers
   214                              <1> 	; first zero-fill ES:EDI so that we can compare the moved data later
   215                              <1> 	mov    eax, 0
   216                              <1> 	mov    ecx, items      ; reset ECX
   217                              <1> 	%3 rep stos%1          ; zero fill ES:EDI
   218                              <1> 	mov    edi, off_value  ; reset EDI
   219                              <1> 	mov    ecx, items      ; reset ECX
   220                              <1> 	%3 rep movs%1          ; MOVE data from DS:ESI to ES:EDI
   221                              <1> 	cmp    ecx, 0
   222                              <1> 	jne    error           ; ECX must be 0
   223                              <1> 	cmp    esi, off_cmp
   224                              <1> 	jne    error
   225                              <1> 	cmp    edi, off_cmp
   226                              <1> 	jne    error
   227                              <1> 	mov    ecx, items      ; reset ECX
   228                              <1> 	mov    edi, off_value  ; reset EDI
   229                              <1> 	mov    esi, off_value  ; reset ESI
   230                              <1> 	%3 repe cmps%1         ; COMPARE moved data in ES:EDI with DS:ESI
   231                              <1> 	cmp    ecx, 0
   232                              <1> 	jne    error           ; ECX must be 0
   233                              <1> 	cmp    esi, off_cmp
   234                              <1> 	jne    error
   235                              <1> 	cmp    edi, off_cmp
   236                              <1> 	jne    error
   237                              <1> %endmacro
   183                                  ;-------------------------------------------------------------------------------
   184                                  	POST 4
     5 000006DC B004                <1>  mov al, 0x%1
     6 000006DE BA9909              <1>  mov dx, POST_PORT
     7 000006E1 EE                  <1>  out dx, al
   185                                  ;-------------------------------------------------------------------------------
   186                                  ;
   187                                  ;   Test store, move, scan, and compare string data
   188                                  ;
   189                                  	testStringOps b,0,a16
    10                              <1> 
    11                              <1>  %assign value 0x12345678
    12                              <1>  %ifidni %1,b
    13                              <1>  %assign val_size 1
    14                              <1>  %define val_mask 0x000000ff
    15                              <1>  %define sized_eax al
    16                              <1>  %endif
    17                              <1>  %ifidni %1,w
    18                              <1>  %assign val_size 2
    19                              <1>  %define val_mask 0x0000ffff
    20                              <1>  %define sized_eax ax
    21                              <1>  %endif
    22                              <1>  %ifidni %1,d
    23                              <1>  %assign val_size 4
    24                              <1>  %define val_mask 0xffffffff
    25                              <1>  %define sized_eax eax
    26                              <1>  %endif
    27                              <1> 
    28                              <1>  %if %2 == 0
    29 000006E2 FC                  <1>  cld
    30                              <1>  %assign off_value 0x0001ffff-(val_size-1)
    31                              <1>  %ifidni %3,a16
    32                              <1> 
    33                              <1>  %assign off_cmp 0x00010000
    34                              <1>  %else
    35                              <1> 
    36                              <1>  %assign off_cmp 0x00020000
    37                              <1>  %endif
    38                              <1>  %else
    39                              <1>  std
    40                              <1>  %assign off_value 0x00010000
    41                              <1>  %ifidni %3,a16
    42                              <1> 
    43                              <1>  %assign off_cmp 0x0001ffff-(val_size-1)
    44                              <1>  %else
    45                              <1> 
    46                              <1>  %assign off_cmp 0x0000ffff-(val_size-1)
    47                              <1>  %endif
    48                              <1>  %endif
    49                              <1> 
    50                              <1>  %ifidni %3,a16
    51                              <1>  %assign off_mask 0x0000ffff
    52                              <1>  %else
    53                              <1>  %assign off_mask 0xffffffff
    54                              <1>  %endif
    55                              <1> 
    56                              <1> 
    57                              <1> 
    58 000006E3 66BFFFFF0100        <1>  mov edi, off_value
    59 000006E9 66BBFFFF0000        <1>  mov ebx, off_value & off_mask
    60 000006EF B000                <1>  mov sized_eax, 0
    61 000006F1 26678803            <1>  mov [es:ebx], sized_eax
    62 000006F5 B078                <1>  mov sized_eax, value
    63 000006F7 AA                  <1>  %3 stos%1
    64 000006F8 26673803            <1>  cmp [es:ebx], sized_eax
    65 000006FC 0F85C70E            <1>  jne error
    66 00000700 6681FF00000100      <1>  cmp edi, off_cmp
    67 00000707 0F85BC0E            <1>  jne error
    68                              <1> 
    69 0000070B 66BEFFFF0100        <1>  mov esi, off_value
    70 00000711 66BFFFFF0100        <1>  mov edi, off_value
    71 00000717 66BBFFFF0000        <1>  mov ebx, off_value & off_mask
    72 0000071D 3E678803            <1>  mov [ds:ebx], sized_eax
    73 00000721 26678803            <1>  mov [es:ebx], sized_eax
    74 00000725 3C00                <1>  cmp sized_eax, 0
    75 00000727 0F849C0E            <1>  je error
    76 0000072B A6                  <1>  %3 cmps%1
    77 0000072C 0F85970E            <1>  jne error
    78 00000730 6681FF00000100      <1>  cmp edi, off_cmp
    79 00000737 0F858C0E            <1>  jne error
    80 0000073B 6681FE00000100      <1>  cmp esi, off_cmp
    81 00000742 0F85810E            <1>  jne error
    82                              <1> 
    83 00000746 66BFFFFF0100        <1>  mov edi, off_value
    84 0000074C B078                <1>  mov sized_eax, value
    85 0000074E 26678803            <1>  mov [es:ebx], sized_eax
    86 00000752 3C00                <1>  cmp sized_eax, 0
    87 00000754 AE                  <1>  %3 scas%1
    88 00000755 0F856E0E            <1>  jne error
    89 00000759 6681FF00000100      <1>  cmp edi, off_cmp
    90 00000760 0F85630E            <1>  jne error
    91                              <1> 
    92 00000764 66BEFFFF0100        <1>  mov esi, off_value
    93 0000076A 66BFFFFF0100        <1>  mov edi, off_value
    94 00000770 B078                <1>  mov sized_eax, value
    95 00000772 3E678803            <1>  mov [ds:ebx], sized_eax
    96 00000776 B000                <1>  mov sized_eax, 0
    97 00000778 26678803            <1>  mov [es:ebx], sized_eax
    98 0000077C A4                  <1>  %3 movs%1
    99 0000077D B078                <1>  mov sized_eax, value
   100 0000077F 26673803            <1>  cmp [es:ebx], sized_eax
   101 00000783 0F85400E            <1>  jne error
   102 00000787 6681FF00000100      <1>  cmp edi, off_cmp
   103 0000078E 0F85350E            <1>  jne error
   104 00000792 6681FE00000100      <1>  cmp esi, off_cmp
   105 00000799 0F852A0E            <1>  jne error
   106                              <1> 
   107 0000079D 66BEFFFF0100        <1>  mov esi, off_value
   108 000007A3 B078                <1>  mov sized_eax, value
   109 000007A5 26678803            <1>  mov [es:ebx], sized_eax
   110 000007A9 6631C0              <1>  xor eax, eax
   111 000007AC AC                  <1>  %3 lods%1
   112 000007AD 3C78                <1>  cmp sized_eax, value & val_mask
   113 000007AF 0F85140E            <1>  jne error
   114 000007B3 6681FE00000100      <1>  cmp esi, off_cmp
   115 000007BA 0F85090E            <1>  jne error
   116                              <1> 
   190                                  	testStringOps w,0,a16
    10                              <1> 
    11                              <1>  %assign value 0x12345678
    12                              <1>  %ifidni %1,b
    13                              <1>  %assign val_size 1
    14                              <1>  %define val_mask 0x000000ff
    15                              <1>  %define sized_eax al
    16                              <1>  %endif
    17                              <1>  %ifidni %1,w
    18                              <1>  %assign val_size 2
    19                              <1>  %define val_mask 0x0000ffff
    20                              <1>  %define sized_eax ax
    21                              <1>  %endif
    22                              <1>  %ifidni %1,d
    23                              <1>  %assign val_size 4
    24                              <1>  %define val_mask 0xffffffff
    25                              <1>  %define sized_eax eax
    26                              <1>  %endif
    27                              <1> 
    28                              <1>  %if %2 == 0
    29 000007BE FC                  <1>  cld
    30                              <1>  %assign off_value 0x0001ffff-(val_size-1)
    31                              <1>  %ifidni %3,a16
    32                              <1> 
    33                              <1>  %assign off_cmp 0x00010000
    34                              <1>  %else
    35                              <1> 
    36                              <1>  %assign off_cmp 0x00020000
    37                              <1>  %endif
    38                              <1>  %else
    39                              <1>  std
    40                              <1>  %assign off_value 0x00010000
    41                              <1>  %ifidni %3,a16
    42                              <1> 
    43                              <1>  %assign off_cmp 0x0001ffff-(val_size-1)
    44                              <1>  %else
    45                              <1> 
    46                              <1>  %assign off_cmp 0x0000ffff-(val_size-1)
    47                              <1>  %endif
    48                              <1>  %endif
    49                              <1> 
    50                              <1>  %ifidni %3,a16
    51                              <1>  %assign off_mask 0x0000ffff
    52                              <1>  %else
    53                              <1>  %assign off_mask 0xffffffff
    54                              <1>  %endif
    55                              <1> 
    56                              <1> 
    57                              <1> 
    58 000007BF 66BFFEFF0100        <1>  mov edi, off_value
    59 000007C5 66BBFEFF0000        <1>  mov ebx, off_value & off_mask
    60 000007CB B80000              <1>  mov sized_eax, 0
    61 000007CE 26678903            <1>  mov [es:ebx], sized_eax
    62 000007D2 B87856              <1>  mov sized_eax, value
    63 000007D5 AB                  <1>  %3 stos%1
    64 000007D6 26673903            <1>  cmp [es:ebx], sized_eax
    65 000007DA 0F85E90D            <1>  jne error
    66 000007DE 6681FF00000100      <1>  cmp edi, off_cmp
    67 000007E5 0F85DE0D            <1>  jne error
    68                              <1> 
    69 000007E9 66BEFEFF0100        <1>  mov esi, off_value
    70 000007EF 66BFFEFF0100        <1>  mov edi, off_value
    71 000007F5 66BBFEFF0000        <1>  mov ebx, off_value & off_mask
    72 000007FB 3E678903            <1>  mov [ds:ebx], sized_eax
    73 000007FF 26678903            <1>  mov [es:ebx], sized_eax
    74 00000803 83F800              <1>  cmp sized_eax, 0
    75 00000806 0F84BD0D            <1>  je error
    76 0000080A A7                  <1>  %3 cmps%1
    77 0000080B 0F85B80D            <1>  jne error
    78 0000080F 6681FF00000100      <1>  cmp edi, off_cmp
    79 00000816 0F85AD0D            <1>  jne error
    80 0000081A 6681FE00000100      <1>  cmp esi, off_cmp
    81 00000821 0F85A20D            <1>  jne error
    82                              <1> 
    83 00000825 66BFFEFF0100        <1>  mov edi, off_value
    84 0000082B B87856              <1>  mov sized_eax, value
    85 0000082E 26678903            <1>  mov [es:ebx], sized_eax
    86 00000832 83F800              <1>  cmp sized_eax, 0
    87 00000835 AF                  <1>  %3 scas%1
    88 00000836 0F858D0D            <1>  jne error
    89 0000083A 6681FF00000100      <1>  cmp edi, off_cmp
    90 00000841 0F85820D            <1>  jne error
    91                              <1> 
    92 00000845 66BEFEFF0100        <1>  mov esi, off_value
    93 0000084B 66BFFEFF0100        <1>  mov edi, off_value
    94 00000851 B87856              <1>  mov sized_eax, value
    95 00000854 3E678903            <1>  mov [ds:ebx], sized_eax
    96 00000858 B80000              <1>  mov sized_eax, 0
    97 0000085B 26678903            <1>  mov [es:ebx], sized_eax
    98 0000085F A5                  <1>  %3 movs%1
    99 00000860 B87856              <1>  mov sized_eax, value
   100 00000863 26673903            <1>  cmp [es:ebx], sized_eax
   101 00000867 0F855C0D            <1>  jne error
   102 0000086B 6681FF00000100      <1>  cmp edi, off_cmp
   103 00000872 0F85510D            <1>  jne error
   104 00000876 6681FE00000100      <1>  cmp esi, off_cmp
   105 0000087D 0F85460D            <1>  jne error
   106                              <1> 
   107 00000881 66BEFEFF0100        <1>  mov esi, off_value
   108 00000887 B87856              <1>  mov sized_eax, value
   109 0000088A 26678903            <1>  mov [es:ebx], sized_eax
   110 0000088E 6631C0              <1>  xor eax, eax
   111 00000891 AD                  <1>  %3 lods%1
   112 00000892 3D7856              <1>  cmp sized_eax, value & val_mask
   113 00000895 0F852E0D            <1>  jne error
   114 00000899 6681FE00000100      <1>  cmp esi, off_cmp
   115 000008A0 0F85230D            <1>  jne error
   116                              <1> 
   191                                  	testStringOps d,0,a16
    10                              <1> 
    11                              <1>  %assign value 0x12345678
    12                              <1>  %ifidni %1,b
    13                              <1>  %assign val_size 1
    14                              <1>  %define val_mask 0x000000ff
    15                              <1>  %define sized_eax al
    16                              <1>  %endif
    17                              <1>  %ifidni %1,w
    18                              <1>  %assign val_size 2
    19                              <1>  %define val_mask 0x0000ffff
    20                              <1>  %define sized_eax ax
    21                              <1>  %endif
    22                              <1>  %ifidni %1,d
    23                              <1>  %assign val_size 4
    24                              <1>  %define val_mask 0xffffffff
    25                              <1>  %define sized_eax eax
    26                              <1>  %endif
    27                              <1> 
    28                              <1>  %if %2 == 0
    29 000008A4 FC                  <1>  cld
    30                              <1>  %assign off_value 0x0001ffff-(val_size-1)
    31                              <1>  %ifidni %3,a16
    32                              <1> 
    33                              <1>  %assign off_cmp 0x00010000
    34                              <1>  %else
    35                              <1> 
    36                              <1>  %assign off_cmp 0x00020000
    37                              <1>  %endif
    38                              <1>  %else
    39                              <1>  std
    40                              <1>  %assign off_value 0x00010000
    41                              <1>  %ifidni %3,a16
    42                              <1> 
    43                              <1>  %assign off_cmp 0x0001ffff-(val_size-1)
    44                              <1>  %else
    45                              <1> 
    46                              <1>  %assign off_cmp 0x0000ffff-(val_size-1)
    47                              <1>  %endif
    48                              <1>  %endif
    49                              <1> 
    50                              <1>  %ifidni %3,a16
    51                              <1>  %assign off_mask 0x0000ffff
    52                              <1>  %else
    53                              <1>  %assign off_mask 0xffffffff
    54                              <1>  %endif
    55                              <1> 
    56                              <1> 
    57                              <1> 
    58 000008A5 66BFFCFF0100        <1>  mov edi, off_value
    59 000008AB 66BBFCFF0000        <1>  mov ebx, off_value & off_mask
    60 000008B1 66B800000000        <1>  mov sized_eax, 0
    61 000008B7 2666678903          <1>  mov [es:ebx], sized_eax
    62 000008BC 66B878563412        <1>  mov sized_eax, value
    63 000008C2 66AB                <1>  %3 stos%1
    64 000008C4 2666673903          <1>  cmp [es:ebx], sized_eax
    65 000008C9 0F85FA0C            <1>  jne error
    66 000008CD 6681FF00000100      <1>  cmp edi, off_cmp
    67 000008D4 0F85EF0C            <1>  jne error
    68                              <1> 
    69 000008D8 66BEFCFF0100        <1>  mov esi, off_value
    70 000008DE 66BFFCFF0100        <1>  mov edi, off_value
    71 000008E4 66BBFCFF0000        <1>  mov ebx, off_value & off_mask
    72 000008EA 3E66678903          <1>  mov [ds:ebx], sized_eax
    73 000008EF 2666678903          <1>  mov [es:ebx], sized_eax
    74 000008F4 6683F800            <1>  cmp sized_eax, 0
    75 000008F8 0F84CB0C            <1>  je error
    76 000008FC 66A7                <1>  %3 cmps%1
    77 000008FE 0F85C50C            <1>  jne error
    78 00000902 6681FF00000100      <1>  cmp edi, off_cmp
    79 00000909 0F85BA0C            <1>  jne error
    80 0000090D 6681FE00000100      <1>  cmp esi, off_cmp
    81 00000914 0F85AF0C            <1>  jne error
    82                              <1> 
    83 00000918 66BFFCFF0100        <1>  mov edi, off_value
    84 0000091E 66B878563412        <1>  mov sized_eax, value
    85 00000924 2666678903          <1>  mov [es:ebx], sized_eax
    86 00000929 6683F800            <1>  cmp sized_eax, 0
    87 0000092D 66AF                <1>  %3 scas%1
    88 0000092F 0F85940C            <1>  jne error
    89 00000933 6681FF00000100      <1>  cmp edi, off_cmp
    90 0000093A 0F85890C            <1>  jne error
    91                              <1> 
    92 0000093E 66BEFCFF0100        <1>  mov esi, off_value
    93 00000944 66BFFCFF0100        <1>  mov edi, off_value
    94 0000094A 66B878563412        <1>  mov sized_eax, value
    95 00000950 3E66678903          <1>  mov [ds:ebx], sized_eax
    96 00000955 66B800000000        <1>  mov sized_eax, 0
    97 0000095B 2666678903          <1>  mov [es:ebx], sized_eax
    98 00000960 66A5                <1>  %3 movs%1
    99 00000962 66B878563412        <1>  mov sized_eax, value
   100 00000968 2666673903          <1>  cmp [es:ebx], sized_eax
   101 0000096D 0F85560C            <1>  jne error
   102 00000971 6681FF00000100      <1>  cmp edi, off_cmp
   103 00000978 0F854B0C            <1>  jne error
   104 0000097C 6681FE00000100      <1>  cmp esi, off_cmp
   105 00000983 0F85400C            <1>  jne error
   106                              <1> 
   107 00000987 66BEFCFF0100        <1>  mov esi, off_value
   108 0000098D 66B878563412        <1>  mov sized_eax, value
   109 00000993 2666678903          <1>  mov [es:ebx], sized_eax
   110 00000998 6631C0              <1>  xor eax, eax
   111 0000099B 66AD                <1>  %3 lods%1
   112 0000099D 663D78563412        <1>  cmp sized_eax, value & val_mask
   113 000009A3 0F85200C            <1>  jne error
   114 000009A7 6681FE00000100      <1>  cmp esi, off_cmp
   115 000009AE 0F85150C            <1>  jne error
   116                              <1> 
   192                                  	testStringOps b,1,a16
    10                              <1> 
    11                              <1>  %assign value 0x12345678
    12                              <1>  %ifidni %1,b
    13                              <1>  %assign val_size 1
    14                              <1>  %define val_mask 0x000000ff
    15                              <1>  %define sized_eax al
    16                              <1>  %endif
    17                              <1>  %ifidni %1,w
    18                              <1>  %assign val_size 2
    19                              <1>  %define val_mask 0x0000ffff
    20                              <1>  %define sized_eax ax
    21                              <1>  %endif
    22                              <1>  %ifidni %1,d
    23                              <1>  %assign val_size 4
    24                              <1>  %define val_mask 0xffffffff
    25                              <1>  %define sized_eax eax
    26                              <1>  %endif
    27                              <1> 
    28                              <1>  %if %2 == 0
    29                              <1>  cld
    30                              <1>  %assign off_value 0x0001ffff-(val_size-1)
    31                              <1>  %ifidni %3,a16
    32                              <1> 
    33                              <1>  %assign off_cmp 0x00010000
    34                              <1>  %else
    35                              <1> 
    36                              <1>  %assign off_cmp 0x00020000
    37                              <1>  %endif
    38                              <1>  %else
    39 000009B2 FD                  <1>  std
    40                              <1>  %assign off_value 0x00010000
    41                              <1>  %ifidni %3,a16
    42                              <1> 
    43                              <1>  %assign off_cmp 0x0001ffff-(val_size-1)
    44                              <1>  %else
    45                              <1> 
    46                              <1>  %assign off_cmp 0x0000ffff-(val_size-1)
    47                              <1>  %endif
    48                              <1>  %endif
    49                              <1> 
    50                              <1>  %ifidni %3,a16
    51                              <1>  %assign off_mask 0x0000ffff
    52                              <1>  %else
    53                              <1>  %assign off_mask 0xffffffff
    54                              <1>  %endif
    55                              <1> 
    56                              <1> 
    57                              <1> 
    58 000009B3 66BF00000100        <1>  mov edi, off_value
    59 000009B9 66BB00000000        <1>  mov ebx, off_value & off_mask
    60 000009BF B000                <1>  mov sized_eax, 0
    61 000009C1 26678803            <1>  mov [es:ebx], sized_eax
    62 000009C5 B078                <1>  mov sized_eax, value
    63 000009C7 AA                  <1>  %3 stos%1
    64 000009C8 26673803            <1>  cmp [es:ebx], sized_eax
    65 000009CC 0F85F70B            <1>  jne error
    66 000009D0 6681FFFFFF0100      <1>  cmp edi, off_cmp
    67 000009D7 0F85EC0B            <1>  jne error
    68                              <1> 
    69 000009DB 66BE00000100        <1>  mov esi, off_value
    70 000009E1 66BF00000100        <1>  mov edi, off_value
    71 000009E7 66BB00000000        <1>  mov ebx, off_value & off_mask
    72 000009ED 3E678803            <1>  mov [ds:ebx], sized_eax
    73 000009F1 26678803            <1>  mov [es:ebx], sized_eax
    74 000009F5 3C00                <1>  cmp sized_eax, 0
    75 000009F7 0F84CC0B            <1>  je error
    76 000009FB A6                  <1>  %3 cmps%1
    77 000009FC 0F85C70B            <1>  jne error
    78 00000A00 6681FFFFFF0100      <1>  cmp edi, off_cmp
    79 00000A07 0F85BC0B            <1>  jne error
    80 00000A0B 6681FEFFFF0100      <1>  cmp esi, off_cmp
    81 00000A12 0F85B10B            <1>  jne error
    82                              <1> 
    83 00000A16 66BF00000100        <1>  mov edi, off_value
    84 00000A1C B078                <1>  mov sized_eax, value
    85 00000A1E 26678803            <1>  mov [es:ebx], sized_eax
    86 00000A22 3C00                <1>  cmp sized_eax, 0
    87 00000A24 AE                  <1>  %3 scas%1
    88 00000A25 0F859E0B            <1>  jne error
    89 00000A29 6681FFFFFF0100      <1>  cmp edi, off_cmp
    90 00000A30 0F85930B            <1>  jne error
    91                              <1> 
    92 00000A34 66BE00000100        <1>  mov esi, off_value
    93 00000A3A 66BF00000100        <1>  mov edi, off_value
    94 00000A40 B078                <1>  mov sized_eax, value
    95 00000A42 3E678803            <1>  mov [ds:ebx], sized_eax
    96 00000A46 B000                <1>  mov sized_eax, 0
    97 00000A48 26678803            <1>  mov [es:ebx], sized_eax
    98 00000A4C A4                  <1>  %3 movs%1
    99 00000A4D B078                <1>  mov sized_eax, value
   100 00000A4F 26673803            <1>  cmp [es:ebx], sized_eax
   101 00000A53 0F85700B            <1>  jne error
   102 00000A57 6681FFFFFF0100      <1>  cmp edi, off_cmp
   103 00000A5E 0F85650B            <1>  jne error
   104 00000A62 6681FEFFFF0100      <1>  cmp esi, off_cmp
   105 00000A69 0F855A0B            <1>  jne error
   106                              <1> 
   107 00000A6D 66BE00000100        <1>  mov esi, off_value
   108 00000A73 B078                <1>  mov sized_eax, value
   109 00000A75 26678803            <1>  mov [es:ebx], sized_eax
   110 00000A79 6631C0              <1>  xor eax, eax
   111 00000A7C AC                  <1>  %3 lods%1
   112 00000A7D 3C78                <1>  cmp sized_eax, value & val_mask
   113 00000A7F 0F85440B            <1>  jne error
   114 00000A83 6681FEFFFF0100      <1>  cmp esi, off_cmp
   115 00000A8A 0F85390B            <1>  jne error
   116                              <1> 
   193                                  	testStringOps w,1,a16
    10                              <1> 
    11                              <1>  %assign value 0x12345678
    12                              <1>  %ifidni %1,b
    13                              <1>  %assign val_size 1
    14                              <1>  %define val_mask 0x000000ff
    15                              <1>  %define sized_eax al
    16                              <1>  %endif
    17                              <1>  %ifidni %1,w
    18                              <1>  %assign val_size 2
    19                              <1>  %define val_mask 0x0000ffff
    20                              <1>  %define sized_eax ax
    21                              <1>  %endif
    22                              <1>  %ifidni %1,d
    23                              <1>  %assign val_size 4
    24                              <1>  %define val_mask 0xffffffff
    25                              <1>  %define sized_eax eax
    26                              <1>  %endif
    27                              <1> 
    28                              <1>  %if %2 == 0
    29                              <1>  cld
    30                              <1>  %assign off_value 0x0001ffff-(val_size-1)
    31                              <1>  %ifidni %3,a16
    32                              <1> 
    33                              <1>  %assign off_cmp 0x00010000
    34                              <1>  %else
    35                              <1> 
    36                              <1>  %assign off_cmp 0x00020000
    37                              <1>  %endif
    38                              <1>  %else
    39 00000A8E FD                  <1>  std
    40                              <1>  %assign off_value 0x00010000
    41                              <1>  %ifidni %3,a16
    42                              <1> 
    43                              <1>  %assign off_cmp 0x0001ffff-(val_size-1)
    44                              <1>  %else
    45                              <1> 
    46                              <1>  %assign off_cmp 0x0000ffff-(val_size-1)
    47                              <1>  %endif
    48                              <1>  %endif
    49                              <1> 
    50                              <1>  %ifidni %3,a16
    51                              <1>  %assign off_mask 0x0000ffff
    52                              <1>  %else
    53                              <1>  %assign off_mask 0xffffffff
    54                              <1>  %endif
    55                              <1> 
    56                              <1> 
    57                              <1> 
    58 00000A8F 66BF00000100        <1>  mov edi, off_value
    59 00000A95 66BB00000000        <1>  mov ebx, off_value & off_mask
    60 00000A9B B80000              <1>  mov sized_eax, 0
    61 00000A9E 26678903            <1>  mov [es:ebx], sized_eax
    62 00000AA2 B87856              <1>  mov sized_eax, value
    63 00000AA5 AB                  <1>  %3 stos%1
    64 00000AA6 26673903            <1>  cmp [es:ebx], sized_eax
    65 00000AAA 0F85190B            <1>  jne error
    66 00000AAE 6681FFFEFF0100      <1>  cmp edi, off_cmp
    67 00000AB5 0F850E0B            <1>  jne error
    68                              <1> 
    69 00000AB9 66BE00000100        <1>  mov esi, off_value
    70 00000ABF 66BF00000100        <1>  mov edi, off_value
    71 00000AC5 66BB00000000        <1>  mov ebx, off_value & off_mask
    72 00000ACB 3E678903            <1>  mov [ds:ebx], sized_eax
    73 00000ACF 26678903            <1>  mov [es:ebx], sized_eax
    74 00000AD3 83F800              <1>  cmp sized_eax, 0
    75 00000AD6 0F84ED0A            <1>  je error
    76 00000ADA A7                  <1>  %3 cmps%1
    77 00000ADB 0F85E80A            <1>  jne error
    78 00000ADF 6681FFFEFF0100      <1>  cmp edi, off_cmp
    79 00000AE6 0F85DD0A            <1>  jne error
    80 00000AEA 6681FEFEFF0100      <1>  cmp esi, off_cmp
    81 00000AF1 0F85D20A            <1>  jne error
    82                              <1> 
    83 00000AF5 66BF00000100        <1>  mov edi, off_value
    84 00000AFB B87856              <1>  mov sized_eax, value
    85 00000AFE 26678903            <1>  mov [es:ebx], sized_eax
    86 00000B02 83F800              <1>  cmp sized_eax, 0
    87 00000B05 AF                  <1>  %3 scas%1
    88 00000B06 0F85BD0A            <1>  jne error
    89 00000B0A 6681FFFEFF0100      <1>  cmp edi, off_cmp
    90 00000B11 0F85B20A            <1>  jne error
    91                              <1> 
    92 00000B15 66BE00000100        <1>  mov esi, off_value
    93 00000B1B 66BF00000100        <1>  mov edi, off_value
    94 00000B21 B87856              <1>  mov sized_eax, value
    95 00000B24 3E678903            <1>  mov [ds:ebx], sized_eax
    96 00000B28 B80000              <1>  mov sized_eax, 0
    97 00000B2B 26678903            <1>  mov [es:ebx], sized_eax
    98 00000B2F A5                  <1>  %3 movs%1
    99 00000B30 B87856              <1>  mov sized_eax, value
   100 00000B33 26673903            <1>  cmp [es:ebx], sized_eax
   101 00000B37 0F858C0A            <1>  jne error
   102 00000B3B 6681FFFEFF0100      <1>  cmp edi, off_cmp
   103 00000B42 0F85810A            <1>  jne error
   104 00000B46 6681FEFEFF0100      <1>  cmp esi, off_cmp
   105 00000B4D 0F85760A            <1>  jne error
   106                              <1> 
   107 00000B51 66BE00000100        <1>  mov esi, off_value
   108 00000B57 B87856              <1>  mov sized_eax, value
   109 00000B5A 26678903            <1>  mov [es:ebx], sized_eax
   110 00000B5E 6631C0              <1>  xor eax, eax
   111 00000B61 AD                  <1>  %3 lods%1
   112 00000B62 3D7856              <1>  cmp sized_eax, value & val_mask
   113 00000B65 0F855E0A            <1>  jne error
   114 00000B69 6681FEFEFF0100      <1>  cmp esi, off_cmp
   115 00000B70 0F85530A            <1>  jne error
   116                              <1> 
   194                                  	testStringOps d,1,a16
    10                              <1> 
    11                              <1>  %assign value 0x12345678
    12                              <1>  %ifidni %1,b
    13                              <1>  %assign val_size 1
    14                              <1>  %define val_mask 0x000000ff
    15                              <1>  %define sized_eax al
    16                              <1>  %endif
    17                              <1>  %ifidni %1,w
    18                              <1>  %assign val_size 2
    19                              <1>  %define val_mask 0x0000ffff
    20                              <1>  %define sized_eax ax
    21                              <1>  %endif
    22                              <1>  %ifidni %1,d
    23                              <1>  %assign val_size 4
    24                              <1>  %define val_mask 0xffffffff
    25                              <1>  %define sized_eax eax
    26                              <1>  %endif
    27                              <1> 
    28                              <1>  %if %2 == 0
    29                              <1>  cld
    30                              <1>  %assign off_value 0x0001ffff-(val_size-1)
    31                              <1>  %ifidni %3,a16
    32                              <1> 
    33                              <1>  %assign off_cmp 0x00010000
    34                              <1>  %else
    35                              <1> 
    36                              <1>  %assign off_cmp 0x00020000
    37                              <1>  %endif
    38                              <1>  %else
    39 00000B74 FD                  <1>  std
    40                              <1>  %assign off_value 0x00010000
    41                              <1>  %ifidni %3,a16
    42                              <1> 
    43                              <1>  %assign off_cmp 0x0001ffff-(val_size-1)
    44                              <1>  %else
    45                              <1> 
    46                              <1>  %assign off_cmp 0x0000ffff-(val_size-1)
    47                              <1>  %endif
    48                              <1>  %endif
    49                              <1> 
    50                              <1>  %ifidni %3,a16
    51                              <1>  %assign off_mask 0x0000ffff
    52                              <1>  %else
    53                              <1>  %assign off_mask 0xffffffff
    54                              <1>  %endif
    55                              <1> 
    56                              <1> 
    57                              <1> 
    58 00000B75 66BF00000100        <1>  mov edi, off_value
    59 00000B7B 66BB00000000        <1>  mov ebx, off_value & off_mask
    60 00000B81 66B800000000        <1>  mov sized_eax, 0
    61 00000B87 2666678903          <1>  mov [es:ebx], sized_eax
    62 00000B8C 66B878563412        <1>  mov sized_eax, value
    63 00000B92 66AB                <1>  %3 stos%1
    64 00000B94 2666673903          <1>  cmp [es:ebx], sized_eax
    65 00000B99 0F852A0A            <1>  jne error
    66 00000B9D 6681FFFCFF0100      <1>  cmp edi, off_cmp
    67 00000BA4 0F851F0A            <1>  jne error
    68                              <1> 
    69 00000BA8 66BE00000100        <1>  mov esi, off_value
    70 00000BAE 66BF00000100        <1>  mov edi, off_value
    71 00000BB4 66BB00000000        <1>  mov ebx, off_value & off_mask
    72 00000BBA 3E66678903          <1>  mov [ds:ebx], sized_eax
    73 00000BBF 2666678903          <1>  mov [es:ebx], sized_eax
    74 00000BC4 6683F800            <1>  cmp sized_eax, 0
    75 00000BC8 0F84FB09            <1>  je error
    76 00000BCC 66A7                <1>  %3 cmps%1
    77 00000BCE 0F85F509            <1>  jne error
    78 00000BD2 6681FFFCFF0100      <1>  cmp edi, off_cmp
    79 00000BD9 0F85EA09            <1>  jne error
    80 00000BDD 6681FEFCFF0100      <1>  cmp esi, off_cmp
    81 00000BE4 0F85DF09            <1>  jne error
    82                              <1> 
    83 00000BE8 66BF00000100        <1>  mov edi, off_value
    84 00000BEE 66B878563412        <1>  mov sized_eax, value
    85 00000BF4 2666678903          <1>  mov [es:ebx], sized_eax
    86 00000BF9 6683F800            <1>  cmp sized_eax, 0
    87 00000BFD 66AF                <1>  %3 scas%1
    88 00000BFF 0F85C409            <1>  jne error
    89 00000C03 6681FFFCFF0100      <1>  cmp edi, off_cmp
    90 00000C0A 0F85B909            <1>  jne error
    91                              <1> 
    92 00000C0E 66BE00000100        <1>  mov esi, off_value
    93 00000C14 66BF00000100        <1>  mov edi, off_value
    94 00000C1A 66B878563412        <1>  mov sized_eax, value
    95 00000C20 3E66678903          <1>  mov [ds:ebx], sized_eax
    96 00000C25 66B800000000        <1>  mov sized_eax, 0
    97 00000C2B 2666678903          <1>  mov [es:ebx], sized_eax
    98 00000C30 66A5                <1>  %3 movs%1
    99 00000C32 66B878563412        <1>  mov sized_eax, value
   100 00000C38 2666673903          <1>  cmp [es:ebx], sized_eax
   101 00000C3D 0F858609            <1>  jne error
   102 00000C41 6681FFFCFF0100      <1>  cmp edi, off_cmp
   103 00000C48 0F857B09            <1>  jne error
   104 00000C4C 6681FEFCFF0100      <1>  cmp esi, off_cmp
   105 00000C53 0F857009            <1>  jne error
   106                              <1> 
   107 00000C57 66BE00000100        <1>  mov esi, off_value
   108 00000C5D 66B878563412        <1>  mov sized_eax, value
   109 00000C63 2666678903          <1>  mov [es:ebx], sized_eax
   110 00000C68 6631C0              <1>  xor eax, eax
   111 00000C6B 66AD                <1>  %3 lods%1
   112 00000C6D 663D78563412        <1>  cmp sized_eax, value & val_mask
   113 00000C73 0F855009            <1>  jne error
   114 00000C77 6681FEFCFF0100      <1>  cmp esi, off_cmp
   115 00000C7E 0F854509            <1>  jne error
   116                              <1> 
   195                                  	testStringReps b,0,a16
   128                              <1> 
   129                              <1>  %assign bytes 0x100
   130                              <1> 
   131                              <1>  %ifidni %1,b
   132                              <1>  %assign items bytes
   133                              <1>  %endif
   134                              <1>  %ifidni %1,w
   135                              <1>  %assign items bytes/2
   136                              <1>  %endif
   137                              <1>  %ifidni %1,d
   138                              <1>  %assign items bytes/4
   139                              <1>  %endif
   140                              <1> 
   141                              <1>  %if %2 == 0
   142 00000C82 FC                  <1>  cld
   143                              <1>  %assign off_value 0x0001ff00
   144                              <1>  %ifidni %3,a16
   145                              <1> 
   146                              <1>  %assign off_cmp 0x00010000
   147                              <1>  %else
   148                              <1> 
   149                              <1>  %assign off_cmp 0x00020000
   150                              <1>  %endif
   151                              <1>  %else
   152                              <1>  std
   153                              <1>  %assign off_value 0x000100ff
   154                              <1>  %ifidni %3,a16
   155                              <1> 
   156                              <1>  %assign off_cmp 0x0001ffff
   157                              <1>  %else
   158                              <1> 
   159                              <1>  %assign off_cmp 0x0000ffff
   160                              <1>  %endif
   161                              <1>  %endif
   162                              <1> 
   163 00000C83 66B878563412        <1>  mov eax, 0x12345678
   164 00000C89 66BE00FF0100        <1>  mov esi, off_value
   165 00000C8F 66BF00FF0100        <1>  mov edi, off_value
   166                              <1> 
   167                              <1> 
   168                              <1> 
   169                              <1> 
   170 00000C95 66B878563412        <1>  mov eax, 0x12345678
   171 00000C9B 66BE00FF0100        <1>  mov esi, off_value
   172 00000CA1 66BF00FF0100        <1>  mov edi, off_value
   173 00000CA7 66B900010000        <1>  mov ecx, items
   174 00000CAD F3AA                <1>  %3 rep stos%1
   175 00000CAF 6683F900            <1>  cmp ecx, 0
   176 00000CB3 0F851009            <1>  jnz error
   177 00000CB7 6681FF00000100      <1>  cmp edi, off_cmp
   178 00000CBE 0F850509            <1>  jnz error
   179 00000CC2 66BF00FF0100        <1>  mov edi, off_value
   180                              <1> 
   181 00000CC8 8CC2                <1>  mov dx, es
   182 00000CCA 8CD9                <1>  mov cx, ds
   183 00000CCC 87CA                <1>  xchg dx, cx
   184 00000CCE 8EC2                <1>  mov es, dx
   185 00000CD0 8ED9                <1>  mov ds, cx
   186 00000CD2 6687F7              <1>  xchg edi, esi
   187                              <1> 
   188 00000CD5 66B900010000        <1>  mov ecx, items
   189 00000CDB F3AA                <1>  %3 rep stos%1
   190 00000CDD 66BF00FF0100        <1>  mov edi, off_value
   191                              <1> 
   192                              <1> 
   193 00000CE3 66B900010000        <1>  mov ecx, items
   194 00000CE9 F3A6                <1>  %3 repe cmps%1
   195 00000CEB 6683F900            <1>  cmp ecx, 0
   196 00000CEF 0F85D408            <1>  jnz error
   197 00000CF3 6681FE00000100      <1>  cmp esi, off_cmp
   198 00000CFA 0F85C908            <1>  jne error
   199 00000CFE 6681FF00000100      <1>  cmp edi, off_cmp
   200 00000D05 0F85BE08            <1>  jne error
   201 00000D09 66BF00FF0100        <1>  mov edi, off_value
   202 00000D0F 66BE00FF0100        <1>  mov esi, off_value
   203                              <1> 
   204                              <1> 
   205 00000D15 66B900010000        <1>  mov ecx, items
   206 00000D1B F3AE                <1>  %3 repe scas%1
   207 00000D1D 6683F900            <1>  cmp ecx, 0
   208 00000D21 0F85A208            <1>  jne error
   209 00000D25 6681FF00000100      <1>  cmp edi, off_cmp
   210 00000D2C 0F859708            <1>  jne error
   211 00000D30 66BF00FF0100        <1>  mov edi, off_value
   212                              <1> 
   213                              <1> 
   214                              <1> 
   215 00000D36 66B800000000        <1>  mov eax, 0
   216 00000D3C 66B900010000        <1>  mov ecx, items
   217 00000D42 F3AA                <1>  %3 rep stos%1
   218 00000D44 66BF00FF0100        <1>  mov edi, off_value
   219 00000D4A 66B900010000        <1>  mov ecx, items
   220 00000D50 F3A4                <1>  %3 rep movs%1
   221 00000D52 6683F900            <1>  cmp ecx, 0
   222 00000D56 0F856D08            <1>  jne error
   223 00000D5A 6681FE00000100      <1>  cmp esi, off_cmp
   224 00000D61 0F856208            <1>  jne error
   225 00000D65 6681FF00000100      <1>  cmp edi, off_cmp
   226 00000D6C 0F855708            <1>  jne error
   227 00000D70 66B900010000        <1>  mov ecx, items
   228 00000D76 66BF00FF0100        <1>  mov edi, off_value
   229 00000D7C 66BE00FF0100        <1>  mov esi, off_value
   230 00000D82 F3A6                <1>  %3 repe cmps%1
   231 00000D84 6683F900            <1>  cmp ecx, 0
   232 00000D88 0F853B08            <1>  jne error
   233 00000D8C 6681FE00000100      <1>  cmp esi, off_cmp
   234 00000D93 0F853008            <1>  jne error
   235 00000D97 6681FF00000100      <1>  cmp edi, off_cmp
   236 00000D9E 0F852508            <1>  jne error
   196                                  	testStringReps w,0,a16
   128                              <1> 
   129                              <1>  %assign bytes 0x100
   130                              <1> 
   131                              <1>  %ifidni %1,b
   132                              <1>  %assign items bytes
   133                              <1>  %endif
   134                              <1>  %ifidni %1,w
   135                              <1>  %assign items bytes/2
   136                              <1>  %endif
   137                              <1>  %ifidni %1,d
   138                              <1>  %assign items bytes/4
   139                              <1>  %endif
   140                              <1> 
   141                              <1>  %if %2 == 0
   142 00000DA2 FC                  <1>  cld
   143                              <1>  %assign off_value 0x0001ff00
   144                              <1>  %ifidni %3,a16
   145                              <1> 
   146                              <1>  %assign off_cmp 0x00010000
   147                              <1>  %else
   148                              <1> 
   149                              <1>  %assign off_cmp 0x00020000
   150                              <1>  %endif
   151                              <1>  %else
   152                              <1>  std
   153                              <1>  %assign off_value 0x000100ff
   154                              <1>  %ifidni %3,a16
   155                              <1> 
   156                              <1>  %assign off_cmp 0x0001ffff
   157                              <1>  %else
   158                              <1> 
   159                              <1>  %assign off_cmp 0x0000ffff
   160                              <1>  %endif
   161                              <1>  %endif
   162                              <1> 
   163 00000DA3 66B878563412        <1>  mov eax, 0x12345678
   164 00000DA9 66BE00FF0100        <1>  mov esi, off_value
   165 00000DAF 66BF00FF0100        <1>  mov edi, off_value
   166                              <1> 
   167                              <1> 
   168                              <1> 
   169                              <1> 
   170 00000DB5 66B878563412        <1>  mov eax, 0x12345678
   171 00000DBB 66BE00FF0100        <1>  mov esi, off_value
   172 00000DC1 66BF00FF0100        <1>  mov edi, off_value
   173 00000DC7 66B980000000        <1>  mov ecx, items
   174 00000DCD F3AB                <1>  %3 rep stos%1
   175 00000DCF 6683F900            <1>  cmp ecx, 0
   176 00000DD3 0F85F007            <1>  jnz error
   177 00000DD7 6681FF00000100      <1>  cmp edi, off_cmp
   178 00000DDE 0F85E507            <1>  jnz error
   179 00000DE2 66BF00FF0100        <1>  mov edi, off_value
   180                              <1> 
   181 00000DE8 8CC2                <1>  mov dx, es
   182 00000DEA 8CD9                <1>  mov cx, ds
   183 00000DEC 87CA                <1>  xchg dx, cx
   184 00000DEE 8EC2                <1>  mov es, dx
   185 00000DF0 8ED9                <1>  mov ds, cx
   186 00000DF2 6687F7              <1>  xchg edi, esi
   187                              <1> 
   188 00000DF5 66B980000000        <1>  mov ecx, items
   189 00000DFB F3AB                <1>  %3 rep stos%1
   190 00000DFD 66BF00FF0100        <1>  mov edi, off_value
   191                              <1> 
   192                              <1> 
   193 00000E03 66B980000000        <1>  mov ecx, items
   194 00000E09 F3A7                <1>  %3 repe cmps%1
   195 00000E0B 6683F900            <1>  cmp ecx, 0
   196 00000E0F 0F85B407            <1>  jnz error
   197 00000E13 6681FE00000100      <1>  cmp esi, off_cmp
   198 00000E1A 0F85A907            <1>  jne error
   199 00000E1E 6681FF00000100      <1>  cmp edi, off_cmp
   200 00000E25 0F859E07            <1>  jne error
   201 00000E29 66BF00FF0100        <1>  mov edi, off_value
   202 00000E2F 66BE00FF0100        <1>  mov esi, off_value
   203                              <1> 
   204                              <1> 
   205 00000E35 66B980000000        <1>  mov ecx, items
   206 00000E3B F3AF                <1>  %3 repe scas%1
   207 00000E3D 6683F900            <1>  cmp ecx, 0
   208 00000E41 0F858207            <1>  jne error
   209 00000E45 6681FF00000100      <1>  cmp edi, off_cmp
   210 00000E4C 0F857707            <1>  jne error
   211 00000E50 66BF00FF0100        <1>  mov edi, off_value
   212                              <1> 
   213                              <1> 
   214                              <1> 
   215 00000E56 66B800000000        <1>  mov eax, 0
   216 00000E5C 66B980000000        <1>  mov ecx, items
   217 00000E62 F3AB                <1>  %3 rep stos%1
   218 00000E64 66BF00FF0100        <1>  mov edi, off_value
   219 00000E6A 66B980000000        <1>  mov ecx, items
   220 00000E70 F3A5                <1>  %3 rep movs%1
   221 00000E72 6683F900            <1>  cmp ecx, 0
   222 00000E76 0F854D07            <1>  jne error
   223 00000E7A 6681FE00000100      <1>  cmp esi, off_cmp
   224 00000E81 0F854207            <1>  jne error
   225 00000E85 6681FF00000100      <1>  cmp edi, off_cmp
   226 00000E8C 0F853707            <1>  jne error
   227 00000E90 66B980000000        <1>  mov ecx, items
   228 00000E96 66BF00FF0100        <1>  mov edi, off_value
   229 00000E9C 66BE00FF0100        <1>  mov esi, off_value
   230 00000EA2 F3A7                <1>  %3 repe cmps%1
   231 00000EA4 6683F900            <1>  cmp ecx, 0
   232 00000EA8 0F851B07            <1>  jne error
   233 00000EAC 6681FE00000100      <1>  cmp esi, off_cmp
   234 00000EB3 0F851007            <1>  jne error
   235 00000EB7 6681FF00000100      <1>  cmp edi, off_cmp
   236 00000EBE 0F850507            <1>  jne error
   197                                  	testStringReps d,0,a16
   128                              <1> 
   129                              <1>  %assign bytes 0x100
   130                              <1> 
   131                              <1>  %ifidni %1,b
   132                              <1>  %assign items bytes
   133                              <1>  %endif
   134                              <1>  %ifidni %1,w
   135                              <1>  %assign items bytes/2
   136                              <1>  %endif
   137                              <1>  %ifidni %1,d
   138                              <1>  %assign items bytes/4
   139                              <1>  %endif
   140                              <1> 
   141                              <1>  %if %2 == 0
   142 00000EC2 FC                  <1>  cld
   143                              <1>  %assign off_value 0x0001ff00
   144                              <1>  %ifidni %3,a16
   145                              <1> 
   146                              <1>  %assign off_cmp 0x00010000
   147                              <1>  %else
   148                              <1> 
   149                              <1>  %assign off_cmp 0x00020000
   150                              <1>  %endif
   151                              <1>  %else
   152                              <1>  std
   153                              <1>  %assign off_value 0x000100ff
   154                              <1>  %ifidni %3,a16
   155                              <1> 
   156                              <1>  %assign off_cmp 0x0001ffff
   157                              <1>  %else
   158                              <1> 
   159                              <1>  %assign off_cmp 0x0000ffff
   160                              <1>  %endif
   161                              <1>  %endif
   162                              <1> 
   163 00000EC3 66B878563412        <1>  mov eax, 0x12345678
   164 00000EC9 66BE00FF0100        <1>  mov esi, off_value
   165 00000ECF 66BF00FF0100        <1>  mov edi, off_value
   166                              <1> 
   167                              <1> 
   168                              <1> 
   169                              <1> 
   170 00000ED5 66B878563412        <1>  mov eax, 0x12345678
   171 00000EDB 66BE00FF0100        <1>  mov esi, off_value
   172 00000EE1 66BF00FF0100        <1>  mov edi, off_value
   173 00000EE7 66B940000000        <1>  mov ecx, items
   174 00000EED F366AB              <1>  %3 rep stos%1
   175 00000EF0 6683F900            <1>  cmp ecx, 0
   176 00000EF4 0F85CF06            <1>  jnz error
   177 00000EF8 6681FF00000100      <1>  cmp edi, off_cmp
   178 00000EFF 0F85C406            <1>  jnz error
   179 00000F03 66BF00FF0100        <1>  mov edi, off_value
   180                              <1> 
   181 00000F09 8CC2                <1>  mov dx, es
   182 00000F0B 8CD9                <1>  mov cx, ds
   183 00000F0D 87CA                <1>  xchg dx, cx
   184 00000F0F 8EC2                <1>  mov es, dx
   185 00000F11 8ED9                <1>  mov ds, cx
   186 00000F13 6687F7              <1>  xchg edi, esi
   187                              <1> 
   188 00000F16 66B940000000        <1>  mov ecx, items
   189 00000F1C F366AB              <1>  %3 rep stos%1
   190 00000F1F 66BF00FF0100        <1>  mov edi, off_value
   191                              <1> 
   192                              <1> 
   193 00000F25 66B940000000        <1>  mov ecx, items
   194 00000F2B F366A7              <1>  %3 repe cmps%1
   195 00000F2E 6683F900            <1>  cmp ecx, 0
   196 00000F32 0F859106            <1>  jnz error
   197 00000F36 6681FE00000100      <1>  cmp esi, off_cmp
   198 00000F3D 0F858606            <1>  jne error
   199 00000F41 6681FF00000100      <1>  cmp edi, off_cmp
   200 00000F48 0F857B06            <1>  jne error
   201 00000F4C 66BF00FF0100        <1>  mov edi, off_value
   202 00000F52 66BE00FF0100        <1>  mov esi, off_value
   203                              <1> 
   204                              <1> 
   205 00000F58 66B940000000        <1>  mov ecx, items
   206 00000F5E F366AF              <1>  %3 repe scas%1
   207 00000F61 6683F900            <1>  cmp ecx, 0
   208 00000F65 0F855E06            <1>  jne error
   209 00000F69 6681FF00000100      <1>  cmp edi, off_cmp
   210 00000F70 0F855306            <1>  jne error
   211 00000F74 66BF00FF0100        <1>  mov edi, off_value
   212                              <1> 
   213                              <1> 
   214                              <1> 
   215 00000F7A 66B800000000        <1>  mov eax, 0
   216 00000F80 66B940000000        <1>  mov ecx, items
   217 00000F86 F366AB              <1>  %3 rep stos%1
   218 00000F89 66BF00FF0100        <1>  mov edi, off_value
   219 00000F8F 66B940000000        <1>  mov ecx, items
   220 00000F95 F366A5              <1>  %3 rep movs%1
   221 00000F98 6683F900            <1>  cmp ecx, 0
   222 00000F9C 0F852706            <1>  jne error
   223 00000FA0 6681FE00000100      <1>  cmp esi, off_cmp
   224 00000FA7 0F851C06            <1>  jne error
   225 00000FAB 6681FF00000100      <1>  cmp edi, off_cmp
   226 00000FB2 0F851106            <1>  jne error
   227 00000FB6 66B940000000        <1>  mov ecx, items
   228 00000FBC 66BF00FF0100        <1>  mov edi, off_value
   229 00000FC2 66BE00FF0100        <1>  mov esi, off_value
   230 00000FC8 F366A7              <1>  %3 repe cmps%1
   231 00000FCB 6683F900            <1>  cmp ecx, 0
   232 00000FCF 0F85F405            <1>  jne error
   233 00000FD3 6681FE00000100      <1>  cmp esi, off_cmp
   234 00000FDA 0F85E905            <1>  jne error
   235 00000FDE 6681FF00000100      <1>  cmp edi, off_cmp
   236 00000FE5 0F85DE05            <1>  jne error
   198                                  	testStringReps b,1,a16
   128                              <1> 
   129                              <1>  %assign bytes 0x100
   130                              <1> 
   131                              <1>  %ifidni %1,b
   132                              <1>  %assign items bytes
   133                              <1>  %endif
   134                              <1>  %ifidni %1,w
   135                              <1>  %assign items bytes/2
   136                              <1>  %endif
   137                              <1>  %ifidni %1,d
   138                              <1>  %assign items bytes/4
   139                              <1>  %endif
   140                              <1> 
   141                              <1>  %if %2 == 0
   142                              <1>  cld
   143                              <1>  %assign off_value 0x0001ff00
   144                              <1>  %ifidni %3,a16
   145                              <1> 
   146                              <1>  %assign off_cmp 0x00010000
   147                              <1>  %else
   148                              <1> 
   149                              <1>  %assign off_cmp 0x00020000
   150                              <1>  %endif
   151                              <1>  %else
   152 00000FE9 FD                  <1>  std
   153                              <1>  %assign off_value 0x000100ff
   154                              <1>  %ifidni %3,a16
   155                              <1> 
   156                              <1>  %assign off_cmp 0x0001ffff
   157                              <1>  %else
   158                              <1> 
   159                              <1>  %assign off_cmp 0x0000ffff
   160                              <1>  %endif
   161                              <1>  %endif
   162                              <1> 
   163 00000FEA 66B878563412        <1>  mov eax, 0x12345678
   164 00000FF0 66BEFF000100        <1>  mov esi, off_value
   165 00000FF6 66BFFF000100        <1>  mov edi, off_value
   166                              <1> 
   167                              <1> 
   168                              <1> 
   169                              <1> 
   170 00000FFC 66B878563412        <1>  mov eax, 0x12345678
   171 00001002 66BEFF000100        <1>  mov esi, off_value
   172 00001008 66BFFF000100        <1>  mov edi, off_value
   173 0000100E 66B900010000        <1>  mov ecx, items
   174 00001014 F3AA                <1>  %3 rep stos%1
   175 00001016 6683F900            <1>  cmp ecx, 0
   176 0000101A 0F85A905            <1>  jnz error
   177 0000101E 6681FFFFFF0100      <1>  cmp edi, off_cmp
   178 00001025 0F859E05            <1>  jnz error
   179 00001029 66BFFF000100        <1>  mov edi, off_value
   180                              <1> 
   181 0000102F 8CC2                <1>  mov dx, es
   182 00001031 8CD9                <1>  mov cx, ds
   183 00001033 87CA                <1>  xchg dx, cx
   184 00001035 8EC2                <1>  mov es, dx
   185 00001037 8ED9                <1>  mov ds, cx
   186 00001039 6687F7              <1>  xchg edi, esi
   187                              <1> 
   188 0000103C 66B900010000        <1>  mov ecx, items
   189 00001042 F3AA                <1>  %3 rep stos%1
   190 00001044 66BFFF000100        <1>  mov edi, off_value
   191                              <1> 
   192                              <1> 
   193 0000104A 66B900010000        <1>  mov ecx, items
   194 00001050 F3A6                <1>  %3 repe cmps%1
   195 00001052 6683F900            <1>  cmp ecx, 0
   196 00001056 0F856D05            <1>  jnz error
   197 0000105A 6681FEFFFF0100      <1>  cmp esi, off_cmp
   198 00001061 0F856205            <1>  jne error
   199 00001065 6681FFFFFF0100      <1>  cmp edi, off_cmp
   200 0000106C 0F855705            <1>  jne error
   201 00001070 66BFFF000100        <1>  mov edi, off_value
   202 00001076 66BEFF000100        <1>  mov esi, off_value
   203                              <1> 
   204                              <1> 
   205 0000107C 66B900010000        <1>  mov ecx, items
   206 00001082 F3AE                <1>  %3 repe scas%1
   207 00001084 6683F900            <1>  cmp ecx, 0
   208 00001088 0F853B05            <1>  jne error
   209 0000108C 6681FFFFFF0100      <1>  cmp edi, off_cmp
   210 00001093 0F853005            <1>  jne error
   211 00001097 66BFFF000100        <1>  mov edi, off_value
   212                              <1> 
   213                              <1> 
   214                              <1> 
   215 0000109D 66B800000000        <1>  mov eax, 0
   216 000010A3 66B900010000        <1>  mov ecx, items
   217 000010A9 F3AA                <1>  %3 rep stos%1
   218 000010AB 66BFFF000100        <1>  mov edi, off_value
   219 000010B1 66B900010000        <1>  mov ecx, items
   220 000010B7 F3A4                <1>  %3 rep movs%1
   221 000010B9 6683F900            <1>  cmp ecx, 0
   222 000010BD 0F850605            <1>  jne error
   223 000010C1 6681FEFFFF0100      <1>  cmp esi, off_cmp
   224 000010C8 0F85FB04            <1>  jne error
   225 000010CC 6681FFFFFF0100      <1>  cmp edi, off_cmp
   226 000010D3 0F85F004            <1>  jne error
   227 000010D7 66B900010000        <1>  mov ecx, items
   228 000010DD 66BFFF000100        <1>  mov edi, off_value
   229 000010E3 66BEFF000100        <1>  mov esi, off_value
   230 000010E9 F3A6                <1>  %3 repe cmps%1
   231 000010EB 6683F900            <1>  cmp ecx, 0
   232 000010EF 0F85D404            <1>  jne error
   233 000010F3 6681FEFFFF0100      <1>  cmp esi, off_cmp
   234 000010FA 0F85C904            <1>  jne error
   235 000010FE 6681FFFFFF0100      <1>  cmp edi, off_cmp
   236 00001105 0F85BE04            <1>  jne error
   199                                  	testStringReps w,1,a16
   128                              <1> 
   129                              <1>  %assign bytes 0x100
   130                              <1> 
   131                              <1>  %ifidni %1,b
   132                              <1>  %assign items bytes
   133                              <1>  %endif
   134                              <1>  %ifidni %1,w
   135                              <1>  %assign items bytes/2
   136                              <1>  %endif
   137                              <1>  %ifidni %1,d
   138                              <1>  %assign items bytes/4
   139                              <1>  %endif
   140                              <1> 
   141                              <1>  %if %2 == 0
   142                              <1>  cld
   143                              <1>  %assign off_value 0x0001ff00
   144                              <1>  %ifidni %3,a16
   145                              <1> 
   146                              <1>  %assign off_cmp 0x00010000
   147                              <1>  %else
   148                              <1> 
   149                              <1>  %assign off_cmp 0x00020000
   150                              <1>  %endif
   151                              <1>  %else
   152 00001109 FD                  <1>  std
   153                              <1>  %assign off_value 0x000100ff
   154                              <1>  %ifidni %3,a16
   155                              <1> 
   156                              <1>  %assign off_cmp 0x0001ffff
   157                              <1>  %else
   158                              <1> 
   159                              <1>  %assign off_cmp 0x0000ffff
   160                              <1>  %endif
   161                              <1>  %endif
   162                              <1> 
   163 0000110A 66B878563412        <1>  mov eax, 0x12345678
   164 00001110 66BEFF000100        <1>  mov esi, off_value
   165 00001116 66BFFF000100        <1>  mov edi, off_value
   166                              <1> 
   167                              <1> 
   168                              <1> 
   169                              <1> 
   170 0000111C 66B878563412        <1>  mov eax, 0x12345678
   171 00001122 66BEFF000100        <1>  mov esi, off_value
   172 00001128 66BFFF000100        <1>  mov edi, off_value
   173 0000112E 66B980000000        <1>  mov ecx, items
   174 00001134 F3AB                <1>  %3 rep stos%1
   175 00001136 6683F900            <1>  cmp ecx, 0
   176 0000113A 0F858904            <1>  jnz error
   177 0000113E 6681FFFFFF0100      <1>  cmp edi, off_cmp
   178 00001145 0F857E04            <1>  jnz error
   179 00001149 66BFFF000100        <1>  mov edi, off_value
   180                              <1> 
   181 0000114F 8CC2                <1>  mov dx, es
   182 00001151 8CD9                <1>  mov cx, ds
   183 00001153 87CA                <1>  xchg dx, cx
   184 00001155 8EC2                <1>  mov es, dx
   185 00001157 8ED9                <1>  mov ds, cx
   186 00001159 6687F7              <1>  xchg edi, esi
   187                              <1> 
   188 0000115C 66B980000000        <1>  mov ecx, items
   189 00001162 F3AB                <1>  %3 rep stos%1
   190 00001164 66BFFF000100        <1>  mov edi, off_value
   191                              <1> 
   192                              <1> 
   193 0000116A 66B980000000        <1>  mov ecx, items
   194 00001170 F3A7                <1>  %3 repe cmps%1
   195 00001172 6683F900            <1>  cmp ecx, 0
   196 00001176 0F854D04            <1>  jnz error
   197 0000117A 6681FEFFFF0100      <1>  cmp esi, off_cmp
   198 00001181 0F854204            <1>  jne error
   199 00001185 6681FFFFFF0100      <1>  cmp edi, off_cmp
   200 0000118C 0F853704            <1>  jne error
   201 00001190 66BFFF000100        <1>  mov edi, off_value
   202 00001196 66BEFF000100        <1>  mov esi, off_value
   203                              <1> 
   204                              <1> 
   205 0000119C 66B980000000        <1>  mov ecx, items
   206 000011A2 F3AF                <1>  %3 repe scas%1
   207 000011A4 6683F900            <1>  cmp ecx, 0
   208 000011A8 0F851B04            <1>  jne error
   209 000011AC 6681FFFFFF0100      <1>  cmp edi, off_cmp
   210 000011B3 0F851004            <1>  jne error
   211 000011B7 66BFFF000100        <1>  mov edi, off_value
   212                              <1> 
   213                              <1> 
   214                              <1> 
   215 000011BD 66B800000000        <1>  mov eax, 0
   216 000011C3 66B980000000        <1>  mov ecx, items
   217 000011C9 F3AB                <1>  %3 rep stos%1
   218 000011CB 66BFFF000100        <1>  mov edi, off_value
   219 000011D1 66B980000000        <1>  mov ecx, items
   220 000011D7 F3A5                <1>  %3 rep movs%1
   221 000011D9 6683F900            <1>  cmp ecx, 0
   222 000011DD 0F85E603            <1>  jne error
   223 000011E1 6681FEFFFF0100      <1>  cmp esi, off_cmp
   224 000011E8 0F85DB03            <1>  jne error
   225 000011EC 6681FFFFFF0100      <1>  cmp edi, off_cmp
   226 000011F3 0F85D003            <1>  jne error
   227 000011F7 66B980000000        <1>  mov ecx, items
   228 000011FD 66BFFF000100        <1>  mov edi, off_value
   229 00001203 66BEFF000100        <1>  mov esi, off_value
   230 00001209 F3A7                <1>  %3 repe cmps%1
   231 0000120B 6683F900            <1>  cmp ecx, 0
   232 0000120F 0F85B403            <1>  jne error
   233 00001213 6681FEFFFF0100      <1>  cmp esi, off_cmp
   234 0000121A 0F85A903            <1>  jne error
   235 0000121E 6681FFFFFF0100      <1>  cmp edi, off_cmp
   236 00001225 0F859E03            <1>  jne error
   200                                  	testStringReps d,1,a16
   128                              <1> 
   129                              <1>  %assign bytes 0x100
   130                              <1> 
   131                              <1>  %ifidni %1,b
   132                              <1>  %assign items bytes
   133                              <1>  %endif
   134                              <1>  %ifidni %1,w
   135                              <1>  %assign items bytes/2
   136                              <1>  %endif
   137                              <1>  %ifidni %1,d
   138                              <1>  %assign items bytes/4
   139                              <1>  %endif
   140                              <1> 
   141                              <1>  %if %2 == 0
   142                              <1>  cld
   143                              <1>  %assign off_value 0x0001ff00
   144                              <1>  %ifidni %3,a16
   145                              <1> 
   146                              <1>  %assign off_cmp 0x00010000
   147                              <1>  %else
   148                              <1> 
   149                              <1>  %assign off_cmp 0x00020000
   150                              <1>  %endif
   151                              <1>  %else
   152 00001229 FD                  <1>  std
   153                              <1>  %assign off_value 0x000100ff
   154                              <1>  %ifidni %3,a16
   155                              <1> 
   156                              <1>  %assign off_cmp 0x0001ffff
   157                              <1>  %else
   158                              <1> 
   159                              <1>  %assign off_cmp 0x0000ffff
   160                              <1>  %endif
   161                              <1>  %endif
   162                              <1> 
   163 0000122A 66B878563412        <1>  mov eax, 0x12345678
   164 00001230 66BEFF000100        <1>  mov esi, off_value
   165 00001236 66BFFF000100        <1>  mov edi, off_value
   166                              <1> 
   167                              <1> 
   168                              <1> 
   169                              <1> 
   170 0000123C 66B878563412        <1>  mov eax, 0x12345678
   171 00001242 66BEFF000100        <1>  mov esi, off_value
   172 00001248 66BFFF000100        <1>  mov edi, off_value
   173 0000124E 66B940000000        <1>  mov ecx, items
   174 00001254 F366AB              <1>  %3 rep stos%1
   175 00001257 6683F900            <1>  cmp ecx, 0
   176 0000125B 0F856803            <1>  jnz error
   177 0000125F 6681FFFFFF0100      <1>  cmp edi, off_cmp
   178 00001266 0F855D03            <1>  jnz error
   179 0000126A 66BFFF000100        <1>  mov edi, off_value
   180                              <1> 
   181 00001270 8CC2                <1>  mov dx, es
   182 00001272 8CD9                <1>  mov cx, ds
   183 00001274 87CA                <1>  xchg dx, cx
   184 00001276 8EC2                <1>  mov es, dx
   185 00001278 8ED9                <1>  mov ds, cx
   186 0000127A 6687F7              <1>  xchg edi, esi
   187                              <1> 
   188 0000127D 66B940000000        <1>  mov ecx, items
   189 00001283 F366AB              <1>  %3 rep stos%1
   190 00001286 66BFFF000100        <1>  mov edi, off_value
   191                              <1> 
   192                              <1> 
   193 0000128C 66B940000000        <1>  mov ecx, items
   194 00001292 F366A7              <1>  %3 repe cmps%1
   195 00001295 6683F900            <1>  cmp ecx, 0
   196 00001299 0F852A03            <1>  jnz error
   197 0000129D 6681FEFFFF0100      <1>  cmp esi, off_cmp
   198 000012A4 0F851F03            <1>  jne error
   199 000012A8 6681FFFFFF0100      <1>  cmp edi, off_cmp
   200 000012AF 0F851403            <1>  jne error
   201 000012B3 66BFFF000100        <1>  mov edi, off_value
   202 000012B9 66BEFF000100        <1>  mov esi, off_value
   203                              <1> 
   204                              <1> 
   205 000012BF 66B940000000        <1>  mov ecx, items
   206 000012C5 F366AF              <1>  %3 repe scas%1
   207 000012C8 6683F900            <1>  cmp ecx, 0
   208 000012CC 0F85F702            <1>  jne error
   209 000012D0 6681FFFFFF0100      <1>  cmp edi, off_cmp
   210 000012D7 0F85EC02            <1>  jne error
   211 000012DB 66BFFF000100        <1>  mov edi, off_value
   212                              <1> 
   213                              <1> 
   214                              <1> 
   215 000012E1 66B800000000        <1>  mov eax, 0
   216 000012E7 66B940000000        <1>  mov ecx, items
   217 000012ED F366AB              <1>  %3 rep stos%1
   218 000012F0 66BFFF000100        <1>  mov edi, off_value
   219 000012F6 66B940000000        <1>  mov ecx, items
   220 000012FC F366A5              <1>  %3 rep movs%1
   221 000012FF 6683F900            <1>  cmp ecx, 0
   222 00001303 0F85C002            <1>  jne error
   223 00001307 6681FEFFFF0100      <1>  cmp esi, off_cmp
   224 0000130E 0F85B502            <1>  jne error
   225 00001312 6681FFFFFF0100      <1>  cmp edi, off_cmp
   226 00001319 0F85AA02            <1>  jne error
   227 0000131D 66B940000000        <1>  mov ecx, items
   228 00001323 66BFFF000100        <1>  mov edi, off_value
   229 00001329 66BEFF000100        <1>  mov esi, off_value
   230 0000132F F366A7              <1>  %3 repe cmps%1
   231 00001332 6683F900            <1>  cmp ecx, 0
   232 00001336 0F858D02            <1>  jne error
   233 0000133A 6681FEFFFF0100      <1>  cmp esi, off_cmp
   234 00001341 0F858202            <1>  jne error
   235 00001345 6681FFFFFF0100      <1>  cmp edi, off_cmp
   236 0000134C 0F857702            <1>  jne error
   201                                  
   202                                  	advTestSegReal
     8                              <1>  advTestBase
    86                              <2>  %assign TEST_BASE1 TEST_BASE1+0x1000
    87                              <2>  %assign TEST_BASE2 TEST_BASE2+0x1000
     9                              <1>  %assign D1_SEG_REAL TEST_BASE1 >> 4
    10                              <1>  %assign D2_SEG_REAL TEST_BASE2 >> 4
    11 00001350 BA0022              <1>  mov dx, D1_SEG_REAL
    12 00001353 8EDA                <1>  mov ds, dx
    13 00001355 BA0062              <1>  mov dx, D2_SEG_REAL
    14 00001358 8EC2                <1>  mov es, dx
   203                                  
   204                                  
   205                                  %include "tests/call_m.asm"
     1                              <1> ;
     2                              <1> ;   Tests Call near by displacement and register indirect
     3                              <1> ;   Stack must be initilized.
     4                              <1> ;   %1: stack pointer register
     5                              <1> ;   Uses: AX, EBX, Flags
     6                              <1> ;
     7                              <1> %macro testCallNear 1
     8                              <1> 	%ifidni %1,sp
     9                              <1> 	%define spcmp ax
    10                              <1> 	%else
    11                              <1> 	%define spcmp eax
    12                              <1> 	%endif
    13                              <1> 	mov spcmp, %1
    14                              <1> 
    15                              <1> %%rel16:
    16                              <1> 	clc
    17                              <1> 	o16 call word %%nearfn16
    18                              <1> 	jnc error
    19                              <1> 	jmp %%rel32
    20                              <1> %%nearfn16:
    21                              <1> 	sub spcmp, 2
    22                              <1> 	cmp %1, spcmp
    23                              <1> 	jne error
    24                              <1> 	add spcmp, 2
    25                              <1> 	stc
    26                              <1> 	o16 ret
    27                              <1> 	jmp error
    28                              <1> 
    29                              <1> %%rel32:
    30                              <1> 	clc
    31                              <1> 	o32 call dword %%nearfn32
    32                              <1> 	jnc error
    33                              <1> 	jmp %%rm16
    34                              <1> %%nearfn32:
    35                              <1> 	sub spcmp, 4
    36                              <1> 	cmp %1, spcmp
    37                              <1> 	jne error
    38                              <1> 	add spcmp, 4
    39                              <1> 	stc
    40                              <1> 	o32 ret
    41                              <1> 	jmp error
    42                              <1> 
    43                              <1> %%rm16:
    44                              <1> 	clc
    45                              <1> 	mov bx, %%nearfn16
    46                              <1> 	o16 call bx
    47                              <1> 	jnc error
    48                              <1> %%rm32:
    49                              <1> 	clc
    50                              <1> 	mov ebx, %%nearfn32
    51                              <1> 	o32 call ebx
    52                              <1> 	jnc error
    53                              <1> %endmacro
    54                              <1> 
    55                              <1> ;
    56                              <1> ;   Tests Call far by immediate and memory pointers
    57                              <1> ;   Stack must be initilized
    58                              <1> ;   %1: code segment
    59                              <1> ;   Uses: AX, Flags, DS:SI as scratch memory
    60                              <1> ;
    61                              <1> %macro testCallFar 1
    62                              <1> 	mov ax, sp
    63                              <1> 
    64                              <1> 	clc
    65                              <1> 	o16 call word %1:%%farfn16
    66                              <1> 	jnc error
    67                              <1> 	jmp %%o32
    68                              <1> %%farfn16:
    69                              <1> 	sub ax, 4
    70                              <1> 	cmp sp, ax
    71                              <1> 	jne error
    72                              <1> 	add ax, 4
    73                              <1> 	stc
    74                              <1> 	o16 retf
    75                              <1> 	jmp error
    76                              <1> 
    77                              <1> %%o32:
    78                              <1> 	clc
    79                              <1> 	o32 call dword %1:%%farfn32
    80                              <1> 	jnc error
    81                              <1> 	jmp %%m1616
    82                              <1> %%farfn32:
    83                              <1> 	sub ax, 8
    84                              <1> 	cmp sp, ax
    85                              <1> 	jne error
    86                              <1> 	add ax, 8
    87                              <1> 	stc
    88                              <1> 	o32 retf
    89                              <1> 	jmp error
    90                              <1> 
    91                              <1> %%m1616:
    92                              <1> 	clc
    93                              <1> 	mov [si], word %%farfn16
    94                              <1> 	mov [si+2], word %1
    95                              <1> 	o16 call far [si]
    96                              <1> 	jnc error
    97                              <1> %%m1632:
    98                              <1> 	clc
    99                              <1> 	mov [si], dword %%farfn32
   100                              <1> 	mov [si+4], word %1
   101                              <1> 	o32 call far [si]
   102                              <1> 	jnc error
   103                              <1> %%exit:
   104                              <1> %endmacro
   206                                  ;-------------------------------------------------------------------------------
   207                                  	POST 5
     5 0000135A B005                <1>  mov al, 0x%1
     6 0000135C BA9909              <1>  mov dx, POST_PORT
     7 0000135F EE                  <1>  out dx, al
   208                                  ;-------------------------------------------------------------------------------
   209                                  ;
   210                                  ;   Calls in real mode
   211                                  ;
   212 00001360 BE0000                  	mov    si, 0
   213                                  	testCallNear sp
     8                              <1>  %ifidni %1,sp
     9                              <1>  %define spcmp ax
    10                              <1>  %else
    11                              <1>  %define spcmp eax
    12                              <1>  %endif
    13 00001363 89E0                <1>  mov spcmp, %1
    14                              <1> 
    15                              <1> %%rel16:
    16 00001365 F8                  <1>  clc
    17 00001366 E80600              <1>  o16 call word %%nearfn16
    18 00001369 0F835A02            <1>  jnc error
    19 0000136D EB11                <1>  jmp %%rel32
    20                              <1> %%nearfn16:
    21 0000136F 83E802              <1>  sub spcmp, 2
    22 00001372 39C4                <1>  cmp %1, spcmp
    23 00001374 0F854F02            <1>  jne error
    24 00001378 83C002              <1>  add spcmp, 2
    25 0000137B F9                  <1>  stc
    26 0000137C C3                  <1>  o16 ret
    27 0000137D E94702              <1>  jmp error
    28                              <1> 
    29                              <1> %%rel32:
    30 00001380 F8                  <1>  clc
    31 00001381 66E806000000        <1>  o32 call dword %%nearfn32
    32 00001387 0F833C02            <1>  jnc error
    33 0000138B EB12                <1>  jmp %%rm16
    34                              <1> %%nearfn32:
    35 0000138D 83E804              <1>  sub spcmp, 4
    36 00001390 39C4                <1>  cmp %1, spcmp
    37 00001392 0F853102            <1>  jne error
    38 00001396 83C004              <1>  add spcmp, 4
    39 00001399 F9                  <1>  stc
    40 0000139A 66C3                <1>  o32 ret
    41 0000139C E92802              <1>  jmp error
    42                              <1> 
    43                              <1> %%rm16:
    44 0000139F F8                  <1>  clc
    45 000013A0 BB[6F13]            <1>  mov bx, %%nearfn16
    46 000013A3 FFD3                <1>  o16 call bx
    47 000013A5 0F831E02            <1>  jnc error
    48                              <1> %%rm32:
    49 000013A9 F8                  <1>  clc
    50 000013AA 66BB[8D130000]      <1>  mov ebx, %%nearfn32
    51 000013B0 66FFD3              <1>  o32 call ebx
    52 000013B3 0F831002            <1>  jnc error
   214                                  	testCallFar C_SEG_REAL
    62 000013B7 89E0                <1>  mov ax, sp
    63                              <1> 
    64 000013B9 F8                  <1>  clc
    65 000013BA 9A[C513]00F0        <1>  o16 call word %1:%%farfn16
    66 000013BF 0F830402            <1>  jnc error
    67 000013C3 EB11                <1>  jmp %%o32
    68                              <1> %%farfn16:
    69 000013C5 83E804              <1>  sub ax, 4
    70 000013C8 39C4                <1>  cmp sp, ax
    71 000013CA 0F85F901            <1>  jne error
    72 000013CE 83C004              <1>  add ax, 4
    73 000013D1 F9                  <1>  stc
    74 000013D2 CB                  <1>  o16 retf
    75 000013D3 E9F101              <1>  jmp error
    76                              <1> 
    77                              <1> %%o32:
    78 000013D6 F8                  <1>  clc
    79 000013D7 669A[E5130000]00F0  <1>  o32 call dword %1:%%farfn32
    80 000013DF 0F83E401            <1>  jnc error
    81 000013E3 EB12                <1>  jmp %%m1616
    82                              <1> %%farfn32:
    83 000013E5 83E808              <1>  sub ax, 8
    84 000013E8 39C4                <1>  cmp sp, ax
    85 000013EA 0F85D901            <1>  jne error
    86 000013EE 83C008              <1>  add ax, 8
    87 000013F1 F9                  <1>  stc
    88 000013F2 66CB                <1>  o32 retf
    89 000013F4 E9D001              <1>  jmp error
    90                              <1> 
    91                              <1> %%m1616:
    92 000013F7 F8                  <1>  clc
    93 000013F8 C704[C513]          <1>  mov [si], word %%farfn16
    94 000013FC C7440200F0          <1>  mov [si+2], word %1
    95 00001401 FF1C                <1>  o16 call far [si]
    96 00001403 0F83C001            <1>  jnc error
    97                              <1> %%m1632:
    98 00001407 F8                  <1>  clc
    99 00001408 66C704[E5130000]    <1>  mov [si], dword %%farfn32
   100 0000140F C7440400F0          <1>  mov [si+4], word %1
   101 00001414 66FF1C              <1>  o32 call far [si]
   102 00001417 0F83AC01            <1>  jnc error
   103                              <1> %%exit:
   215                                  
   216                                  	advTestSegReal
     8                              <1>  advTestBase
    86                              <2>  %assign TEST_BASE1 TEST_BASE1+0x1000
    87                              <2>  %assign TEST_BASE2 TEST_BASE2+0x1000
     9                              <1>  %assign D1_SEG_REAL TEST_BASE1 >> 4
    10                              <1>  %assign D2_SEG_REAL TEST_BASE2 >> 4
    11 0000141B BA0023              <1>  mov dx, D1_SEG_REAL
    12 0000141E 8EDA                <1>  mov ds, dx
    13 00001420 BA0063              <1>  mov dx, D2_SEG_REAL
    14 00001423 8EC2                <1>  mov es, dx
   217                                  
   218                                  
   219                                  %include "tests/load_ptr_m.asm"
     1                              <1> ;
     2                              <1> ;   Tests LSS,LDS,LES,LFS,LGS in 16 and 32 bit mode
     3                              <1> ;   %1 segment register name, one of ss,ds,es,fs,gs
     4                              <1> ;   [ed:di] memory address to use for the pointer
     5                              <1> ;   Uses: nothing
     6                              <1> ;
     7                              <1> 
     8                              <1> %macro testLoadPtr 1
     9                              <1> 	mov cx, %1
    10                              <1> 	mov dx, es
    11                              <1> 
    12                              <1> 	mov [es:di], word 0x1234
    13                              <1> 	mov [es:di + 2], word 0xabcd
    14                              <1> 	l%1 bx, [es:di]
    15                              <1> 	mov ax, %1
    16                              <1> 	cmp ax, 0xabcd
    17                              <1> 	jne error
    18                              <1> 	cmp bx, 0x1234
    19                              <1> 	jne error
    20                              <1> 
    21                              <1> 	mov es, dx
    22                              <1> 
    23                              <1> 	mov [es:di], dword 0x12345678
    24                              <1> 	mov [es:di + 4], word 0xbcde
    25                              <1> 	l%1 ebx, [es:di]
    26                              <1> 	mov ax, %1
    27                              <1> 	cmp ax, 0xbcde
    28                              <1> 	jne error
    29                              <1> 	cmp ebx, 0x12345678
    30                              <1> 	jne error
    31                              <1> 
    32                              <1> 	mov es, dx
    33                              <1> 	mov %1, cx
    34                              <1> %endmacro
   220                                  ;-------------------------------------------------------------------------------
   221                                  	POST 6
     5 00001425 B006                <1>  mov al, 0x%1
     6 00001427 BA9909              <1>  mov dx, POST_PORT
     7 0000142A EE                  <1>  out dx, al
   222                                  ;-------------------------------------------------------------------------------
   223                                  ;
   224                                  ;   Load full pointer in real mode
   225                                  ;
   226 0000142B BF0000                  	mov    di, 0
   227                                  	testLoadPtr ss
     9 0000142E 8CD1                <1>  mov cx, %1
    10 00001430 8CC2                <1>  mov dx, es
    11                              <1> 
    12 00001432 26C7053412          <1>  mov [es:di], word 0x1234
    13 00001437 26C74502CDAB        <1>  mov [es:di + 2], word 0xabcd
    14 0000143D 260FB21D            <1>  l%1 bx, [es:di]
    15 00001441 8CD0                <1>  mov ax, %1
    16 00001443 3DCDAB              <1>  cmp ax, 0xabcd
    17 00001446 0F857D01            <1>  jne error
    18 0000144A 81FB3412            <1>  cmp bx, 0x1234
    19 0000144E 0F857501            <1>  jne error
    20                              <1> 
    21 00001452 8EC2                <1>  mov es, dx
    22                              <1> 
    23 00001454 2666C70578563412    <1>  mov [es:di], dword 0x12345678
    24 0000145C 26C74504DEBC        <1>  mov [es:di + 4], word 0xbcde
    25 00001462 26660FB21D          <1>  l%1 ebx, [es:di]
    26 00001467 8CD0                <1>  mov ax, %1
    27 00001469 3DDEBC              <1>  cmp ax, 0xbcde
    28 0000146C 0F855701            <1>  jne error
    29 00001470 6681FB78563412      <1>  cmp ebx, 0x12345678
    30 00001477 0F854C01            <1>  jne error
    31                              <1> 
    32 0000147B 8EC2                <1>  mov es, dx
    33 0000147D 8ED1                <1>  mov %1, cx
   228                                  	testLoadPtr ds
     9 0000147F 8CD9                <1>  mov cx, %1
    10 00001481 8CC2                <1>  mov dx, es
    11                              <1> 
    12 00001483 26C7053412          <1>  mov [es:di], word 0x1234
    13 00001488 26C74502CDAB        <1>  mov [es:di + 2], word 0xabcd
    14 0000148E 26C51D              <1>  l%1 bx, [es:di]
    15 00001491 8CD8                <1>  mov ax, %1
    16 00001493 3DCDAB              <1>  cmp ax, 0xabcd
    17 00001496 0F852D01            <1>  jne error
    18 0000149A 81FB3412            <1>  cmp bx, 0x1234
    19 0000149E 0F852501            <1>  jne error
    20                              <1> 
    21 000014A2 8EC2                <1>  mov es, dx
    22                              <1> 
    23 000014A4 2666C70578563412    <1>  mov [es:di], dword 0x12345678
    24 000014AC 26C74504DEBC        <1>  mov [es:di + 4], word 0xbcde
    25 000014B2 2666C51D            <1>  l%1 ebx, [es:di]
    26 000014B6 8CD8                <1>  mov ax, %1
    27 000014B8 3DDEBC              <1>  cmp ax, 0xbcde
    28 000014BB 0F850801            <1>  jne error
    29 000014BF 6681FB78563412      <1>  cmp ebx, 0x12345678
    30 000014C6 0F85FD00            <1>  jne error
    31                              <1> 
    32 000014CA 8EC2                <1>  mov es, dx
    33 000014CC 8ED9                <1>  mov %1, cx
   229                                  	testLoadPtr es
     9 000014CE 8CC1                <1>  mov cx, %1
    10 000014D0 8CC2                <1>  mov dx, es
    11                              <1> 
    12 000014D2 26C7053412          <1>  mov [es:di], word 0x1234
    13 000014D7 26C74502CDAB        <1>  mov [es:di + 2], word 0xabcd
    14 000014DD 26C41D              <1>  l%1 bx, [es:di]
    15 000014E0 8CC0                <1>  mov ax, %1
    16 000014E2 3DCDAB              <1>  cmp ax, 0xabcd
    17 000014E5 0F85DE00            <1>  jne error
    18 000014E9 81FB3412            <1>  cmp bx, 0x1234
    19 000014ED 0F85D600            <1>  jne error
    20                              <1> 
    21 000014F1 8EC2                <1>  mov es, dx
    22                              <1> 
    23 000014F3 2666C70578563412    <1>  mov [es:di], dword 0x12345678
    24 000014FB 26C74504DEBC        <1>  mov [es:di + 4], word 0xbcde
    25 00001501 2666C41D            <1>  l%1 ebx, [es:di]
    26 00001505 8CC0                <1>  mov ax, %1
    27 00001507 3DDEBC              <1>  cmp ax, 0xbcde
    28 0000150A 0F85B900            <1>  jne error
    29 0000150E 6681FB78563412      <1>  cmp ebx, 0x12345678
    30 00001515 0F85AE00            <1>  jne error
    31                              <1> 
    32 00001519 8EC2                <1>  mov es, dx
    33 0000151B 8EC1                <1>  mov %1, cx
   230                                  	testLoadPtr fs
     9 0000151D 8CE1                <1>  mov cx, %1
    10 0000151F 8CC2                <1>  mov dx, es
    11                              <1> 
    12 00001521 26C7053412          <1>  mov [es:di], word 0x1234
    13 00001526 26C74502CDAB        <1>  mov [es:di + 2], word 0xabcd
    14 0000152C 260FB41D            <1>  l%1 bx, [es:di]
    15 00001530 8CE0                <1>  mov ax, %1
    16 00001532 3DCDAB              <1>  cmp ax, 0xabcd
    17 00001535 0F858E00            <1>  jne error
    18 00001539 81FB3412            <1>  cmp bx, 0x1234
    19 0000153D 0F858600            <1>  jne error
    20                              <1> 
    21 00001541 8EC2                <1>  mov es, dx
    22                              <1> 
    23 00001543 2666C70578563412    <1>  mov [es:di], dword 0x12345678
    24 0000154B 26C74504DEBC        <1>  mov [es:di + 4], word 0xbcde
    25 00001551 26660FB41D          <1>  l%1 ebx, [es:di]
    26 00001556 8CE0                <1>  mov ax, %1
    27 00001558 3DDEBC              <1>  cmp ax, 0xbcde
    28 0000155B 756A                <1>  jne error
    29 0000155D 6681FB78563412      <1>  cmp ebx, 0x12345678
    30 00001564 7561                <1>  jne error
    31                              <1> 
    32 00001566 8EC2                <1>  mov es, dx
    33 00001568 8EE1                <1>  mov %1, cx
   231                                  	testLoadPtr gs
     9 0000156A 8CE9                <1>  mov cx, %1
    10 0000156C 8CC2                <1>  mov dx, es
    11                              <1> 
    12 0000156E 26C7053412          <1>  mov [es:di], word 0x1234
    13 00001573 26C74502CDAB        <1>  mov [es:di + 2], word 0xabcd
    14 00001579 260FB51D            <1>  l%1 bx, [es:di]
    15 0000157D 8CE8                <1>  mov ax, %1
    16 0000157F 3DCDAB              <1>  cmp ax, 0xabcd
    17 00001582 7543                <1>  jne error
    18 00001584 81FB3412            <1>  cmp bx, 0x1234
    19 00001588 753D                <1>  jne error
    20                              <1> 
    21 0000158A 8EC2                <1>  mov es, dx
    22                              <1> 
    23 0000158C 2666C70578563412    <1>  mov [es:di], dword 0x12345678
    24 00001594 26C74504DEBC        <1>  mov [es:di + 4], word 0xbcde
    25 0000159A 26660FB51D          <1>  l%1 ebx, [es:di]
    26 0000159F 8CE8                <1>  mov ax, %1
    27 000015A1 3DDEBC              <1>  cmp ax, 0xbcde
    28 000015A4 7521                <1>  jne error
    29 000015A6 6681FB78563412      <1>  cmp ebx, 0x12345678
    30 000015AD 7518                <1>  jne error
    31                              <1> 
    32 000015AF 8EC2                <1>  mov es, dx
    33 000015B1 8EE9                <1>  mov %1, cx
   232                                  
   233                                  	advTestSegReal
     8                              <1>  advTestBase
    86                              <2>  %assign TEST_BASE1 TEST_BASE1+0x1000
    87                              <2>  %assign TEST_BASE2 TEST_BASE2+0x1000
     9                              <1>  %assign D1_SEG_REAL TEST_BASE1 >> 4
    10                              <1>  %assign D2_SEG_REAL TEST_BASE2 >> 4
    11 000015B3 BA0024              <1>  mov dx, D1_SEG_REAL
    12 000015B6 8EDA                <1>  mov ds, dx
    13 000015B8 BA0064              <1>  mov dx, D2_SEG_REAL
    14 000015BB 8EC2                <1>  mov es, dx
   234                                  
   235                                  %if TEST_PMODE
   236                                  
   237                                  ; ==============================================================================
   238                                  ;	Protected mode tests
   239                                  ; ==============================================================================
   240                                  
   241                                  ;-------------------------------------------------------------------------------
   242                                  	POST 8
   243                                  ;-------------------------------------------------------------------------------
   244                                  ;
   245                                  ;   GDT, LDT, PDT, and PT setup, enter protected mode
   246                                  ;
   247                                  	jmp initGDT
   248                                  
   249                                  ESP_R0_PROT equ 0x0000FFFF
   250                                  ESP_R3_PROT equ 0x00007FFF
   251                                  
   252                                  
   253                                  %include "protected_m.asm"
   254                                  
   255                                  
   256                                  ;;; support for ROM based GDT (currently unused)
   257                                  romGDT:
   258                                  romGDTEnd:
   259                                  romGDTaddr:
   260                                  	dw romGDTEnd - romGDT - 1 ; 16-bit limit
   261                                  	dw romGDT, 0x000f         ; 32-bit base address
   262                                  ;;;
   263                                  
   264                                  ptrGDTreal: ; pointer to the pmode GDT for real mode code
   265                                  	dd 0             ; 32-bit offset
   266                                  	dw GDT_SEG_REAL  ; 16-bit segment selector
   267                                  ptrIDTreal: ; pointer to the pmode IDT for real mode code
   268                                  	dd 0
   269                                  	dw IDT_SEG_REAL
   270                                  
   271                                  initGDT:
   272                                  	; the first descriptor in the GDT is always a dud (the null selector)
   273                                  	defGDTDesc NULL
   274                                  	defGDTDesc C_SEG_PROT16,  0x000f0000,0x0000ffff,ACC_TYPE_CODE_R|ACC_PRESENT
   275                                  	defGDTDesc C_SEG_PROT32,  0x000f0000,0x0000ffff,ACC_TYPE_CODE_R|ACC_PRESENT,EXT_32BIT
   276                                  	defGDTDesc CU_SEG_PROT32, 0x000f0000,0x0000ffff,ACC_TYPE_CODE_R|ACC_PRESENT|ACC_DPL_3,EXT_32BIT
   277                                  	defGDTDesc CC_SEG_PROT32, 0x000f0000,0x0000ffff,ACC_TYPE_CODE_R|ACC_TYPE_CONFORMING|ACC_PRESENT|EXT_32BIT
   278                                  	defGDTDesc IDT_SEG_PROT,  0x00000400,0x000000ff,ACC_TYPE_DATA_W|ACC_PRESENT
   279                                  	defGDTDesc IDTU_SEG_PROT, 0x00000400,0x000000ff,ACC_TYPE_DATA_W|ACC_PRESENT|ACC_DPL_3
   280                                  	defGDTDesc GDT_DSEG_PROT, 0x00000500,0x000002ff,ACC_TYPE_DATA_W|ACC_PRESENT
   281                                  	defGDTDesc GDTU_DSEG_PROT,0x00000500,0x000002ff,ACC_TYPE_DATA_W|ACC_PRESENT|ACC_DPL_3
   282                                  	defGDTDesc LDT_SEG_PROT,  0x00000800,0x000007ff,ACC_TYPE_LDT|ACC_PRESENT
   283                                  	defGDTDesc LDT_DSEG_PROT, 0x00000800,0x000007ff,ACC_TYPE_DATA_W|ACC_PRESENT
   284                                  	defGDTDesc PG_SEG_PROT,   0x00001000,0x00002fff,ACC_TYPE_DATA_W|ACC_PRESENT
   285                                  	defGDTDesc S_SEG_PROT32,  0x00010000,0x0008ffff,ACC_TYPE_DATA_W|ACC_PRESENT,EXT_32BIT
   286                                  	defGDTDesc SU_SEG_PROT32, 0x00010000,0x0008ffff,ACC_TYPE_DATA_W|ACC_PRESENT|ACC_DPL_3,EXT_32BIT
   287                                  	defGDTDesc TSS_PROT,      0x00004000,0x00000fff,ACC_TYPE_TSS|ACC_PRESENT|ACC_DPL_3
   288                                  	defGDTDesc TSS_DSEG_PROT, 0x00004000,0x00000fff,ACC_TYPE_DATA_W|ACC_PRESENT
   289                                  	defGDTDesc FLAT_SEG_PROT, 0x00000000,0xffffffff,ACC_TYPE_DATA_W|ACC_PRESENT
   290                                  	defGDTDesc RING0_GATE ; placeholder for a call gate used to switch to ring 0
   291                                  
   292                                  	jmp initIDT
   293                                  
   294                                  ptrIDTprot: ; pointer to the IDT for pmode
   295                                  	dd 0             ; 32-bit offset
   296                                  	dw IDT_SEG_PROT  ; 16-bit segment selector
   297                                  ptrIDTUprot: ; pointer to the IDT for pmode
   298                                  	dd 0             ; 32-bit offset
   299                                  	dw IDTU_SEG_PROT  ; 16-bit segment selector
   300                                  ptrGDTprot: ; pointer to the GDT for pmode (kernel mode data segment)
   301                                  	dd 0
   302                                  	dw GDT_DSEG_PROT
   303                                  ptrGDTUprot: ; pointer to the GDT for pmode (user mode data segment)
   304                                  	dd 0
   305                                  	dw GDTU_DSEG_PROT
   306                                  ptrLDTprot: ; pointer to the LDT for pmode
   307                                  	dd 0
   308                                  	dw LDT_DSEG_PROT
   309                                  ptrPDprot: ; pointer to the Page Directory for pmode
   310                                  	dd 0
   311                                  	dw PG_SEG_PROT
   312                                  ptrPT0prot: ; pointer to Page Table 0
   313                                  	dd 0x1000
   314                                  	dw PG_SEG_PROT
   315                                  ptrPT1prot: ; pointer to Page Table 1
   316                                  	dd 0x2000
   317                                  	dw PG_SEG_PROT
   318                                  ptrSSprot: ; pointer to the stack for pmode
   319                                  	dd ESP_R0_PROT
   320                                  	dw S_SEG_PROT32
   321                                  ptrTSSprot: ; pointer to the task state segment
   322                                  	dd 0
   323                                  	dw TSS_DSEG_PROT
   324                                  addrProtIDT: ; address of pmode IDT to be used with lidt
   325                                  	dw 0xFF              ; 16-bit limit
   326                                  	dd IDT_SEG_REAL << 4 ; 32-bit base address
   327                                  addrGDT: ; address of GDT to be used with lgdt
   328                                  	dw GDT_SEG_LIMIT
   329                                  	dd GDT_SEG_REAL << 4
   330                                  
   331                                  ; Initializes an interrupt gate in system memory in real mode
   332                                  initIntGateReal:
   333                                  	pushad
   334                                  	initIntGate
   335                                  	popad
   336                                  	ret
   337                                  
   338                                  initIDT:
   339                                  	lds    ebx, [cs:ptrIDTreal]
   340                                  	mov    esi, C_SEG_PROT32
   341                                  	mov    edi, DefaultExcHandler
   342                                  	mov    dx,  ACC_DPL_0
   343                                  %assign vector 0
   344                                  %rep    0x15
   345                                  	mov    eax, vector
   346                                  	call   initIntGateReal
   347                                  %assign vector vector+1
   348                                  %endrep
   349                                  
   350                                  	jmp initPaging
   351                                  
   352                                  initPaging:
   353                                  ;
   354                                  ; pages:
   355                                  ;  00000-00FFF   1  1000h   4K IDTs, GDT and LDT
   356                                  ;  01000-01FFF   1  1000h   4K page directory
   357                                  ;  02000-02FFF   1  1000h   4K page table 0
   358                                  ;  03000-03FFF   1  1000h   4K page table 1
   359                                  ;  04000-04FFF   1  1000h   4K task switch segments
   360                                  ;  05000-0FFFF  11  c000h  44K free
   361                                  ;  10000-1FFFF  16 10000h  64K stack
   362                                  ;  20000-9EFFF 127 7f000h 508K tests
   363                                  ;  9F000-9FFFF   1  1000h   4K used for page faults (PTE 9Fh)
   364                                  ;
   365                                  PAGE_DIR_ADDR equ 0x1000
   366                                  PAGE_TBL0_ADDR equ PAGE_DIR_ADDR+0x1000
   367                                  PAGE_TBL1_ADDR equ PAGE_DIR_ADDR+0x2000
   368                                  
   369                                  ;   Now we want to build a page directory and a page table. We need two pages of
   370                                  ;   4K-aligned physical memory.  We use a hard-coded address, segment 0x100,
   371                                  ;   corresponding to physical address 0x1000.
   372                                  ;
   373                                  	mov   esi, PAGE_DIR_ADDR
   374                                  	mov   eax, esi
   375                                  	shr   eax, 4
   376                                  	mov   es,  eax
   377                                  ;
   378                                  ;   Build a page directory at ES:EDI (0100:0000) with only 1 valid PDE (the first one),
   379                                  ;   because we're not going to access any memory outside the first 1MB.
   380                                  ;
   381                                  	cld
   382                                  	mov   eax, PAGE_TBL0_ADDR | PTE_PRESENT | PTE_USER | PTE_WRITE
   383                                  	xor   edi, edi
   384                                  	stosd
   385                                  	mov   ecx, 1024-1 ; ECX == number of (remaining) PDEs to write
   386                                  	xor   eax, eax    ; fill remaining PDEs with 0
   387                                  	rep   stosd
   388                                  ;
   389                                  ;   Build a page table at EDI with 256 (out of 1024) valid PTEs, mapping the first 1MB
   390                                  ;   as linear == physical.
   391                                  ;
   392                                  	mov   eax, PTE_PRESENT | PTE_WRITE | PTE_USER
   393                                  	mov   ecx, 256 ; ECX == number of PTEs to write
   394                                  .initPT:
   395                                  	stosd
   396                                  	add   eax, 0x1000
   397                                  	loop  .initPT
   398                                  	mov   ecx, 1024-256 ; ECX == number of (remaining) PTEs to write
   399                                  	xor   eax, eax
   400                                  	rep   stosd
   401                                  
   402                                  switchToProtMode:
   403                                  	cli ; make sure interrupts are off now, since we've not initialized the IDT yet
   404                                  	o32 lidt [cs:addrProtIDT]
   405                                  	o32 lgdt [cs:addrGDT]
   406                                  	mov    cr3, esi
   407                                  	mov    eax, cr0
   408                                  	or     eax, CR0_MSW_PE | CR0_PG
   409                                  	mov    cr0, eax
   410                                  	jmp    C_SEG_PROT32:toProt32 ; jump to flush the prefetch queue
   411                                  toProt32:
   412                                  	bits 32
   413                                  	jmp    initLDT
   414                                  
   415                                  %include "protected_p.asm"
   416                                  
   417                                  initLDT:
   418                                  	defLDTDesc D_SEG_PROT16,   TEST_BASE, 0x000fffff,ACC_TYPE_DATA_W|ACC_PRESENT
   419                                  	defLDTDesc D_SEG_PROT32,   TEST_BASE, 0x000fffff,ACC_TYPE_DATA_W|ACC_PRESENT,EXT_32BIT
   420                                  	defLDTDesc DU_SEG_PROT,    TEST_BASE, 0x000fffff,ACC_TYPE_DATA_W|ACC_PRESENT|ACC_DPL_3
   421                                  	defLDTDesc D1_SEG_PROT,    TEST_BASE1,0x000fffff,ACC_TYPE_DATA_W|ACC_PRESENT
   422                                  	defLDTDesc D2_SEG_PROT,    TEST_BASE2,0x000fffff,ACC_TYPE_DATA_W|ACC_PRESENT
   423                                  	defLDTDesc DC_SEG_PROT32,  TEST_BASE1,0x000fffff,ACC_TYPE_CODE_R|ACC_PRESENT,EXT_32BIT
   424                                  	defLDTDesc RO_SEG_PROT,    TEST_BASE, 0x000fffff,ACC_TYPE_DATA_R|ACC_PRESENT
   425                                  	defLDTDesc ROU_SEG_PROT,   TEST_BASE, 0x000fffff,ACC_TYPE_DATA_R|ACC_PRESENT|ACC_DPL_3
   426                                  	defLDTDesc DTEST_SEG_PROT, TEST_BASE, 0x000fffff,ACC_TYPE_DATA_W|ACC_PRESENT,EXT_32BIT
   427                                  	defLDTDesc DPL1_SEG_PROT,  TEST_BASE, 0x000fffff,ACC_TYPE_DATA_W|ACC_PRESENT|ACC_DPL_1
   428                                  	defLDTDesc NP_SEG_PROT,    TEST_BASE, 0x000fffff,ACC_TYPE_DATA_W
   429                                  	defLDTDesc SYS_SEG_PROT,   TEST_BASE, 0x000fffff,ACC_PRESENT
   430                                  
   431                                  	mov  ax, LDT_SEG_PROT
   432                                  	lldt ax
   433                                  	mov  ax, TSS_PROT
   434                                  	ltr  ax
   435                                  	jmp  protTests
   436                                  
   437                                  %include "tss_p.asm"
   438                                  %include "protected_rings_p.asm"
   439                                  
   440                                  protTests:
   441                                  
   442                                  %include "tests/stack_m.asm"
   443                                  
   444                                  ;-------------------------------------------------------------------------------
   445                                  	POST 9
   446                                  ;-------------------------------------------------------------------------------
   447                                  ;
   448                                  ;   Stack functionality
   449                                  ;
   450                                  ;
   451                                  ;   For the next tests, with a 16-bit data segment in SS, we
   452                                  ;   expect all pushes/pops will occur at SP rather than ESP.
   453                                  ;
   454                                  	mov    ax, D_SEG_PROT16
   455                                  	mov    ds, ax
   456                                  	mov    ss, ax
   457                                  	mov    es, ax
   458                                  	mov    fs, ax
   459                                  	mov    gs, ax
   460                                  
   461                                  	;
   462                                  	; general purpose registers
   463                                  	;
   464                                  	testPushPopR ax,16
   465                                  	testPushPopR bx,16
   466                                  	testPushPopR cx,16
   467                                  	testPushPopR dx,16
   468                                  	testPushPopR sp,16
   469                                  	testPushPopR bp,16
   470                                  	testPushPopR si,16
   471                                  	testPushPopR di,16
   472                                  
   473                                  	testPushPopAll16 16
   474                                  	testPushPopAll32 16
   475                                  
   476                                  	;
   477                                  	; segment registers
   478                                  	;
   479                                  	testPushPopSR cs,16
   480                                  	testPushPopSR ds,16
   481                                  	testPushPopSR ss,16
   482                                  	testPushPopSR es,16
   483                                  	testPushPopSR fs,16
   484                                  	testPushPopSR gs,16
   485                                  
   486                                  	;
   487                                  	; memory
   488                                  	;
   489                                  	testPushPopM 16
   490                                  	testPushImm 16
   491                                  
   492                                  	;
   493                                  	; flags
   494                                  	;
   495                                  	testPushPopF 16
   496                                  
   497                                  ;
   498                                  ;   Now use a 32-bit stack address size.
   499                                  ;   All pushes/pops will occur at ESP rather than SP.
   500                                  ;
   501                                  	mov    ax,  D_SEG_PROT32
   502                                  	mov    ss,  ax
   503                                  
   504                                  	testPushPopR ax,32
   505                                  	testPushPopR bx,32
   506                                  	testPushPopR cx,32
   507                                  	testPushPopR dx,32
   508                                  	testPushPopR bp,32
   509                                  	testPushPopR sp,32
   510                                  	testPushPopR si,32
   511                                  	testPushPopR di,32
   512                                  
   513                                  	testPushPopAll16 32
   514                                  	testPushPopAll32 32
   515                                  
   516                                  	testPushPopSR cs,32
   517                                  	testPushPopSR ds,32
   518                                  	testPushPopSR ss,32
   519                                  	testPushPopSR es,32
   520                                  	testPushPopSR fs,32
   521                                  	testPushPopSR gs,32
   522                                  
   523                                  	testPushPopM 32
   524                                  	testPushImm 32
   525                                  
   526                                  	testPushPopF 32
   527                                  
   528                                  
   529                                  	; the stack works
   530                                  	; initialize it for the next tests
   531                                  	loadProtModeStack
   532                                  
   533                                  	advTestSegProt
   534                                  
   535                                  
   536                                  ;-------------------------------------------------------------------------------
   537                                  	POST A
   538                                  ;-------------------------------------------------------------------------------
   539                                  ;
   540                                  ;   Test user mode (ring 3) switching
   541                                  ;
   542                                  	call   clearTSS
   543                                  	mov    ax, D_SEG_PROT32
   544                                  	mov    ds, ax
   545                                  	mov    es, ax
   546                                  	mov    fs, ax
   547                                  	mov    gs, ax
   548                                  	call   switchToRing3
   549                                  	; CS must be CU_SEG_PROT32|3 (CPL=3)
   550                                  	mov    ax, cs
   551                                  	cmp    ax, CU_SEG_PROT32|3
   552                                  	jne    error
   553                                  	; data segments must be NULL
   554                                  	mov    ax, ds
   555                                  	cmp    ax, 0
   556                                  	jne    error
   557                                  	mov    ax, es
   558                                  	cmp    ax, 0
   559                                  	jne    error
   560                                  	mov    ax, fs
   561                                  	cmp    ax, 0
   562                                  	jne    error
   563                                  	mov    ax, gs
   564                                  	cmp    ax, 0
   565                                  	jne    error
   566                                  	; test some privileged ops
   567                                  	protModeFaultTest EX_GP, 0, cli
   568                                  	protModeFaultTest EX_GP, 0, hlt
   569                                  	; switch back to ring 0
   570                                  	call switchToRing0
   571                                  	; CS must be C_SEG_PROT32|0 (CPL=0)
   572                                  	mov    ax, cs
   573                                  	cmp    ax, C_SEG_PROT32
   574                                  	jne    error
   575                                  
   576                                  
   577                                  ;-------------------------------------------------------------------------------
   578                                  	POST B
   579                                  ;-------------------------------------------------------------------------------
   580                                  ;
   581                                  ;   Test of moving segment registers in protected mode
   582                                  ;
   583                                  	testMovSegR_prot ds
   584                                  	testMovSegR_prot es
   585                                  	testMovSegR_prot fs
   586                                  	testMovSegR_prot gs
   587                                  	testMovSegR_prot cs
   588                                  	testMovSegR_prot ss
   589                                  
   590                                  	loadProtModeStack
   591                                  	advTestSegProt
   592                                  
   593                                  
   594                                  ;-------------------------------------------------------------------------------
   595                                  	POST C
   596                                  ;-------------------------------------------------------------------------------
   597                                  ;
   598                                  ;   Zero and sign-extension tests
   599                                  ;
   600                                  	movsx  eax, byte [cs:signedByte] ; byte to a 32-bit register with sign-extension
   601                                  	cmp    eax, 0xffffff80
   602                                  	jne    error
   603                                  
   604                                  	movsx  eax, word [cs:signedWord] ; word to a 32-bit register with sign-extension
   605                                  	cmp    eax, 0xffff8080
   606                                  	jne    error
   607                                  
   608                                  	movzx  eax, byte [cs:signedByte] ; byte to a 32-bit register with zero-extension
   609                                  	cmp    eax, 0x00000080
   610                                  	jne    error
   611                                  
   612                                  	movzx  eax, word [cs:signedWord] ; word to a 32-bit register with zero-extension
   613                                  	cmp    eax, 0x00008080
   614                                  	jne    error
   615                                  
   616                                  	push   byte -128       ; NASM will not use opcode 0x6A ("PUSH imm8") unless we specify "byte"
   617                                  	pop    ebx             ; verify EBX == 0xFFFFFF80
   618                                  	cmp    ebx, 0xFFFFFF80
   619                                  	jne    error
   620                                  
   621                                  	and    ebx, 0xff       ; verify EBX == 0x00000080
   622                                  	cmp    ebx, 0x00000080
   623                                  	jne    error
   624                                  
   625                                  	movsx  bx, bl          ; verify EBX == 0x0000FF80
   626                                  	cmp    ebx, 0x0000FF80
   627                                  	jne    error
   628                                  
   629                                  	movsx  ebx, bx         ; verify EBX == 0xFFFFFF80
   630                                  	cmp    ebx, 0xFFFFFF80
   631                                  	jne    error
   632                                  
   633                                  	movzx  bx,  bl         ; verify EBX == 0xFFFF0080
   634                                  	cmp    ebx, 0xFFFF0080
   635                                  	jne    error
   636                                  
   637                                  	movzx  ebx, bl         ; verify EBX == 0x00000080
   638                                  	cmp    ebx, 0x00000080
   639                                  	jne    error
   640                                  
   641                                  	not    ebx             ; verify EBX == 0xFFFFFF7F
   642                                  	cmp    ebx,0xFFFFFF7F
   643                                  	jne    error
   644                                  
   645                                  	movsx  bx, bl          ; verify EBX == 0xFFFF007F
   646                                  	cmp    ebx, 0xFFFF007F
   647                                  	jne    error
   648                                  
   649                                  	movsx  ebx, bl         ; verify EBX == 0x0000007F
   650                                  	cmp    ebx, 0x0000007F
   651                                  	jne    error
   652                                  
   653                                  	not    ebx             ; verify EBX == 0xFFFFFF80
   654                                  	cmp    ebx, 0xFFFFFF80
   655                                  	jne    error
   656                                  
   657                                  	movzx  ebx, bx         ; verify EBX == 0x0000FF80
   658                                  	cmp    ebx, 0x0000FF80
   659                                  	jne    error
   660                                  
   661                                  	movzx  bx, bl          ; verify EBX == 0x00000080
   662                                  	cmp    ebx,0x00000080
   663                                  	jne    error
   664                                  
   665                                  	movsx  bx, bl
   666                                  	neg    bx
   667                                  	neg    bx
   668                                  	cmp    ebx, 0x0000FF80
   669                                  	jne    error
   670                                  
   671                                  	movsx  ebx, bx
   672                                  	neg    ebx
   673                                  	neg    ebx
   674                                  	cmp    ebx, 0xFFFFFF80
   675                                  	jne    error
   676                                  
   677                                  
   678                                  	jmp postD
   679                                  %include "tests/lea_m.asm"
   680                                  %include "tests/lea_p.asm"
   681                                  postD:
   682                                  ;-------------------------------------------------------------------------------
   683                                  	POST D
   684                                  ;-------------------------------------------------------------------------------
   685                                  ;
   686                                  ;   16-bit addressing modes (LEA)
   687                                  ;
   688                                  	mov ax, 0x0001
   689                                  	mov bx, 0x0002
   690                                  	mov cx, 0x0004
   691                                  	mov dx, 0x0008
   692                                  	mov si, 0x0010
   693                                  	mov di, 0x0020
   694                                  	testLEA16 [0x4000],0x4000
   695                                  	testLEA16 [bx], 0x0002
   696                                  	testLEA16 [si], 0x0010
   697                                  	testLEA16 [di], 0x0020
   698                                  	testLEA16 [bx + 0x40], 0x0042
   699                                  	testLEA16 [si + 0x40], 0x0050
   700                                  	testLEA16 [di + 0x40], 0x0060
   701                                  	testLEA16 [bx + 0x4000], 0x4002
   702                                  	testLEA16 [si + 0x4000], 0x4010
   703                                  	testLEA16 [bx + si], 0x0012
   704                                  	testLEA16 [bx + di], 0x0022
   705                                  	testLEA16 [bx + 0x40 + si], 0x0052
   706                                  	testLEA16 [bx + 0x40 + di], 0x0062
   707                                  	testLEA16 [bx + 0x4000 + si], 0x4012
   708                                  	testLEA16 [bx + 0x4000 + di], 0x4022
   709                                  
   710                                  
   711                                  ;-------------------------------------------------------------------------------
   712                                  	POST E
   713                                  ;-------------------------------------------------------------------------------
   714                                  ;
   715                                  ;   32-bit addressing modes (LEA)
   716                                  ;
   717                                  	call testAddressing32
   718                                  
   719                                  	advTestSegProt
   720                                  
   721                                  
   722                                  ;-------------------------------------------------------------------------------
   723                                  	POST F
   724                                  ;-------------------------------------------------------------------------------
   725                                  ;
   726                                  ;   Access memory using various addressing modes
   727                                  ;
   728                                  	; store a known word at the scratch address
   729                                  	mov    ebx, 0x11223344
   730                                  	mov    [0x10000], ebx
   731                                  
   732                                  	; now access that scratch address using various addressing modes
   733                                  	mov    ecx, 0x10000
   734                                  	cmp    [ecx], ebx
   735                                  	jne    error
   736                                  
   737                                  	add    ecx, 64
   738                                  	cmp    [ecx-64], ebx
   739                                  	jne    error
   740                                  
   741                                  	sub    ecx, 64
   742                                  	shr    ecx, 1
   743                                  	cmp    [ecx+0x8000], ebx
   744                                  	jne    error
   745                                  
   746                                  	cmp    [ecx+ecx], ebx
   747                                  	jne    error
   748                                  
   749                                  	shr    ecx, 1
   750                                  	cmp    [ecx+ecx*2+0x4000], ebx
   751                                  	jne    error
   752                                  
   753                                  	cmp    [ecx*4], ebx
   754                                  	jne    error
   755                                  
   756                                  	; test default segment SS
   757                                  	mov    ebp, ecx
   758                                  	cmp    [ebp+ecx*2+0x4000], ebx ; EBP is used as base so the default segment is SS
   759                                  	je     error ; since SS != DS, this better be a mismatch
   760                                  
   761                                  	mov    eax, esp ; save ESP
   762                                  	mov    esp, ecx
   763                                  	cmp    [esp+ecx*2+0x4000], ebx ; ESP is used as base so the default segment is SS
   764                                  	je     error ; since SS != DS, this better be a mismatch
   765                                  	mov    esp, eax ; restore ESP
   766                                  
   767                                  	mov    ax, D1_SEG_PROT
   768                                  	mov    dx, D2_SEG_PROT
   769                                  
   770                                  	; store the known word in a different segment
   771                                  	mov    ds, dx
   772                                  	mov    [0x10000], ebx
   773                                  	mov    ds, ax
   774                                  
   775                                  	; test segment overrides
   776                                  	mov    es, dx
   777                                  	cmp    [es:ecx+ecx*2+0x4000], ebx
   778                                  	jne    error
   779                                  	mov    es, ax
   780                                  	mov    fs, dx
   781                                  	cmp    [fs:ecx+ecx*2+0x4000], ebx
   782                                  	jne    error
   783                                  	mov    fs, ax
   784                                  	mov    gs, dx
   785                                  	cmp    [gs:ecx+ecx*2+0x4000], ebx
   786                                  	jne    error
   787                                  	mov    gs, ax
   788                                  	mov    ss, dx
   789                                  	cmp    [ss:ecx+ecx*2+0x4000], ebx
   790                                  	jne    error
   791                                  	mov    dx, S_SEG_PROT32
   792                                  	mov    ss, dx
   793                                  	cmp    [ds:ebp+ecx*2+0x4000], ebx
   794                                  	jne    error
   795                                  
   796                                  	advTestSegProt
   797                                  
   798                                  
   799                                  ;-------------------------------------------------------------------------------
   800                                  	POST 10
   801                                  ;-------------------------------------------------------------------------------
   802                                  ;
   803                                  ;   Store, move, scan, and compare string data in protected mode
   804                                  ;
   805                                  	pushad
   806                                  	pushfd
   807                                  	testStringOps b,0,a32
   808                                  	testStringOps w,0,a32
   809                                  	testStringOps d,0,a32
   810                                  	testStringOps b,1,a32
   811                                  	testStringOps w,1,a32
   812                                  	testStringOps d,1,a32
   813                                  	testStringReps b,0,a32
   814                                  	testStringReps w,0,a32
   815                                  	testStringReps d,0,a32
   816                                  	testStringReps b,1,a32
   817                                  	testStringReps w,1,a32
   818                                  	testStringReps d,1,a32
   819                                  	popfd
   820                                  	popad
   821                                  
   822                                  	advTestSegProt
   823                                  
   824                                  
   825                                  	jmp post11
   826                                  %include "tests/paging_m.asm"
   827                                  %include "tests/paging_p.asm"
   828                                  post11:
   829                                  ;-------------------------------------------------------------------------------
   830                                  	POST 11
   831                                  ;-------------------------------------------------------------------------------
   832                                  ;
   833                                  ;	Verify page faults and PTE bits
   834                                  ;
   835                                  	setProtModeIntGate EX_PF, PageFaultHandler
   836                                  	; set test data segment to DPL 3 R/W flat
   837                                  	updLDTDesc DTEST_SEG_PROT, 0x0000000, 0x000fffff, ACC_TYPE_DATA_W|ACC_PRESENT|ACC_DPL_3, EXT_PAGE
   838                                  	; setup page table 1
   839                                  	cld
   840                                  	les   ebx, [cs:ptrPDprot]
   841                                  	mov   [es:ebx + 4], dword PAGE_TBL1_ADDR ; PDE 1 -> page table 1
   842                                  	les   ebx, [cs:ptrPT1prot]
   843                                  	mov   edi, ebx
   844                                  	xor   eax, eax
   845                                  	mov   ecx, 1024
   846                                  	rep   stosd
   847                                  	mov   [es:ebx + (TESTPAGE_PTE&0x3FF)*4], dword TESTPAGE_OFF
   848                                  
   849                                  	mov   eax, pagingTestsEnd-pagingTests
   850                                  	mov   esi, pagingTests
   851                                  	mov   edx, 0
   852                                  	mov   ecx, 3
   853                                  	div   ecx
   854                                  	mov   ecx, eax
   855                                  .nextTest:
   856                                  	movzx eax, byte [cs:esi + 0]
   857                                  	movzx ebx, byte [cs:esi + 1]
   858                                  	movzx edx, byte [cs:esi + 2]
   859                                  	call  testPageFault
   860                                  	add   esi, 3
   861                                  	loop .nextTest
   862                                  
   863                                  	setProtModeIntGate EX_PF, DefaultExcHandler
   864                                  
   865                                  	; test if the Dirty bit is updated after a read
   866                                  	updPageFlags TESTPAGE_PDE, PTE_SUPER_W
   867                                  	updPageFlags TESTPAGE_PTE, PTE_SUPER_W
   868                                  	mov   ax, DTEST_SEG_PROT
   869                                  	mov   ds, ax
   870                                  	mov   eax, [TESTPAGE_LIN]
   871                                  	mov   [TESTPAGE_LIN], eax
   872                                  	mov   eax, TESTPAGE_LIN
   873                                  	call  getPTE
   874                                  	test  eax, PTE_DIRTY
   875                                  	jz    error
   876                                  
   877                                  	mov ax, D1_SEG_PROT
   878                                  	mov ds, ax
   879                                  
   880                                  
   881                                  ;-------------------------------------------------------------------------------
   882                                  	POST 12
   883                                  ;-------------------------------------------------------------------------------
   884                                  ;
   885                                  ;   Verify other memory access faults
   886                                  ;
   887                                  	; #GP(0) If the destination operand is in a non-writable segment.
   888                                  	mov ax, RO_SEG_PROT ; write protect DS
   889                                  	mov ds, ax
   890                                  	protModeFaultTest EX_GP, 0, mov [0],eax
   891                                  	; #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
   892                                  	; use byte granular DS
   893                                  	updLDTDesc DTEST_SEG_PROT, 0x0000000, 0x0009ffff, ACC_TYPE_DATA_W|ACC_PRESENT
   894                                  	mov ax, DTEST_SEG_PROT
   895                                  	mov ds, ax
   896                                  	protModeFaultTest EX_GP, 0, mov eax,[0x9fffd] ; check on read
   897                                  	protModeFaultTest EX_GP, 0, mov [0x9fffd],eax ; check on write
   898                                  	mov eax,[0x9fffc] ; this should be ok
   899                                  	mov [0x9fffc],eax ; this should be ok
   900                                  	protModeFaultTest EX_GP, 0, mov eax,[-1] ; check on read (test for overflows)
   901                                  	protModeFaultTest EX_GP, 0, mov [-1],eax ; check on write (test for overflows)
   902                                  	; use page granular DS
   903                                  	updLDTDesc DTEST_SEG_PROT, 0x0000000, 0x0000009f, ACC_TYPE_DATA_W|ACC_PRESENT, EXT_PAGE
   904                                  	mov ax, DTEST_SEG_PROT
   905                                  	mov ds, ax
   906                                  	protModeFaultTest EX_GP, 0, mov eax,[0x9fffd] ; check on read
   907                                  	protModeFaultTest EX_GP, 0, mov [0x9fffd],eax ; check on write
   908                                  	mov eax,[0x9fffc] ; this should be ok
   909                                  	mov [0x9fffc],eax ; this should be ok
   910                                  	; #SS(0) If a memory operand effective address is outside the SS segment limit.
   911                                  	protModeFaultTest EX_SS, 0, mov eax,[ss:-1] ; check on read
   912                                  	protModeFaultTest EX_SS, 0, mov [ss:-1],eax ; check on write
   913                                  	; #UD If the LOCK prefix is used.
   914                                  	protModeFaultTest EX_UD, 0, lock mov [0],eax
   915                                  
   916                                  	mov ax, D1_SEG_PROT
   917                                  	mov ds, ax
   918                                  
   919                                  
   920                                  %include "tests/bit_m.asm"
   921                                  ;-------------------------------------------------------------------------------
   922                                  	POST 13
   923                                  ;-------------------------------------------------------------------------------
   924                                  ;
   925                                  ;   Verify Bit Scan operations
   926                                  ;
   927                                  	testBitscan bsf
   928                                  	testBitscan bsr
   929                                  
   930                                  
   931                                  ;-------------------------------------------------------------------------------
   932                                  	POST 14
   933                                  ;-------------------------------------------------------------------------------
   934                                  ;
   935                                  ;   Verify Bit Test operations
   936                                  ;
   937                                  	testBittest16 bt
   938                                  	testBittest16 btc
   939                                  	cmp edx, 0x00005555
   940                                  	jne error
   941                                  	testBittest16 btr
   942                                  	cmp edx, 0
   943                                  	jne error
   944                                  	testBittest16 bts
   945                                  	cmp edx, 0x0000ffff
   946                                  	jne error
   947                                  
   948                                  	testBittest32 bt
   949                                  	testBittest32 btc
   950                                  	cmp edx, 0x55555555
   951                                  	jne error
   952                                  	testBittest32 btr
   953                                  	cmp edx, 0
   954                                  	jne error
   955                                  	testBittest32 bts
   956                                  	cmp edx, 0xffffffff
   957                                  	jne error
   958                                  
   959                                  
   960                                  %include "tests/setcc_m.asm"
   961                                  ;-------------------------------------------------------------------------------
   962                                  	POST 15
   963                                  ;-------------------------------------------------------------------------------
   964                                  ;
   965                                  ;   Verify Byte set on condition (SETcc)
   966                                  ;
   967                                  	testSetcc bl
   968                                  	testSetcc byte [0x10000]
   969                                  
   970                                  	advTestSegProt
   971                                  
   972                                  
   973                                  ;-------------------------------------------------------------------------------
   974                                  	POST 16
   975                                  ;-------------------------------------------------------------------------------
   976                                  ;
   977                                  ;	Calls in protected mode
   978                                  ;
   979                                  	mov si, 0
   980                                  	testCallNear esp
   981                                  	testCallFar C_SEG_PROT32
   982                                  
   983                                  	advTestSegProt
   984                                  
   985                                  
   986                                  ;-------------------------------------------------------------------------------
   987                                  	POST 17
   988                                  ;-------------------------------------------------------------------------------
   989                                  ;
   990                                  ;	Adjust RPL Field of Selector (ARPL)
   991                                  ;
   992                                  	; test on register destination
   993                                  	xor ax, ax       ; ZF = 0
   994                                  	mov ax, 0xfff0
   995                                  	mov bx, 0x0002
   996                                  	arpl ax, bx      ; RPL ax < RPL bx
   997                                  	jnz error        ; must be ZF = 1
   998                                  	cmp ax, 0xfff2
   999                                  	jne error
  1000                                  	; test on memory destination
  1001                                  	xor ax, ax       ; ZF = 0
  1002                                  	mov word [0x20000], 0xfff0
  1003                                  	arpl [0x20000], bx
  1004                                  	jnz error
  1005                                  	cmp word [0x20000], 0xfff2
  1006                                  	jne error
  1007                                  	%if BOCHS = 0
  1008                                  	; test unexpected memory write
  1009                                  	;
  1010                                  	; This test fails with Bochs, which does not write to memory (correctly),
  1011                                  	; but throws a #GP fault before that, during the reading of the memory
  1012                                  	; operand. Bochs checks that the destination segment is writeable before the
  1013                                  	; execution of ARPL.
  1014                                  	;
  1015                                  	; make DS read only
  1016                                  	updLDTDescAcc D1_SEG_PROT,ACC_TYPE_DATA_R|ACC_PRESENT
  1017                                  	mov ax, D1_SEG_PROT
  1018                                  	mov ds, ax
  1019                                  	xor eax, eax
  1020                                  	arpl [0x20000], bx ; value has not changed, arpl should not write to memory
  1021                                  	; make DS writeable again
  1022                                  	updLDTDescAcc D1_SEG_PROT,ACC_TYPE_DATA_W|ACC_PRESENT
  1023                                  	mov ax, D1_SEG_PROT
  1024                                  	mov ds, ax
  1025                                  	%endif
  1026                                  	; test with RPL dest > RPL src
  1027                                  	xor ax, ax       ; ZF = 0
  1028                                  	mov ax, 0xfff3
  1029                                  	arpl ax, bx
  1030                                  	jz error
  1031                                  	cmp ax, 0xfff3
  1032                                  	jne error
  1033                                  
  1034                                  	advTestSegProt
  1035                                  
  1036                                  
  1037                                  ;-------------------------------------------------------------------------------
  1038                                  	POST 18
  1039                                  ;-------------------------------------------------------------------------------
  1040                                  ;
  1041                                  ;	Check Array Index Against Bounds (BOUND)
  1042                                  ;
  1043                                  	setProtModeIntGate EX_BR, BoundExcHandler
  1044                                  	xor eax, eax
  1045                                  	mov ebx, 0x10100
  1046                                  	mov word [0x20000], 0x0010
  1047                                  	mov word [0x20002], 0x0102
  1048                                  	o16 bound bx, [0x20000]
  1049                                  	cmp eax, BOUND_HANDLER_SIG
  1050                                  	je error
  1051                                  	mov word [0x20002], 0x00FF
  1052                                  	o16 bound bx, [0x20000]
  1053                                  	cmp eax, BOUND_HANDLER_SIG
  1054                                  	jne error
  1055                                  	xor eax, eax
  1056                                  	mov dword [0x20004], 0x10010
  1057                                  	mov dword [0x20008], 0x10102
  1058                                  	o32 bound ebx, [0x20004]
  1059                                  	cmp eax, BOUND_HANDLER_SIG
  1060                                  	je error
  1061                                  	mov dword [0x20008], 0x100FF
  1062                                  	o32 bound ebx, [0x20004]
  1063                                  	cmp eax, BOUND_HANDLER_SIG
  1064                                  	jne error
  1065                                  	setProtModeIntGate EX_BR, DefaultExcHandler
  1066                                  
  1067                                  	advTestSegProt
  1068                                  	jmp post19
  1069                                  
  1070                                  BoundExcHandler:
  1071                                  	mov word [0x20002], 0x0100
  1072                                  	mov dword [0x20008], 0x10100
  1073                                  	BOUND_HANDLER_SIG equ 0x626f756e
  1074                                  	mov eax, BOUND_HANDLER_SIG
  1075                                  	iretd
  1076                                  
  1077                                  
  1078                                  %include "tests/xchg_m.asm"
  1079                                  post19:
  1080                                  ;-------------------------------------------------------------------------------
  1081                                  	POST 19
  1082                                  ;-------------------------------------------------------------------------------
  1083                                  ;
  1084                                  ;   Exchange Register/Memory with Register (XCHG)
  1085                                  ;
  1086                                  	testXchg ax,cx ; 66 91
  1087                                  	testXchg ax,dx ; 66 92
  1088                                  	testXchg ax,bx ; 66 93
  1089                                  	mov bp,sp
  1090                                  	testXchg ax,sp ; 66 94
  1091                                  	mov sp,bp
  1092                                  	testXchg ax,bp ; 66 95
  1093                                  	testXchg ax,si ; 66 96
  1094                                  	testXchg ax,di ; 66 97
  1095                                  
  1096                                  	testXchg eax,ecx ; 91
  1097                                  	testXchg eax,edx ; 92
  1098                                  	testXchg eax,ebx ; 93
  1099                                  	mov ebp,esp
  1100                                  	testXchg eax,esp ; 94
  1101                                  	mov esp,ebp
  1102                                  	testXchg eax,ebp ; 95
  1103                                  	testXchg eax,esi ; 96
  1104                                  	testXchg eax,edi ; 97
  1105                                  
  1106                                  	testXchg bl,cl         ; 86 D9
  1107                                  	testXchg byte [0],cl   ; 86 0D 00000000
  1108                                  	testXchg bx,cx         ; 66 87 D9
  1109                                  	testXchg word [0],cx   ; 66 87 0D 00000000
  1110                                  	testXchg ebx,ecx       ; 87 D9
  1111                                  	testXchg dword [0],ecx ; 87 0D 00000000
  1112                                  
  1113                                  	advTestSegProt
  1114                                  
  1115                                  
  1116                                  %include "tests/enter_m.asm"
  1117                                  post1A:
  1118                                  ;-------------------------------------------------------------------------------
  1119                                  	POST 1A
  1120                                  ;-------------------------------------------------------------------------------
  1121                                  ;
  1122                                  ;   Make Stack Frame for Procedure Parameters (ENTER)
  1123                                  ;
  1124                                  	testENTER16 1, 0,16
  1125                                  	testENTER16 2, 1,16
  1126                                  	testENTER16 3, 4,16
  1127                                  	testENTER16 4,36,32
  1128                                  	testENTER32 5, 0,32
  1129                                  	testENTER32 6, 1,32
  1130                                  	testENTER32 7, 4,32
  1131                                  	testENTER32 8,36,16
  1132                                  	; The ENTER instruction causes a page fault whenever a write using the final
  1133                                  	; value of the stack pointer (within the current stack segment) would do so.
  1134                                  	jmp .pageFaultTest
  1135                                  .pageFaultProc:
  1136                                  	call  switchToRing3
  1137                                  	mov   ax, DU_SEG_PROT|3
  1138                                  	mov   ss, ax
  1139                                  	mov   esp, 0x1004
  1140                                  .pageFaultEIP:
  1141                                  	enter 1,0
  1142                                  	jmp   error
  1143                                  .pageFaultTest:
  1144                                  	loadProtModeStack
  1145                                  	updPageFlags 0x1000|(TEST_BASE>>12), PTE_SUPER_W
  1146                                  	protModeFaultTestEx EX_PF, PF_PROT|PF_WRITE|PF_USER, 3, .pageFaultEIP, call .pageFaultProc
  1147                                  	testCPL 0
  1148                                  	mov   ax, D1_SEG_PROT
  1149                                  	mov   ds, ax
  1150                                  	mov   ax, D2_SEG_PROT
  1151                                  	mov   es, ax
  1152                                  
  1153                                  
  1154                                  %include "tests/leave_m.asm"
  1155                                  post1B:
  1156                                  ;-------------------------------------------------------------------------------
  1157                                  	POST 1B
  1158                                  ;-------------------------------------------------------------------------------
  1159                                  ;
  1160                                  ;   High Level Procedure Exit (LEAVE)
  1161                                  ;
  1162                                  	testLEAVE o16,16
  1163                                  	testLEAVE o16,32
  1164                                  	testLEAVE o32,16
  1165                                  	testLEAVE o32,32
  1166                                  
  1167                                  	loadProtModeStack
  1168                                  	jmp post1C
  1169                                  
  1170                                  
  1171                                  %include "tests/ver_p.asm"
  1172                                  post1C:
  1173                                  ;-------------------------------------------------------------------------------
  1174                                  	POST 1C
  1175                                  ;-------------------------------------------------------------------------------
  1176                                  ;
  1177                                  ;   Verify a Segment for Reading or Writing (VERR/VERW)
  1178                                  ;
  1179                                  	; null segment
  1180                                  	testVERR NULL,0
  1181                                  	testVERW NULL,0
  1182                                  	; out of bounds descriptor
  1183                                  	testVERR GDT_SEG_LIMIT+1,0
  1184                                  	testVERW GDT_SEG_LIMIT+1,0
  1185                                  	; system segment
  1186                                  	testVERR LDT_SEG_PROT,0
  1187                                  	testVERW LDT_SEG_PROT,0
  1188                                  
  1189                                  	; CPL 0
  1190                                  	; code segment
  1191                                  	testVERR C_SEG_PROT32,1
  1192                                  	testVERW C_SEG_PROT32,0
  1193                                  	; data segment
  1194                                  	testVERR S_SEG_PROT32,1
  1195                                  	testVERW S_SEG_PROT32,1
  1196                                  
  1197                                  	; CPL 3
  1198                                  	call  switchToRing3
  1199                                  	; non-conforming code segment
  1200                                  	testVERR C_SEG_PROT32,0  ; DPL0 code segment
  1201                                  	testVERW C_SEG_PROT32,0
  1202                                  	testVERR CU_SEG_PROT32,1 ; DPL3 code segment
  1203                                  	testVERW CU_SEG_PROT32,0
  1204                                  	; conforming code segment
  1205                                  	testVERR CC_SEG_PROT32,1
  1206                                  	testVERW CC_SEG_PROT32,0
  1207                                  	; data segment
  1208                                  	testVERR S_SEG_PROT32,0  ; DPL0 stack segment
  1209                                  	testVERW S_SEG_PROT32,0
  1210                                  	testVERR SU_SEG_PROT32,1 ; DPL3 stack segment
  1211                                  	testVERW SU_SEG_PROT32,1
  1212                                  	testVERR ROU_SEG_PROT,1  ; DPL3 read-only data segment
  1213                                  	testVERW ROU_SEG_PROT,0
  1214                                  	call  switchToRing0
  1215                                  
  1216                                  
  1217                                  %include "print_init.asm"
  1218                                  
  1219                                  	jmp undefTests
  1220                                  
  1221                                  %include "print_p.asm"
  1222                                  
  1223                                  undefTests:
  1224                                  ;-------------------------------------------------------------------------------
  1225                                  	POST E0
  1226                                  ;-------------------------------------------------------------------------------
  1227                                  ;
  1228                                  ;   Undefined behaviours and bugs
  1229                                  ;   Results have been validated against 386SX hardware.
  1230                                  ;
  1231                                  	mov al, 0
  1232                                  	cmp al, TEST_UNDEF
  1233                                  	je arithLogicTests
  1234                                  
  1235                                  	mov al, CPU_FAMILY
  1236                                  	cmp al, 3
  1237                                  	je bcd386FlagsTest
  1238                                  	call printUnkCPU
  1239                                  	jmp error
  1240                                  
  1241                                  	%include "tests/bcd_m.asm"
  1242                                  
  1243                                  bcd386FlagsTest:
  1244                                  	PS_CAO  equ PS_CF|PS_AF|PS_OF
  1245                                  	PS_PZSO equ PS_PF|PS_ZF|PS_SF|PS_OF
  1246                                  
  1247                                  	; AAA
  1248                                  	; undefined flags: PF, ZF, SF, OF
  1249                                  	testBCDflags   aaa, 0x0000, 0,           PS_PF|PS_ZF
  1250                                  	testBCDflags   aaa, 0x0001, PS_PZSO,     0
  1251                                  	testBCDflags   aaa, 0x007A, 0,           PS_CF|PS_AF|PS_SF|PS_OF
  1252                                  	testBCDflags   aaa, 0x007B, PS_AF,       PS_CF|PS_PF|PS_AF|PS_SF|PS_OF
  1253                                  	; AAD
  1254                                  	; undefined flags: CF, AF, OF
  1255                                  	testBCDflags   aad, 0x0001, PS_CAO,      0
  1256                                  	testBCDflags   aad, 0x0D8E, 0,           PS_CAO
  1257                                  	testBCDflags   aad, 0x0106, 0,           PS_AF
  1258                                  	testBCDflags   aad, 0x01F7, 0,           PS_CF|PS_AF
  1259                                  	; AAM
  1260                                  	; undefined flags: CF, AF, OF
  1261                                  	testBCDflags   aam, 0x0000, 0,           PS_ZF|PS_PF
  1262                                  	testBCDflags   aam, 0x0000, PS_CAO,      PS_ZF|PS_PF
  1263                                  	; AAS
  1264                                  	; undefined flags: PF, ZF, SF, OF
  1265                                  	testBCDflags   aas, 0x0000, PS_SF|PS_OF, PS_PF|PS_ZF
  1266                                  	testBCDflags   aas, 0x0000, PS_AF,       PS_CF|PS_PF|PS_AF|PS_SF
  1267                                  	testBCDflags   aas, 0x0001, PS_PZSO,     0
  1268                                  	testBCDflags   aas, 0x0680, PS_AF,       PS_CF|PS_AF|PS_OF
  1269                                  	; DAA
  1270                                  	; undefined flags: OF
  1271                                  	testBCDflags   daa, 0x001A, PS_AF|PS_OF, PS_AF
  1272                                  	testBCDflags   daa, 0x001A, PS_CF,       PS_CF|PS_AF|PS_SF|PS_OF
  1273                                  	; DAS
  1274                                  	; undefined flags: OF
  1275                                  	testBCDflags   das, 0x0080, PS_OF,       PS_SF
  1276                                  	testBCDflags   das, 0x0080, PS_AF,       PS_AF|PS_OF
  1277                                  
  1278                                  shifts386FlagsTest:
  1279                                  	%include "tests/shift_m.asm"
  1280                                  
  1281                                  	; SHR al,cl - SHR ax,cl
  1282                                  	; undefined flags:
  1283                                  	;  CF when cl>7 (byte) or cl>15 (word):
  1284                                  	;    if byte operand and cl=8 or cl=16 or cl=24 then CF=MSB(operand)
  1285                                  	;    if word operand and cl=16 then CF=MSB(operand)
  1286                                  	;  OF when cl>1: set according to result
  1287                                  	;  AF when cl>0: always 1
  1288                                  	; shift count is modulo 32 so if cl=32 then result is equal to cl=0
  1289                                  	testShiftBFlags   shr, 0x81,   1,  0,     PS_CF|PS_AF|PS_OF
  1290                                  	testShiftBFlags   shr, 0x82,   2,  0,     PS_CF|PS_AF
  1291                                  	testShiftBFlags   shr, 0x80,   8,  0,     PS_CF|PS_PF|PS_AF|PS_ZF
  1292                                  	testShiftBFlags   shr, 0x00,   8,  PS_CF, PS_PF|PS_AF|PS_ZF
  1293                                  	testShiftBFlags   shr, 0x80,   16, 0,     PS_CF|PS_PF|PS_AF|PS_ZF
  1294                                  	testShiftBFlags   shr, 0x00,   16, PS_CF, PS_PF|PS_AF|PS_ZF
  1295                                  	testShiftBFlags   shr, 0x80,   24, 0,     PS_CF|PS_PF|PS_AF|PS_ZF
  1296                                  	testShiftBFlags   shr, 0x00,   24, PS_CF, PS_PF|PS_AF|PS_ZF
  1297                                  	testShiftBFlags   shr, 0x80,   32, 0,     0
  1298                                  	testShiftWFlags   shr, 0x8000, 16, 0,     PS_CF|PS_PF|PS_AF|PS_ZF
  1299                                  	testShiftWFlags   shr, 0x0000, 16, PS_CF, PS_PF|PS_AF|PS_ZF
  1300                                  	testShiftWFlags   shr, 0x8000, 32, 0,     0
  1301                                  
  1302                                  	; SHL al,cl - SHL ax,cl
  1303                                  	; undefined flags:
  1304                                  	;  CF when cl>7 (byte) or cl>15 (word):
  1305                                  	;    if byte operand and cl=8 or cl=16 or cl=24 then CF=LSB(operand)
  1306                                  	;    if word operand and cl=16 then CF=LSB(operand)
  1307                                  	;  OF when cl>1: set according to result
  1308                                  	;  AF when cl>0: always 1
  1309                                  	; shift count is modulo 32 so if cl=32 then result is equal to cl=0
  1310                                  	testShiftBFlags   shl, 0x81, 1,  0,     PS_CF|PS_AF|PS_OF
  1311                                  	testShiftBFlags   shl, 0x41, 2,  0,     PS_CF|PS_AF|PS_OF
  1312                                  	testShiftBFlags   shl, 0x01, 8,  0,     PS_CF|PS_PF|PS_AF|PS_ZF|PS_OF
  1313                                  	testShiftBFlags   shl, 0x00, 8,  PS_CF, PS_PF|PS_AF|PS_ZF
  1314                                  	testShiftBFlags   shl, 0x01, 16, 0,     PS_CF|PS_PF|PS_AF|PS_ZF|PS_OF
  1315                                  	testShiftBFlags   shl, 0x00, 16, PS_CF, PS_PF|PS_AF|PS_ZF
  1316                                  	testShiftBFlags   shl, 0x01, 24, 0,     PS_CF|PS_PF|PS_AF|PS_ZF|PS_OF
  1317                                  	testShiftBFlags   shl, 0x00, 24, PS_CF, PS_PF|PS_AF|PS_ZF
  1318                                  	testShiftBFlags   shl, 0x01, 32, 0,     0
  1319                                  	testShiftWFlags   shl, 0x01, 16, 0,     PS_CF|PS_PF|PS_AF|PS_ZF|PS_OF
  1320                                  	testShiftWFlags   shl, 0x00, 16, PS_CF, PS_PF|PS_AF|PS_ZF
  1321                                  	testShiftWFlags   shl, 0x01, 32, 0,     0
  1322                                  
  1323                                  bt386FlagsTest:
  1324                                  	; BT, BTC, BTR, BTS
  1325                                  	; undefined flags:
  1326                                  	;  OF: same as RCR with CF=0
  1327                                  	testBittestFlags   0x01, 0, 0,     PS_CF
  1328                                  	testBittestFlags   0x01, 0, PS_CF, PS_CF
  1329                                  	testBittestFlags   0x01, 1, 0,     PS_OF
  1330                                  	testBittestFlags   0x01, 1, PS_CF, PS_OF
  1331                                  	testBittestFlags   0x01, 2, 0,     PS_OF
  1332                                  	testBittestFlags   0x01, 2, PS_CF, PS_OF
  1333                                  	testBittestFlags   0x01, 3, 0,     0
  1334                                  	testBittestFlags   0x01, 3, PS_CF, 0
  1335                                  
  1336                                  rotate386FlagsTest:
  1337                                  	; RCR
  1338                                  	; CF and OF are set with byte and count=9 or word and count=17
  1339                                  	testShiftBFlags   rcr, 0,    9, 0,           0
  1340                                  	testShiftBFlags   rcr, 0,    9, PS_CF|PS_OF, PS_CF
  1341                                  	testShiftBFlags   rcr, 0x40, 9, 0,           PS_OF
  1342                                  	testShiftBFlags   rcr, 0x40, 9, PS_CF|PS_OF, PS_CF|PS_OF
  1343                                  	testShiftWFlags   rcr, 0,      17, 0,           0
  1344                                  	testShiftWFlags   rcr, 0,      17, PS_CF|PS_OF, PS_CF
  1345                                  	testShiftWFlags   rcr, 0x4000, 17, 0,           PS_OF
  1346                                  	testShiftWFlags   rcr, 0x4000, 17, PS_CF|PS_OF, PS_CF|PS_OF
  1347                                  	; RCL
  1348                                  	; CF and OF are set with byte and count=9 or word and count=17
  1349                                  	testShiftBFlags   rcl, 0,    9, 0,           0
  1350                                  	testShiftBFlags   rcl, 0,    9, PS_CF|PS_OF, PS_CF|PS_OF
  1351                                  	testShiftBFlags   rcl, 0x80, 9, 0,           PS_OF
  1352                                  	testShiftBFlags   rcl, 0x80, 9, PS_CF|PS_OF, PS_CF
  1353                                  	testShiftWFlags   rcl, 0,      17, 0,           0
  1354                                  	testShiftWFlags   rcl, 0,      17, PS_CF|PS_OF, PS_CF|PS_OF
  1355                                  	testShiftWFlags   rcl, 0x8000, 17, 0,           PS_OF
  1356                                  	testShiftWFlags   rcl, 0x8000, 17, PS_CF|PS_OF, PS_CF
  1357                                  
  1358                                  	jmp arithLogicTests
  1359                                  
  1360                                  arithLogicTests:
  1361                                  ;-------------------------------------------------------------------------------
  1362                                  	POST EE
  1363                                  ;-------------------------------------------------------------------------------
  1364                                  ;
  1365                                  ;   Now run a series of unverified tests for arithmetical and logical opcodes
  1366                                  ;   Manually verify by comparing the tests output with a reference file
  1367                                  ;
  1368                                  	jmp bcdTests
  1369                                  
  1370                                  bcdTests:
  1371                                  	testBCD   daa, 0x12340503, PS_AF,         PS_CF | PS_PF | PS_ZF | PS_SF | PS_AF
  1372                                  	testBCD   daa, 0x12340506, PS_AF,         PS_CF | PS_PF | PS_ZF | PS_SF | PS_AF
  1373                                  	testBCD   daa, 0x12340507, PS_AF,         PS_CF | PS_PF | PS_ZF | PS_SF | PS_AF
  1374                                  	testBCD   daa, 0x12340559, PS_AF,         PS_CF | PS_PF | PS_ZF | PS_SF | PS_AF
  1375                                  	testBCD   daa, 0x12340560, PS_AF,         PS_CF | PS_PF | PS_ZF | PS_SF | PS_AF
  1376                                  	testBCD   daa, 0x1234059f, PS_AF,         PS_CF | PS_PF | PS_ZF | PS_SF | PS_AF
  1377                                  	testBCD   daa, 0x123405a0, PS_AF,         PS_CF | PS_PF | PS_ZF | PS_SF | PS_AF
  1378                                  	testBCD   daa, 0x12340503, 0,             PS_CF | PS_PF | PS_ZF | PS_SF | PS_AF
  1379                                  	testBCD   daa, 0x12340506, 0,             PS_CF | PS_PF | PS_ZF | PS_SF | PS_AF
  1380                                  	testBCD   daa, 0x12340503, PS_CF,         PS_CF | PS_PF | PS_ZF | PS_SF | PS_AF
  1381                                  	testBCD   daa, 0x12340506, PS_CF,         PS_CF | PS_PF | PS_ZF | PS_SF | PS_AF
  1382                                  	testBCD   daa, 0x12340503, PS_CF | PS_AF, PS_CF | PS_PF | PS_ZF | PS_SF | PS_AF
  1383                                  	testBCD   daa, 0x12340506, PS_CF | PS_AF, PS_CF | PS_PF | PS_ZF | PS_SF | PS_AF
  1384                                  	testBCD   das, 0x12340503, PS_AF,         PS_CF | PS_PF | PS_ZF | PS_SF | PS_AF
  1385                                  	testBCD   das, 0x12340506, PS_AF,         PS_CF | PS_PF | PS_ZF | PS_SF | PS_AF
  1386                                  	testBCD   das, 0x12340507, PS_AF,         PS_CF | PS_PF | PS_ZF | PS_SF | PS_AF
  1387                                  	testBCD   das, 0x12340559, PS_AF,         PS_CF | PS_PF | PS_ZF | PS_SF | PS_AF
  1388                                  	testBCD   das, 0x12340560, PS_AF,         PS_CF | PS_PF | PS_ZF | PS_SF | PS_AF
  1389                                  	testBCD   das, 0x1234059f, PS_AF,         PS_CF | PS_PF | PS_ZF | PS_SF | PS_AF
  1390                                  	testBCD   das, 0x123405a0, PS_AF,         PS_CF | PS_PF | PS_ZF | PS_SF | PS_AF
  1391                                  	testBCD   das, 0x12340503, 0,             PS_CF | PS_PF | PS_ZF | PS_SF | PS_AF
  1392                                  	testBCD   das, 0x12340506, 0,             PS_CF | PS_PF | PS_ZF | PS_SF | PS_AF
  1393                                  	testBCD   das, 0x12340503, PS_CF,         PS_CF | PS_PF | PS_ZF | PS_SF | PS_AF
  1394                                  	testBCD   das, 0x12340506, PS_CF,         PS_CF | PS_PF | PS_ZF | PS_SF | PS_AF
  1395                                  	testBCD   das, 0x12340503, PS_CF | PS_AF, PS_CF | PS_PF | PS_ZF | PS_SF | PS_AF
  1396                                  	testBCD   das, 0x12340506, PS_CF | PS_AF, PS_CF | PS_PF | PS_ZF | PS_SF | PS_AF
  1397                                  	testBCD   aaa, 0x12340205, PS_AF,         PS_CF | PS_AF
  1398                                  	testBCD   aaa, 0x12340306, PS_AF,         PS_CF | PS_AF
  1399                                  	testBCD   aaa, 0x1234040a, PS_AF,         PS_CF | PS_AF
  1400                                  	testBCD   aaa, 0x123405fa, PS_AF,         PS_CF | PS_AF
  1401                                  	testBCD   aaa, 0x12340205, 0,             PS_CF | PS_AF
  1402                                  	testBCD   aaa, 0x12340306, 0,             PS_CF | PS_AF
  1403                                  	testBCD   aaa, 0x1234040a, 0,             PS_CF | PS_AF
  1404                                  	testBCD   aaa, 0x123405fa, 0,             PS_CF | PS_AF
  1405                                  	testBCD   aas, 0x12340205, PS_AF,         PS_CF | PS_AF
  1406                                  	testBCD   aas, 0x12340306, PS_AF,         PS_CF | PS_AF
  1407                                  	testBCD   aas, 0x1234040a, PS_AF,         PS_CF | PS_AF
  1408                                  	testBCD   aas, 0x123405fa, PS_AF,         PS_CF | PS_AF
  1409                                  	testBCD   aas, 0x12340205, 0,             PS_CF | PS_AF
  1410                                  	testBCD   aas, 0x12340306, 0,             PS_CF | PS_AF
  1411                                  	testBCD   aas, 0x1234040a, 0,             PS_CF | PS_AF
  1412                                  	testBCD   aas, 0x123405fa, 0,             PS_CF | PS_AF
  1413                                  	testBCD   aam, 0x12340547, PS_AF,         PS_PF | PS_ZF | PS_SF
  1414                                  	testBCD   aad, 0x12340407, PS_AF,         PS_PF | PS_ZF | PS_SF
  1415                                  
  1416                                  
  1417                                  	setProtModeIntGate EX_DE, DivExcHandler
  1418                                  	cld
  1419                                  	; The tests for arithmetical and logical opcodes are defined as a sequence
  1420                                  	; of procedures labeled as "tableOps" (see tests/arith-logic_d.asm)
  1421                                  	mov    esi, tableOps   ; ESI -> tableOps entry
  1422                                  
  1423                                  testOps:
  1424                                  	movzx  ecx, byte [cs:esi]           ; ECX == length of instruction sequence
  1425                                  	test   ecx, ecx                     ; (must use JZ since there's no long version of JECXZ)
  1426                                  	jz     near testDone                ; zero means we've reached the end of the table
  1427                                  	movzx  ebx, byte [cs:esi+1]         ; EBX == TYPE
  1428                                  	shl    ebx, 6                       ; EBX == TYPE * 64
  1429                                  	movzx  edx, byte [cs:esi+2]         ; EDX == SIZE
  1430                                  	shl    edx, 4                       ; EDX == SIZE * 16
  1431                                  	lea    ebx, [cs:typeValues+ebx+edx] ; EBX -> values for type
  1432                                  	add    esi, 3                       ; ESI -> instruction mnemonic
  1433                                  .skip:
  1434                                  	cs lodsb
  1435                                  	test   al,al
  1436                                  	jnz    .skip
  1437                                  	push   ecx
  1438                                  	mov    ecx, [cs:ebx]    ; ECX == count of values for dst
  1439                                  	mov    eax, [cs:ebx+4]  ; EAX -> values for dst
  1440                                  	mov    ebp, [cs:ebx+8]  ; EBP == count of values for src
  1441                                  	mov    edi, [cs:ebx+12] ; EDI -> values for src
  1442                                  	xchg   ebx, eax         ; EBX -> values for dst
  1443                                  	sub    eax, eax         ; set all ARITH flags to known values prior to tests
  1444                                  testDst:
  1445                                  	push   ebp
  1446                                  	push   edi
  1447                                  	pushfd
  1448                                  testSrc:
  1449                                  	mov   eax, [cs:ebx]    ; EAX == dst
  1450                                  	mov   edx, [cs:edi]    ; EDX == src
  1451                                  	popfd
  1452                                  	call  printOp
  1453                                  	call  printEAX
  1454                                  	call  printEDX
  1455                                  	call  printPS
  1456                                  	call  esi       ; execute the instruction sequence
  1457                                  	call  printEAX
  1458                                  	call  printEDX
  1459                                  	call  printPS
  1460                                  	call  printEOL
  1461                                  	pushfd
  1462                                  	add   edi,4    ; EDI -> next src
  1463                                  	dec   ebp      ; decrement src count
  1464                                  	jnz   testSrc
  1465                                  	popfd
  1466                                  	pop   edi         ; ESI -> restored values for src
  1467                                  	pop   ebp         ; EBP == restored count of values for src
  1468                                  	lea   ebx,[ebx+4] ; EBX -> next dst (without modifying flags)
  1469                                  	loop  testDst
  1470                                  
  1471                                  	pop  ecx
  1472                                  	add  esi, ecx     ; ESI -> next tableOps entry
  1473                                  	jmp  testOps
  1474                                  
  1475                                  testDone:
  1476                                  	jmp postFF
  1477                                  
  1478                                  DivExcHandler:
  1479                                  	push esi
  1480                                  	mov  esi,strDE
  1481                                  	call printStr
  1482                                  	pop  esi
  1483                                  ;
  1484                                  ;   It's rather annoying that the 80386 treats #DE as a fault rather than a trap, leaving CS:EIP pointing to the
  1485                                  ;   faulting instruction instead of the RET we conveniently placed after it.  So, instead of trying to calculate where
  1486                                  ;   that RET is, we simply set EIP on the stack to point to our own RET.
  1487                                  ;
  1488                                  	mov  dword [esp], DivExcHandlerRet
  1489                                  	iretd
  1490                                  DivExcHandlerRet:
  1491                                  	ret
  1492                                  
  1493                                  %include "tests/arith-logic_d.asm"
  1494                                  
  1495                                  %endif
  1496                                  
  1497                                  postFF:
  1498                                  ;-------------------------------------------------------------------------------
  1499                                  	POST FF
     5 000015BD B0FF                <1>  mov al, 0x%1
     6 000015BF BA9909              <1>  mov dx, POST_PORT
     7 000015C2 EE                  <1>  out dx, al
  1500                                  ;-------------------------------------------------------------------------------
  1501                                  ;
  1502                                  ;   Testing finished. STOP.
  1503                                  ;
  1504 000015C3 FA                      	cli
  1505 000015C4 F4                      	hlt
  1506 000015C5 EBF6                    	jmp postFF
  1507                                  
  1508                                  ;
  1509                                  ; Default exception handler and error routine
  1510                                  ;
  1511                                  DefaultExcHandler:
  1512                                  error:
  1513                                  	; CLI and HLT are privileged instructions, don't use them in ring3
  1514 000015C7 8CC8                    	mov ax, cs
  1515                                  	; when in real mode, the jnz will be decoded together with test as
  1516                                  	; "test eax,0xfe750007" (66A9070075FE)
  1517 000015C9 A90700                  	test ax, 7     ; 66 A9 07 00
  1518 000015CC 75FE                    .ring3: jnz .ring3 ; 75 FE
  1519 000015CE FA                      	cli
  1520 000015CF F4                      	hlt
  1521 000015D0 EBF5                    	jmp error
  1522                                  
  1523                                  
  1524                                  LPTports:
  1525 000015D2 BC03                    	dw   0x3BC
  1526 000015D4 7803                    	dw   0x378
  1527 000015D6 7802                    	dw   0x278
  1528                                  COMTHRports:
  1529 000015D8 F803                    	dw   0x3F8
  1530 000015DA F802                    	dw   0x2F8
  1531                                  COMLSRports:
  1532 000015DC FD03                    	dw   0x3FD
  1533 000015DE FD02                    	dw   0x2FD
  1534                                  signedWord:
  1535 000015E0 80                      	db   0x80
  1536                                  signedByte:
  1537 000015E1 80                      	db   0x80
  1538                                  
  1539                                  ;
  1540                                  ;   Fill the remaining space with NOPs until we get to target offset 0xFFF0.
  1541                                  ;
  1542 000015E2 90<rep EA0Eh>           	times 0xfff0-($-$$) nop
  1543                                  
  1544                                  
  1545                                  bits 16
  1546                                  
  1547                                  resetVector:
  1548 0000FFF0 EA[4500]00F0            	jmp   C_SEG_REAL:cpuTest ; 0000FFF0
  1549                                  
  1550                                  release:
  1551 0000FFF5 3F3F2F3F3F2F323100      	db    RELEASE,0       ; 0000FFF5  release date
  1552 0000FFFE FC                      	db    0xFC            ; 0000FFFE  FC (Model ID byte)
  1553 0000FFFF 00                      	db    0x00            ; 0000FFFF  00 (checksum byte, unused)
