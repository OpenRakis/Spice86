@moxy
@attribute required int Size
@attribute required string Operation
@attribute required string Mutation
@moxy

namespace {{ moxy.Class.Namespace }};

using Spice86.Core.Emulator.CPU.CfgCpu.Ast;
using Spice86.Core.Emulator.CPU.CfgCpu.Ast.Builder;
using Spice86.Core.Emulator.CPU.CfgCpu.Ast.Instruction;
using Spice86.Core.Emulator.CPU.CfgCpu.Ast.Operations;
using Spice86.Core.Emulator.CPU.CfgCpu.Ast.Value;
using Spice86.Core.Emulator.CPU.CfgCpu.InstructionExecutor;
using Spice86.Core.Emulator.CPU.CfgCpu.ParsedInstruction.ModRm;
using Spice86.Core.Emulator.CPU.CfgCpu.ParsedInstruction.Prefix;
using Spice86.Shared.Emulator.Memory;

public partial class {{ moxy.Class.Name }} : InstructionWithModRm {

    public {{ moxy.Class.Name }}(SegmentedAddress address, InstructionField<ushort> opcodeField, List<InstructionPrefix> prefixes, ModRmContext modRmContext) : base(address, opcodeField, prefixes, modRmContext, 1) {
    }

    public override void Execute(InstructionExecutionHelper helper) {
        helper.ModRm.RefreshWithNewModRmContext(ModRmContext);
        uint bitIndex = helper.ModRm.R{{Size}};
        ExecuteBitOperation(helper, bitIndex);
        helper.MoveIpToEndOfInstruction(this);
    }

    private void ExecuteBitOperation(InstructionExecutionHelper helper, uint bitIndex) {
        {{ if Size == 16 }}ushort{{ else }}uint{{ end }} value;
        bool isMemory = helper.ModRm.MemoryAddress != null;
        if (!isMemory) {
            value = helper.ModRm.RM{{Size}};
            helper.State.CarryFlag = IsBitSet(value, bitIndex % {{Size}});
            {{ if Mutation != "None" }}
            value = ApplyMutation(value, bitIndex % {{Size}});
            helper.ModRm.RM{{Size}} = value;
            {{ end }}
            return;
        }

        uint baseAddress = helper.ModRm.MandatoryMemoryAddress;
        uint elementSize = {{Size}};
        uint elementBytes = elementSize / 8;
        uint elementIndex = bitIndex / elementSize;
        uint bitInElement = bitIndex % elementSize;
        uint address = baseAddress + elementIndex * elementBytes;
        {{ if Size == 16 }}value = helper.Memory.UInt16[address];{{ else }}value = helper.Memory.UInt32[address];{{ end }}
        helper.State.CarryFlag = IsBitSet(value, bitInElement);
        {{ if Mutation != "None" }}
        value = ApplyMutation(value, bitInElement);
        {{ if Size == 16 }}helper.Memory.UInt16[address] = value;{{ else }}helper.Memory.UInt32[address] = value;{{ end }}
        {{ end }}
    }

    private bool IsBitSet({{ if Size == 16 }}ushort{{ else }}uint{{ end }} value, uint bitIndex) {
        {{ if Size == 16 }}ushort mask = (ushort)(1 << (int)bitIndex);{{ else }}uint mask = 1u << (int)bitIndex;{{ end }}
        return (value & mask) != 0;
    }

    private {{ if Size == 16 }}ushort{{ else }}uint{{ end }} ApplyMutation({{ if Size == 16 }}ushort{{ else }}uint{{ end }} value, uint bitIndex) {
        {{ if Size == 16 }}ushort mask = (ushort)(1 << (int)bitIndex);{{ else }}uint mask = 1u << (int)bitIndex;{{ end }}
        {{ if Mutation == "Set" }}
        return ({{ if Size == 16 }}ushort{{ else }}uint{{ end }})(value | mask);
        {{ else if Mutation == "Reset" }}
        return ({{ if Size == 16 }}ushort{{ else }}uint{{ end }})(value & ({{ if Size == 16 }}ushort{{ else }}uint{{ end }})~mask);
        {{ else if Mutation == "Toggle" }}
        return ({{ if Size == 16 }}ushort{{ else }}uint{{ end }})(value ^ mask);
        {{ else }}
        return value;
        {{ end }}
    }

    public override InstructionNode ToInstructionAst(AstBuilder builder) {
        return new InstructionNode(InstructionOperation.{{Operation}},
            builder.ModRm.RmToNode(builder.UType({{Size}}), ModRmContext),
            builder.ModRm.RToNode(builder.UType({{Size}}), ModRmContext));
    }

    public override IVisitableAstNode GenerateExecutionAst(AstBuilder builder) {
        DataType dataType = builder.UType({{Size}});

        // bitIndex = R register
        ValueNode bitIndexNode = builder.ModRm.RToNode(dataType, ModRmContext);

        // bitInElement = bitIndex % {{Size}} (same for both register and memory)
        // Result is always a small value (0-31 or 0-15), so we use the operand's data type
        BinaryOperationNode bitInElement = new BinaryOperationNode(dataType, bitIndexNode, BinaryOperation.MODULO, builder.Constant.ToNode({{Size}}));

        // Get the target node (register or adjusted memory pointer)
        // This is the only path-specific code
        ValueNode targetNode;
        bool isMemory = ModRmContext.MemoryAddressType != MemoryAddressType.NONE;
        if (!isMemory) {
            // Register path: simple RM access
            targetNode = builder.ModRm.RmToNode(dataType, ModRmContext);
        } else {
            // Memory path: calculate offset adjustment based on bit index
            // Per Intel spec: Effective Address + (elementBytes * (bitIndex / elementSize))
            const uint elementSize = {{Size}};
            const uint elementBytes = elementSize / 8;

            // elementIndex = bitIndex / {{Size}}
            BinaryOperationNode elementIndex = new BinaryOperationNode(DataType.UINT32, bitIndexNode, BinaryOperation.DIVIDE, builder.Constant.ToNode(elementSize));

            // offsetAdjustment = elementIndex * elementBytes
            BinaryOperationNode offsetAdjustment = new BinaryOperationNode(DataType.UINT32, elementIndex, BinaryOperation.MULTIPLY, builder.Constant.ToNode(elementBytes));

            // Create adjusted memory pointer
            targetNode = builder.ModRm.ToMemoryAddressNodeWithOffsetAdjustment(dataType, ModRmContext, offsetAdjustment);
        }

        // Common bit test and mutation logic for both paths
        // CarryFlag = IsBitSet(target, bitInElement)
        BinaryOperationNode carryValue = builder.Bitwise.IsBitSet(targetNode, bitInElement);
        IVisitableAstNode setCarry = builder.Assign(DataType.BOOL, builder.Flag.Carry(), carryValue);

        {{ if Mutation == "None" }}
        // BT: No mutation, just set carry flag
        return builder.WithIpAdvancement(this, setCarry);
        {{ else }}
        // BTC/BTR/BTS: Apply mutation and write back
        {{ if Mutation == "Set" }}
        // BTS: value = SetBit(value, bitInElement)
        BinaryOperationNode mutatedValue = builder.Bitwise.SetBit(targetNode, bitInElement);
        {{ else if Mutation == "Reset" }}
        // BTR: value = ResetBit(value, bitInElement)
        BinaryOperationNode mutatedValue = builder.Bitwise.ResetBit(targetNode, bitInElement);
        {{ else if Mutation == "Toggle" }}
        // BTC: value = ToggleBit(value, bitInElement)
        BinaryOperationNode mutatedValue = builder.Bitwise.ToggleBit(targetNode, bitInElement);
        {{ end }}
        IVisitableAstNode assignMutated = builder.Assign(dataType, targetNode, mutatedValue);

        return builder.WithIpAdvancement(this, setCarry, assignMutated);
        {{ end }}
    }
}
