@moxy
@attribute required int Size
@attribute required string SignedType
@attribute required string MemoryIndexer
@attribute required int ElementSize
@moxy

namespace {{ moxy.Class.Namespace }};

using System;

using Spice86.Core.Emulator.CPU.CfgCpu.Ast.Builder;
using Spice86.Core.Emulator.CPU.CfgCpu.Ast.Instruction;
using Spice86.Core.Emulator.CPU.CfgCpu.Ast.Operations;
using Spice86.Core.Emulator.CPU.CfgCpu.Ast.Value;
using Spice86.Core.Emulator.CPU.CfgCpu.InstructionExecutor;
using Spice86.Core.Emulator.CPU.CfgCpu.ParsedInstruction.ModRm;
using Spice86.Core.Emulator.CPU.CfgCpu.ParsedInstruction.Prefix;
using Spice86.Core.Emulator.CPU.Exceptions;
using Spice86.Core.Emulator.CPU.Registers;
using Spice86.Shared.Emulator.Memory;

public partial class {{ moxy.Class.Name }} : InstructionWithModRm {
    public {{ moxy.Class.Name }}(SegmentedAddress address, InstructionField<ushort> opcodeField, List<InstructionPrefix> prefixes, ModRmContext modRmContext) :
        base(address, opcodeField, prefixes, modRmContext, 1) {
    }

    public override void Execute(InstructionExecutionHelper helper) {
        helper.ModRm.RefreshWithNewModRmContext(ModRmContext);
        if (ModRmContext.MemoryAddressType == MemoryAddressType.NONE) {
            throw new CpuInvalidOpcodeException("BOUND requires a memory operand.");
        }

        uint address = helper.ModRm.MandatoryMemoryAddress;
        {{SignedType}} lowerBound = helper.Memory.{{MemoryIndexer}}[address];
        uint upperAddress = address + (uint){{ElementSize}};
        {{SignedType}} upperBound = helper.Memory.{{MemoryIndexer}}[upperAddress];
        {{SignedType}} index = ({{SignedType}}){{ if Size == 16 }}helper.ModRm.R16{{ else }}helper.ModRm.R32{{ end }};
        if (index < lowerBound || index > upperBound) {
            throw new CpuBoundRangeExceededException(
                $"BOUND check failed: index={index}, lower={lowerBound}, upper={upperBound}.");
        }

        helper.MoveIpToEndOfInstruction(this);
    }

    public override InstructionNode ToInstructionAst(AstBuilder builder) {
        ValueNode indexNode = builder.ModRm.RToNode(builder.SType({{Size}}), ModRmContext);
        ValueNode lowerPointer = builder.ModRm.ToMemoryAddressNode(builder.SType({{Size}}), ModRmContext);
        if (ModRmContext.SegmentIndex == null) {
            throw new InvalidOperationException("Segment index must be set for BOUND memory operand.");
        }

        ValueNode offset = builder.ModRm.MemoryOffsetToNode(ModRmContext);
        ValueNode increment = builder.Constant.ToNode({{ if Size == 16 }}(ushort){{ElementSize}}{{ else }}(uint){{ElementSize}}{{ end }});
        ValueNode upperOffset = new BinaryOperationNode(builder.AddressType(this), offset, BinaryOperation.PLUS, increment);
        ValueNode upperPointer = builder.Pointer.ToSegmentedPointer(builder.SType({{Size}}), (SegmentRegisterIndex)ModRmContext.SegmentIndex.Value, upperOffset);

        return new InstructionNode(
            InstructionOperation.BOUND,
            indexNode,
            lowerPointer,
            upperPointer);
    }
}
