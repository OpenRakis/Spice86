using Spice86.Logging;
using Spice86.Shared.Interfaces;

namespace Spice86.Core.Emulator.CPU;
using Serilog.Events;

using Spice86.Core.Emulator.Callback;
using Spice86.Core.Emulator.CPU.Exceptions;
using Spice86.Core.Emulator.CPU.InstructionsImpl;
using Spice86.Core.Emulator.Errors;
using Spice86.Core.Emulator.Function;
using Spice86.Core.Emulator.IOPorts;
using Spice86.Core.Emulator.Memory;
using Spice86.Core.Emulator.VM;
using Spice86.Core.Utils;

using System.Collections.Generic;

/// <summary>
/// Implementation of a 8086 CPU. <br /> It has some 80186, 80286 and 80386 instructions as some
/// program use them. <br /> It also has some x87 FPU instructions to support telling the programs
/// that x87 is not supported :) <br /> Some docs that helped the implementation: <ul> <li>
/// Instructions decoding: http://rubbermallet.org/8086%20notes.pdf and
/// http://ref.x86asm.net/coder32.html </li><li> Instructions implementation details:
/// https://www.felixcloutier.com/x86/ </li><li> Pure 8086 instructions:
/// https://jbwyatt.com/253/emu/8086_instruction_set.html </li></ul>
/// </summary>
public class Cpu {
    // Extract regIndex from opcode
    private const int RegIndexMask = 0b111;

    private readonly ILoggerService _loggerService;

    private static readonly HashSet<int> _stringOpCodes = new()
        { 0xA4, 0xA5, 0xA6, 0xA7, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF, 0x6C, 0x6D, 0x6E, 0x6F };

    private readonly Machine _machine;
    private readonly Memory _memory;
    private readonly ModRM _modRM;
    private readonly Instructions8 _instructions8;
    private readonly Instructions16 _instructions16;
    private readonly Instructions32 _instructions32;
    private Instructions16Or32 _instructions16Or32;

    /// <summary>
    /// Address size for the currently executing instruction.
    /// </summary>
    public int AddressSize { get; private set; }

    public CallbackHandler? CallbackHandler { get; set; }

    // When true will crash if an interrupt targets code at 0000:0000
    public bool ErrorOnUninitializedInterruptHandler { get; set; }

    // interrupt not generated by the code
    public byte? ExternalInterruptVectorNumber { get; set; }

    // Value used to read parts of the instruction.
    // CPU uses this internally and adjusts IP after instruction execution is done.
    private ushort _internalIp;

    public IOPortDispatcher? IoPortDispatcher { get; set; }

    public ExecutionFlowRecorder ExecutionFlowRecorder { get; }

    public Cpu(Machine machine, ILoggerService loggerService, ExecutionFlowRecorder executionFlowRecorder, bool recordData) {
        _loggerService = loggerService;
        _machine = machine;
        _memory = machine.MainMemory;
        State = new State();
        Alu = new Alu(State);
        Stack = new Stack(_memory, State);
        ExecutionFlowRecorder = executionFlowRecorder;
        FunctionHandler = new FunctionHandler(machine, _loggerService, recordData);
        FunctionHandlerInExternalInterrupt = new FunctionHandler(machine, _loggerService, recordData);
        FunctionHandlerInUse = FunctionHandler;
        StaticAddressesRecorder = new StaticAddressesRecorder(State, recordData);
        _modRM = new ModRM(machine, this);
        _instructions8 = new Instructions8(machine, Alu, this, _memory, _modRM, StaticAddressesRecorder);
        _instructions16 = new Instructions16(machine, Alu, this, _memory, _modRM, StaticAddressesRecorder);
        _instructions32 = new Instructions32(machine, Alu, this, _memory, _modRM, StaticAddressesRecorder);
        _instructions16Or32 = _instructions16;
        AddressSize = 16;
    }

    public void ExecuteNextInstruction() {
        _internalIp = State.IP;
        ExecutionFlowRecorder.RegisterExecutedInstruction(State.CS, _internalIp);
        StaticAddressesRecorder.Reset();
        byte opcode = ProcessPrefixes();
        if (State.ContinueZeroFlagValue != null && IsStringOpcode(opcode)) {
            // continueZeroFlag is either true or false if a rep prefix has been encountered
            ProcessRep(opcode);
        } else {
            try {
                ExecOpcode(opcode);
            }
            catch (CpuException e) {
                HandleCpuException(e);
            }
        }
        // Reset to 16 bit operand and address size
        _instructions16Or32 = _instructions16;
        AddressSize = 16;
        State.ClearPrefixes();
        StaticAddressesRecorder.Commit();
        State.IncCycles();
        HandleExternalInterrupt();
        State.IP = _internalIp;
    }

    public void ExternalInterrupt(byte vectorNumber) {
        ExternalInterruptVectorNumber = vectorNumber;
    }

    public void FarRet(ushort numberOfBytesToPop) {
        FunctionHandlerInUse.Ret(CallType.FAR);
        _internalIp = Stack.Pop16();
        ushort cs = Stack.Pop16();
        ExecutionFlowRecorder.RegisterReturn(State.CS, State.IP, cs, _internalIp);
        State.CS = cs;
        State.SP = (ushort)(numberOfBytesToPop + State.SP);
        // Set it here for overriden code calling this
        State.IP = _internalIp;
    }

    public bool IsRunning { get; set; } = true;

    public Alu Alu { get; }

    public FunctionHandler FunctionHandler { get; }

    public FunctionHandler FunctionHandlerInExternalInterrupt { get; }

    public FunctionHandler FunctionHandlerInUse { get; private set; }

    public Stack Stack { get; }

    public State State { get; }

    public StaticAddressesRecorder StaticAddressesRecorder { get; }

    public void InterruptRet() {
        FunctionHandlerInUse.Ret(CallType.INTERRUPT);
        _internalIp = Stack.Pop16();
        State.CS = Stack.Pop16();
        State.Flags.FlagRegister = Stack.Pop16();
        FunctionHandlerInUse = FunctionHandler;
        // Set it here for overriden code calling this
        State.IP = _internalIp;
    }

    public void NearRet(int numberOfBytesToPop) {
        FunctionHandlerInUse.Ret(CallType.NEAR);
        _internalIp = Stack.Pop16();
        ExecutionFlowRecorder.RegisterReturn(State.CS, State.IP, State.CS, _internalIp);
        State.SP = (ushort)(numberOfBytesToPop + State.SP);
        // Set it here for overriden code calling this
        State.IP = _internalIp;
    }

    public uint NextUint32() {
        uint res = _memory.GetUint32(InternalIpPhysicalAddress);
        ExecutionFlowRecorder.RegisterExecutableByte(_machine, State.CS, _internalIp);
        ExecutionFlowRecorder.RegisterExecutableByte(_machine, State.CS, (ushort) (_internalIp+1));
        ExecutionFlowRecorder.RegisterExecutableByte(_machine, State.CS, (ushort) (_internalIp+2));
        ExecutionFlowRecorder.RegisterExecutableByte(_machine, State.CS, (ushort) (_internalIp+3));
        _internalIp += 4;
        return res;
    }

    public ushort NextUint16() {
        ushort res = _memory.GetUint16(InternalIpPhysicalAddress);
        ExecutionFlowRecorder.RegisterExecutableByte(_machine, State.CS, _internalIp);
        ExecutionFlowRecorder.RegisterExecutableByte(_machine, State.CS, (ushort) (_internalIp+1));
        _internalIp += 2;
        return res;
    }

    public byte NextUint8() {
        byte res = _memory.GetUint8(InternalIpPhysicalAddress);
        ExecutionFlowRecorder.RegisterExecutableByte(_machine, State.CS, _internalIp);
        _internalIp++;
        return res;
    }

    public void SetFlagOnInterruptStack(int flagMask, bool flagValue) {
        uint flagsAddress = MemoryUtils.ToPhysicalAddress(State.SS, (ushort)(State.SP + 4));
        int value = _memory.GetUint16(flagsAddress);
        if (flagValue) {
            value |= flagMask;
        } else {
            value &= ~flagMask;
        }

        _memory.SetUint16(flagsAddress, (ushort)value);
    }

    private void HandleCpuException(CpuException cpuException) {
        if (_loggerService.IsEnabled(LogEventLevel.Debug)) {
            _loggerService.Debug(cpuException.ToString());
        }
        if (cpuException.Type is CpuExceptionType.Fault) {
            _instructions16Or32 = _instructions16;
            State.ClearPrefixes();
            _internalIp = State.IP;
        }
        if (cpuException.ErrorCode != null) {
            Stack.Push16(cpuException.ErrorCode.Value);
        }
        Interrupt(cpuException.InterruptVector, false);
    }

    private static bool IsStringOpUpdatingFlags(int stringOpCode)
        => stringOpCode is 0xA6 // CMPSB
            or 0xA7 // CMPSW
            or 0xAE // SCASB
            or 0xAF;

    public void Callback(ushort callbackIndex) {
        CallbackHandler?.Run(callbackIndex);
    }

    private void ExecSubOpcode(byte subcode) {
        switch (subcode) {
            case 0x80:
            case 0x81:
            case 0x82:
            case 0x83:
            case 0x84:
            case 0x85:
            case 0x86:
            case 0x87:
            case 0x88:
            case 0x89:
            case 0x8A:
            case 0x8B:
            case 0x8C:
            case 0x8D:
            case 0x8E:
            case 0x8F:
                Jcc(TestJumpCondition(subcode), AddressSize);
                break;
            case 0x90:
            case 0x91:
            case 0x92:
            case 0x93:
            case 0x94:
            case 0x95:
            case 0x96:
            case 0x97:
            case 0x98:
            case 0x99:
            case 0x9A:
            case 0x9B:
            case 0x9C:
            case 0x9D:
            case 0x9E:
            case 0x9F:
                _instructions8.Setcc(TestJumpCondition(subcode));
                break;
            case 0xA0:
                // PUSH FS
                Stack.Push16(State.FS);
                break;
            case 0xA1:
                // POP FS
                State.FS = Stack.Pop16();
                break;
            case 0xA4:
                // SHLD r/m16, r16, imm8
                // SHLD r/m32, r32, imm8
                _instructions16Or32.Shld(Grp2CountSource.NextUint8);
                break;
            case 0xA5:
                // SHLD r/m16, r16, CL
                // SHLD r/m32, r32, CL
                _instructions16Or32.Shld(Grp2CountSource.CL);
                break;
            case 0xA8:
                // PUSH GS
                Stack.Push16(State.GS);
                break;
            case 0xA9:
                // POP GS
                State.GS = Stack.Pop16();
                break;
            case 0xAF:
                // IMUL r16, r/m16
                // IMUL r32, r/m32
                _instructions16Or32.ImulRmReg16Or32();
                break;
            case 0xB4:
                _instructions16Or32.Lfs();
                break;
            case 0xB5:
                _instructions16Or32.Lgs();
                break;
            case 0xB6:
                // MOVZX r16, r/m8
                // MOVZX r32, r/m8
                _instructions16Or32.MovzxByte();
                break;
            case 0xB7:
                // MOVZX r32, r/m16
                _instructions32.Movzx();
                break;
            case 0xBE:
                // MOVSX r16, r/m8
                // MOVSX r32, r/m8
                _instructions16Or32.MovsxByte();
                break;
            case 0xBF:
                // MOVSX r32, r/m16
                _instructions32.Movsx();
                break;
            default:
                HandleInvalidOpcode(subcode);
                break;
        }
    }

    private void ExecOpcode(byte opcode) {
        switch (opcode) {
            case 0x00:
                _instructions8.AddRmReg();
                break;
            case 0x01:
                _instructions16Or32.AddRmReg();
                break;
            case 0x02:
                _instructions8.AddRegRm();
                break;
            case 0x03:
                _instructions16Or32.AddRegRm();
                break;
            case 0x04:
                _instructions8.AddAccImm();
                break;
            case 0x05:
                _instructions16Or32.AddAccImm();
                break;
            case 0x06:
                // PUSH ES
                Stack.Push16(State.ES);
                break;
            case 0x07:
                // POP ES
                State.ES = Stack.Pop16();
                break;
            case 0x08:
                _instructions8.OrRmReg();
                break;
            case 0x09:
                _instructions16Or32.OrRmReg();
                break;
            case 0x0A:
                _instructions8.OrRegRm();
                break;
            case 0x0B:
                _instructions16Or32.OrRegRm();
                break;
            case 0x0C:
                _instructions8.OrAccImm();
                break;
            case 0x0D:
                _instructions16Or32.OrAccImm();
                break;
            case 0x0E:
                // PUSH CS
                Stack.Push16(State.CS);
                break;
            case 0x0F:
                ExecSubOpcode(NextUint8());
                break;
            case 0x10:
                _instructions8.AdcRmReg();
                break;
            case 0x11:
                _instructions16Or32.AdcRmReg();
                break;
            case 0x12:
                _instructions8.AdcRegRm();
                break;
            case 0x13:
                _instructions16Or32.AdcRegRm();
                break;
            case 0x14:
                _instructions8.AdcAccImm();
                break;
            case 0x15:
                _instructions16Or32.AdcAccImm();
                break;
            case 0x16:
                // PUSH SS
                Stack.Push16(State.SS);
                break;
            case 0x17:
                // POP SS
                State.SS = Stack.Pop16();
                break;
            case 0x18:
                _instructions8.SbbRmReg();
                break;
            case 0x19:
                _instructions16Or32.SbbRmReg();
                break;
            case 0x1A:
                _instructions8.SbbRegRm();
                break;
            case 0x1B:
                _instructions16Or32.SbbRegRm();
                break;
            case 0x1C:
                _instructions8.SbbAccImm();
                break;
            case 0x1D:
                _instructions16Or32.SbbAccImm();
                break;
            case 0x1E:
                // PUSH DS
                Stack.Push16(State.DS);
                break;
            case 0x1F:
                // POP DS
                State.DS = Stack.Pop16();
                break;
            case 0x20:
                _instructions8.AndRmReg();
                break;
            case 0x21:
                _instructions16Or32.AndRmReg();
                break;
            case 0x22:
                _instructions8.AndRegRm();
                break;
            case 0x23:
                _instructions16Or32.AndRegRm();
                break;
            case 0x24:
                _instructions8.AndAccImm();
                break;
            case 0x25:
                _instructions16Or32.AndAccImm();
                break;
            case 0x26:
                HandleInvalidOpcodeBecausePrefix(opcode);
                break;
            case 0x27:
                Daa();
                break;
            case 0x28:
                _instructions8.SubRmReg();
                break;
            case 0x29:
                _instructions16Or32.SubRmReg();
                break;
            case 0x2A:
                _instructions8.SubRegRm();
                break;
            case 0x2B:
                _instructions16Or32.SubRegRm();
                break;
            case 0x2C:
                _instructions8.SubAccImm();
                break;
            case 0x2D:
                _instructions16Or32.SubAccImm();
                break;
            case 0x2E:
                HandleInvalidOpcodeBecausePrefix(opcode);
                break;
            case 0x2F:
                Das();
                break;
            case 0x30:
                _instructions8.XorRmReg();
                break;
            case 0x31:
                _instructions16Or32.XorRmReg();
                break;
            case 0x32:
                _instructions8.XorRegRm();
                break;
            case 0x33:
                _instructions16Or32.XorRegRm();
                break;
            case 0x34:
                _instructions8.XorAccImm();
                break;
            case 0x35:
                _instructions16Or32.XorAccImm();
                break;
            case 0x36:
                HandleInvalidOpcodeBecausePrefix(opcode);
                break;
            case 0x37:
                Aaa();
                break;
            case 0x38:
                _instructions8.CmpRmReg();
                break;
            case 0x39:
                _instructions16Or32.CmpRmReg();
                break;
            case 0x3A:
                _instructions8.CmpRegRm();
                break;
            case 0x3B:
                _instructions16Or32.CmpRegRm();
                break;
            case 0x3C:
                _instructions8.CmpAccImm();
                break;
            case 0x3D:
                _instructions16Or32.CmpAccImm();
                break;
            case 0x3E:
                HandleInvalidOpcodeBecausePrefix(opcode);
                break;
            case 0x3F:
                Aas();
                break;
            case 0x40:
            case 0x41:
            case 0x42:
            case 0x43:
            case 0x44:
            case 0x45:
            case 0x46:
            case 0x47:
                _instructions16Or32.IncReg(opcode & RegIndexMask);
                break;
            case 0x48:
            case 0x49:
            case 0x4A:
            case 0x4B:
            case 0x4C:
            case 0x4D:
            case 0x4E:
            case 0x4F:
                _instructions16Or32.DecReg(opcode & RegIndexMask);
                break;
            case 0x50:
            case 0x51:
            case 0x52:
            case 0x53:
            case 0x54:
            case 0x55:
            case 0x56:
            case 0x57:
                _instructions16Or32.PushReg(opcode & RegIndexMask);
                break;
            case 0x58:
            case 0x59:
            case 0x5A:
            case 0x5B:
            case 0x5C:
            case 0x5D:
            case 0x5E:
            case 0x5F:
                _instructions16Or32.PopReg(opcode & RegIndexMask);
                break;
            case 0x60:
                _instructions16Or32.Pusha();
                break;
            case 0x61:
                _instructions16Or32.Popa();
                break;
            case 0x62:// BOUND
            case 0x63:// ARPL
                HandleInvalidOpcode(opcode);
                break;
            case 0x64:
            case 0x65:
            case 0x66:
            case 0x67:
                HandleInvalidOpcodeBecausePrefix(opcode);
                break;
            case 0x68:
                _instructions16Or32.PushImm();
                break;
            case 0x69:
                _instructions16Or32.ImulRmImm16Or32();
                break;
            case 0x6A:
                _instructions16Or32.PushImm8SignExtended();
                break;
            case 0x6B:
                _instructions16Or32.ImulRmImm8();
                break;
            case 0x6C:
                _instructions8.Ins();
                break;
            case 0x6D:
                _instructions16Or32.Ins();
                break;
            case 0x6E:
                _instructions8.Outs();
                break;
            case 0x6F:
                _instructions16Or32.Outs();
                break;
            case 0x70:
            case 0x71:
            case 0x72:
            case 0x73:
            case 0x74:
            case 0x75:
            case 0x76:
            case 0x77:
            case 0x78:
            case 0x79:
            case 0x7A:
            case 0x7B:
            case 0x7C:
            case 0x7D:
            case 0x7E:
            case 0x7F:
                Jcc(TestJumpCondition(opcode));
                break;
            case 0x80:
                _instructions8.Grp1();
                break;
            case 0x81:
                _instructions16Or32.Grp1(false);
                break;
            case 0x82:
                _instructions8.Grp1();
                break;
            case 0x83:
                _instructions16Or32.Grp1(true);
                break;
            case 0x84:
                _instructions8.TestRmReg();
                break;
            case 0x85:
                _instructions16Or32.TestRmReg();
                break;
            case 0x86:
                _instructions8.XchgRm();
                break;
            case 0x87:
                _instructions16Or32.XchgRm();
                break;
            case 0x88:
                _instructions8.MovRmReg();
                break;
            case 0x89:
                _instructions16Or32.MovRmReg();
                break;
            case 0x8A:
                _instructions8.MovRegRm();
                break;
            case 0x8B:
                _instructions16Or32.MovRegRm();
                break;
            case 0x8C:
                _instructions16Or32.MovRmSreg();
                break;
            case 0x8D:
                _instructions16Or32.Lea();
                break;
            case 0x8E:
                // Only available in 16 bits
                _instructions16.MovSregRm();
                break;
            case 0x8F:
                _instructions16Or32.PopRm();
                break;
            case 0x90:
                // NOP
                break;
            case 0x91:
            case 0x92:
            case 0x93:
            case 0x94:
            case 0x95:
            case 0x96:
            case 0x97:
                _instructions16Or32.XchgAcc(opcode & RegIndexMask);
                break;
            case 0x98:
                _instructions16Or32.Cbw();
                break;
            case 0x99:
                _instructions16Or32.Cwd();
                break;
            case 0x9A: {
                ushort ip = NextUint16();
                ushort cs = NextUint16();
                FarCall(State.CS, _internalIp, cs, ip);
                break;
            }
            // Do nothing, this is to wait for the FPU which is not implemented
            case 0x9B:
                // WAIT FPU
                break;
            case 0x9C:
                _instructions16Or32.Pushf();
                break;
            case 0x9D:
                _instructions16Or32.Popf();
                break;
            case 0x9E:
                _instructions8.Sahf();
                break;
            case 0x9F:
                _instructions8.Lahf();
                break;
            case 0xA0:
                _instructions8.MovAccMoffs();
                break;
            case 0xA1:
                _instructions16Or32.MovAccMoffs();
                break;
            case 0xA2:
                _instructions8.MovMoffsAcc();
                break;
            case 0xA3:
                _instructions16Or32.MovMoffsAcc();
                break;
            case 0xA4:
                _instructions8.Movs();
                break;
            case 0xA5:
                _instructions16Or32.Movs();
                break;
            case 0xA6:
                _instructions8.Cmps();
                break;
            case 0xA7:
                _instructions16Or32.Cmps();
                break;
            case 0xA8:
                _instructions8.TestAccImm();
                break;
            case 0xA9:
                _instructions16Or32.TestAccImm();
                break;
            case 0xAA:
                _instructions8.Stos();
                break;
            case 0xAB:
                _instructions16Or32.Stos();
                break;
            case 0xAC:
                _instructions8.Lods();
                break;
            case 0xAD:
                _instructions16Or32.Lods();
                break;
            case 0xAE:
                _instructions8.Scas();
                break;
            case 0xAF:
                _instructions16Or32.Scas();
                break;
            case 0xB0:
            case 0xB1:
            case 0xB2:
            case 0xB3:
            case 0xB4:
            case 0xB5:
            case 0xB6:
            case 0xB7:
                _instructions8.MovRegImm(opcode & RegIndexMask);
                break;
            case 0xB8:
            case 0xB9:
            case 0xBA:
            case 0xBB:
            case 0xBC:
            case 0xBD:
            case 0xBE:
            case 0xBF:
                _instructions16Or32.MovRegImm(opcode & RegIndexMask);
                break;
            case 0xC0:
                _instructions8.Grp2(Grp2CountSource.NextUint8);
                break;
            case 0xC1:
                _instructions16Or32.Grp2(Grp2CountSource.NextUint8);
                break;
            case 0xC2:
                // RET imm16 (numberOfBytesToPop)
                NearRet(NextUint16());
                break;
            case 0xC3:
                // RET
                NearRet(0);
                break;
            case 0xC4:
                _instructions16Or32.Les();
                break;
            case 0xC5:
                _instructions16Or32.Lds();
                break;
            case 0xC6:
                _instructions8.MovRmImm();
                break;
            case 0xC7:
                _instructions16Or32.MovRmImm();
                break;
            case 0xC8: //ENTER
                _instructions16Or32.Enter();
                break;
            case 0xC9: //LEAVE
                _instructions16Or32.Leave();
                break;
            case 0xCA:
                // RETF and pop imm16 (numberOfBytesToPop)
                FarRet(NextUint16());
                break;
            case 0xCB:
                // RETF
                FarRet(0);
                break;
            case 0xCC:
                // INT 3
                Interrupt(3, false);
                break;
            case 0xCD:
                // INT ib
                Interrupt(NextUint8(), false);
                break;
            case 0xCE:
                // INTO
                if (State.OverflowFlag) {
                    Interrupt(4, false);
                }
                break;
            case 0xCF:
                // IRET
                InterruptRet();
                break;
            case 0xD0:
                _instructions8.Grp2(Grp2CountSource.One);
                break;
            case 0xD1:
                _instructions16Or32.Grp2(Grp2CountSource.One);
                break;
            case 0xD2:
                _instructions8.Grp2(Grp2CountSource.CL);
                break;
            case 0xD3:
                _instructions16Or32.Grp2(Grp2CountSource.CL);
                break;

            case 0xD4:
                // AAM ib
                Aam(NextUint8());
                break;
            case 0xD5:
                // AAD ib
                Aad(NextUint8());
                break;
            case 0xD6:
                _instructions8.Salc();
                break;
            case 0xD7:
                _instructions8.Xlat();
                break;
            case 0xD8:
                // FPU stuff
                HandleInvalidOpcode(opcode);
                break;
            case 0xD9: {
                _modRM.Read();
                int groupIndex = _modRM.RegisterIndex;
                switch (groupIndex) {
                    case 0x7: {
                        // FNSTCW
                        // Set the control word to the value expected after init since FPU is not supported.
                        _modRM.SetRm16(0x37F);

                        break;
                    }
                    default: throw new InvalidGroupIndexException(_machine, groupIndex);
                }
                break;
            }
            case 0xDA:
                // FPU stuff
                HandleInvalidOpcode(opcode);
                break;
            case 0xDB: {
                byte opCodeNextByte = NextUint8();
                if (opCodeNextByte != 0xE3) {
                    ushort fullOpCode = (ushort)(opcode << 8 | opCodeNextByte);
                    HandleInvalidOpcode(fullOpCode);
                }
                // FNINIT
                // Do nothing, no FPU emulation, but this is used to detect FPU
                break;
            }
            case 0xDC:
                // FPU stuff
                HandleInvalidOpcode(opcode);
                break;
            case 0xDD: {
                _modRM.Read();
                int groupIndex = _modRM.RegisterIndex;
                switch (groupIndex) {
                    case 0x7:
                        // FNSTSW
                        // Set non zero, means no FPU installed when called after FNINIT.
                        _modRM.SetRm16(0xFF);
                        break;
                    default:
                        throw new InvalidGroupIndexException(_machine, groupIndex);
                }
                break;
            }
            case 0xDE:
            case 0xDF:
                // FPU stuff
                HandleInvalidOpcode(opcode);
                break;
            case 0xE0:
            case 0xE1: {
                    // zeroFlag==true => LOOPZ
                    // zeroFlag==false =>  LOOPNZ
                    bool zeroFlag = (opcode & 0x1) == 1;
                    sbyte address = (sbyte)NextUint8();
                    bool done = AddressSize switch {
                        16 => --State.CX == 0,
                        32 => --State.ECX == 0,
                        _ => throw new InvalidOperationException($"Invalid address size: {AddressSize}")

                    };
                    if (!done && State.ZeroFlag == zeroFlag) {
                        ushort targetIp = (ushort)(_internalIp + address);
                        ExecutionFlowRecorder.RegisterJump(State.CS, State.IP, State.CS, targetIp);
                        _internalIp = targetIp;
                    }

                    break;
                }
            case 0xE2: {
                    // LOOP
                    sbyte address = (sbyte)NextUint8();
                    bool done = AddressSize switch {
                        16 => --State.CX == 0,
                        32 => --State.ECX == 0,
                        _ => throw new InvalidOperationException($"Invalid address size: {AddressSize}")
                    };

                    if (!done) {
                        ushort targetIp = (ushort)(_internalIp + address);
                        ExecutionFlowRecorder.RegisterJump(State.CS, State.IP, State.CS, targetIp);
                        _internalIp = targetIp;
                    }

                    break;
                }
            case 0xE3: // JCXZ, JECXZ
                Jcc(TestJumpConditionCXZ());
                break;
            case 0xE4:
                _instructions8.InImm8();
                break;
            case 0xE5:
                _instructions16Or32.InImm8();
                break;
            case 0xE6:
                _instructions8.OutImm8();
                break;
            case 0xE7:
                _instructions16Or32.OutImm8();
                break;
            case 0xE8: {
                    // CALL NEAR
                    ushort nextInstruction = (ushort)(_internalIp + 2);
                    short offset = (short)NextUint16();
                    ushort callAddress = (ushort)(nextInstruction + offset);
                    NearCall(nextInstruction, callAddress);
                    break;
                }
            case 0xE9: {
                    short offset = (short)NextUint16();
                    JumpNear((ushort)(_internalIp + offset));
                    break;
                }
            case 0xEA: {
                    ushort ip = NextUint16();
                    ushort cs = NextUint16();
                    JumpFar(cs, ip);
                    break;
                }
            case 0xEB: {
                    sbyte offset = (sbyte)NextUint8();
                    JumpNear((ushort)(_internalIp + offset));
                    break;
                }
            case 0xEC:
                _instructions8.InDx();
                break;
            case 0xED:
                _instructions16Or32.InDx();
                break;
            case 0xEE:
                _instructions8.OutDx();
                break;
            case 0xEF:
                _instructions16Or32.OutDx();
                break;
            case 0xF0: // LOCK
                HandleInvalidOpcodeBecausePrefix(opcode);
                break;
            case 0xF1:
                HandleInvalidOpcode(opcode);
                break;
            case 0xF2:
            case 0xF3:
                HandleInvalidOpcodeBecausePrefix(opcode);
                break;
            case 0xF4:
                // HLT
                _loggerService.Information("HLT instruction encountered, halting!");
                IsRunning = false;
                break;
            case 0xF5:
                // CMC
                State.CarryFlag = !State.CarryFlag;
                break;
            case 0xF6:
                _instructions8.Grp3();
                break;
            case 0xF7:
                _instructions16Or32.Grp3();
                break;
            case 0xF8:
                // CLC
                State.CarryFlag = false;
                break;
            case 0xF9:
                // STC
                State.CarryFlag = true;
                break;
            case 0xFA:
                // CLI
                State.InterruptFlag = false;
                break;
            case 0xFB:
                // STI
                State.InterruptFlag = true;
                break;
            case 0xFC:
                // CLD
                State.DirectionFlag = false;
                break;
            case 0xFD:
                // STD
                State.DirectionFlag = true;
                break;
            case 0xFE:
                _instructions8.Grp4();
                break;

            case 0xFF: // GRP5 rmw
                _instructions16Or32.Grp5();
                break;
        }
    }

    public void Aam(byte v2) {
        byte v1 = State.AL;
        if (v2 == 0) {
            throw new CpuDivisionErrorException("Division by zero");
        }

        byte result = (byte)(v1 % v2);
        State.AH = (byte)(v1 / v2);
        State.AL = result;
        Alu.UpdateFlags8(result);
    }

    public void Aad(byte v2) {
        byte result = (byte)(State.AL + (State.AH * v2));
        State.AL = result;
        State.AH = 0;
        State.Flags.FlagRegister = 0;
        Alu.UpdateFlags8(result);
    }

    public void Aas() {
        bool finalAuxillaryFlag = false;
        bool finalCarryFlag = false;
        if ((State.AL & 0x0F) > 9 || State.AuxiliaryFlag) {
            State.AX = (ushort)(State.AX - 6);
            State.AH = (byte)(State.AH - 1);
            finalAuxillaryFlag = true;
            finalCarryFlag = true;
        }

        State.AL = (byte)(State.AL & 0x0F);
        // Undocumented behaviour
        Alu.UpdateFlags8(State.AL);
        State.AuxiliaryFlag = finalAuxillaryFlag;
        State.CarryFlag = finalCarryFlag;
    }

    public void Daa() {
        byte initialAL = State.AL;
        bool initialCF = State.CarryFlag;
        bool finalAuxillaryFlag = false;
        if ((State.AL & 0x0F) > 9 || State.AuxiliaryFlag) {
            State.AL = (byte)(State.AL + 6);
            finalAuxillaryFlag = true;
        }

        bool finalCarryFlag;
        if (initialAL > 0x99 || initialCF) {
            State.AL = (byte)(State.AL + 0x60);
            finalCarryFlag = true;
        } else {
            finalCarryFlag = false;
        }

        // Undocumented behaviour
        Alu.UpdateFlags8(State.AL);
        State.AuxiliaryFlag = finalAuxillaryFlag;
        State.CarryFlag = finalCarryFlag;
    }

    public void Das() {
        byte initialAL = State.AL;
        bool initialCF = State.CarryFlag;
        bool finalAuxillaryFlag = false;
        bool finalCarryFlag = false;
        State.CarryFlag = false;
        if ((State.AL & 0x0F) > 9 || State.AuxiliaryFlag) {
            State.AL = (byte)(State.AL - 6);
            finalCarryFlag = State.CarryFlag || initialCF;
            finalAuxillaryFlag = true;
        }

        if (initialAL > 0x99 || initialCF) {
            State.AL = (byte)(State.AL - 0x60);
            finalCarryFlag = true;
        }

        // Undocumented behaviour
        Alu.UpdateFlags8(State.AL);
        State.AuxiliaryFlag = finalAuxillaryFlag;
        State.CarryFlag = finalCarryFlag;
    }

    public void Aaa() {
        bool finalAuxillaryFlag = false;
        bool finalCarryFlag = false;
        if ((State.AL & 0x0F) > 9 || State.AuxiliaryFlag) {
            State.AX = (ushort)(State.AX + 0x106);
            finalAuxillaryFlag = true;
            finalCarryFlag = true;
        }

        State.AL = (byte)(State.AL & 0x0F);
        // Undocumented behaviour
        Alu.UpdateFlags8(State.AL);
        State.AuxiliaryFlag = finalAuxillaryFlag;
        State.CarryFlag = finalCarryFlag;
    }

    public void FarCallWithReturnIpNextInstruction(ushort targetCS, ushort targetIP) {
        FarCall(State.CS, _internalIp, targetCS, targetIP);
    }

    private void FarCall(ushort returnCS, ushort returnIP, ushort targetCS, ushort targetIP) {
        Stack.Push16(returnCS);
        Stack.Push16(returnIP);
        HandleCall(CallType.FAR, returnCS, returnIP, targetCS, targetIP);
    }

    private uint InternalIpPhysicalAddress => MemoryUtils.ToPhysicalAddress(State.CS, _internalIp);

    private void HandleCall(CallType callType, ushort returnCS, ushort returnIP, ushort targetCS, ushort targetIP) {
        ExecutionFlowRecorder.RegisterCall(State.CS, State.IP, targetCS, targetIP);
        State.CS = targetCS;
        // Setting it here as well for eventual overrides
        State.IP = targetIP;
        _internalIp = targetIP;
        FunctionHandlerInUse.Call(callType, targetCS, targetIP, returnCS, returnIP);
    }

    private void HandleExternalInterrupt() {
        if (!State.InterruptFlag) {
            return;
        }

        // Check the PIC in case this was not directly set by rewritten code
        ExternalInterruptVectorNumber ??= _machine.DualPic.ComputeVectorNumber();

        if (ExternalInterruptVectorNumber == null) {
            return;
        }

        Interrupt(ExternalInterruptVectorNumber, true);
        ExternalInterruptVectorNumber = null;
    }

    private void HandleInvalidOpcode(ushort opcode) =>
        throw new InvalidOpCodeException(_machine, opcode, false);

    private void HandleInvalidOpcodeBecausePrefix(byte opcode) =>
        throw new InvalidOpCodeException(_machine, opcode, true);

    private void HandleJump(ushort cs, ushort ip) {
        ExecutionFlowRecorder.RegisterJump(State.CS, State.IP, cs, ip);
        _internalIp = ip;
        State.CS = cs;
    }

    private void Interrupt(byte? vectorNumber, bool external) {
        if (vectorNumber == null) {
            return;
        }

        ushort targetIP = _memory.GetUint16((ushort)(4 * vectorNumber.Value));
        ushort targetCS = _memory.GetUint16((ushort)((4 * vectorNumber.Value) + 2));
        if (ErrorOnUninitializedInterruptHandler && targetCS == 0 && targetIP == 0) {
            throw new UnhandledOperationException(_machine,
                $"Int was called but vector was not initialized for vectorNumber={ConvertUtils.ToHex(vectorNumber.Value)}");
        }

        ushort returnCS = State.CS;
        ushort returnIP = _internalIp;

        Stack.Push16(State.Flags.FlagRegister16);
        Stack.Push16(returnCS);
        Stack.Push16(returnIP);
        State.InterruptFlag = false;
        _internalIp = targetIP;
        // Setting it here as well for eventual overrides
        State.IP = targetIP;
        State.CS = targetCS;
        bool recordReturn = true;
        if (external) {
            FunctionHandlerInUse = FunctionHandlerInExternalInterrupt;
            recordReturn = false;
        }
        FunctionHandlerInUse.Icall(CallType.INTERRUPT, targetCS, targetIP, returnCS, returnIP, vectorNumber.Value,
            recordReturn);
    }

    private static bool IsStringOpcode(int opcode) {
        return _stringOpCodes.Contains(opcode);
    }

    private bool TestJumpConditionCXZ() {
        // JCXZ. JECXZ
        return AddressSize switch {
            16 => State.CX == 0,
            32 => State.ECX == 0,
            _ => throw new InvalidOperationException($"Invalid address size: {AddressSize}")
        };
    }

    private bool TestJumpCondition(byte opcode) {
        int jumpCondition = opcode & 0xF;
        // Condition is encoded in the LSB except for JCXZ which is only available as primary opcode.
        return jumpCondition switch {
            // JO
            0x0 => State.OverflowFlag,
            // JNO
            0x1 => !State.OverflowFlag,
            // JB
            0x2 => State.CarryFlag,
            //JNB
            0x3 => !State.CarryFlag,
            // JZ
            0x4 => State.ZeroFlag,
            // JNZ
            0x5 => !State.ZeroFlag,
            // JBE
            0x6 => State.CarryFlag || State.ZeroFlag,
            // JA
            0x7 => !State.CarryFlag && !State.ZeroFlag,
            // JS
            0x8 => State.SignFlag,
            // JNS
            0x9 => !State.SignFlag,
            // JP
            0xA => State.ParityFlag,
            // JPO
            0xB => !State.ParityFlag,
            // JL
            0xC => State.SignFlag != State.OverflowFlag,
            // JGE
            0xD => State.SignFlag == State.OverflowFlag,
            // JNG
            0xE => State.ZeroFlag || State.SignFlag != State.OverflowFlag,
            // JG
            0xF => !State.ZeroFlag && State.SignFlag == State.OverflowFlag,
            _ => throw new InvalidOpCodeException(_machine, opcode, false)
        };
    }

    /// <summary>
    /// Jumps handling
    /// </summary>
    private void Jcc(bool jump, int offsetSize = 8) {
        int address = offsetSize switch {
            8 => (sbyte)NextUint8(),
            16 => (short)NextUint16(),
            32 => (int)NextUint32(),
            _ => throw new ArgumentOutOfRangeException(nameof(offsetSize), offsetSize, null)
        };

        if (jump) {
            HandleJump(State.CS, (ushort)(_internalIp + address));
        }
    }

    public void JumpFar(ushort cs, ushort ip) {
        HandleJump(cs, ip);
    }

    public void JumpNear(ushort ip) {
        HandleJump(State.CS, ip);
    }

    public void NearCallWithReturnIpNextInstruction(ushort callIP) {
        NearCall(_internalIp, callIP);
    }
    private void NearCall(ushort returnIP, ushort callIP) {
        Stack.Push16(returnIP);
        HandleCall(CallType.NEAR, State.CS, returnIP, State.CS, callIP);
    }

    public byte In8(int port) {
        if (IoPortDispatcher != null) {
            return IoPortDispatcher.ReadByte((ushort)port);
        }
        return 0;
    }

    public ushort In16(int port) {
        if (IoPortDispatcher != null) {
            return IoPortDispatcher.ReadWord((ushort)port);
        }
        return 0;
    }

    public uint In32(int port) {
        if (IoPortDispatcher != null) {
            return IoPortDispatcher.ReadDWord((ushort)port);
        }
        return 0;
    }

    public void Out8(int port, byte val) => IoPortDispatcher?.WriteByte((ushort)port, val);

    public void Out16(int port, ushort val) => IoPortDispatcher?.WriteWord((ushort)port, val);

    public void Out32(int port, uint val) => IoPortDispatcher?.WriteDWord((ushort)port, val);

    private bool ProcessPrefix(int opcode) {
        switch (opcode) {
            case 0x26:
                // ES:
                State.SegmentOverrideIndex = SegmentRegisters.EsIndex;
                break;
            case 0x2E:
                // CS:
                State.SegmentOverrideIndex = SegmentRegisters.CsIndex;
                break;
            case 0x36:
                // SS:
                State.SegmentOverrideIndex = SegmentRegisters.SsIndex;
                break;
            case 0x3E:
                // DS:
                State.SegmentOverrideIndex = SegmentRegisters.DsIndex;
                break;
            case 0x64:
                // FS:
                State.SegmentOverrideIndex = SegmentRegisters.FsIndex;
                break;
            case 0x65:
                // GS
                State.SegmentOverrideIndex = SegmentRegisters.GsIndex;
                break;
            case 0x66:
                _instructions16Or32 = _instructions32;
                break;
            case 0x67:
                AddressSize = 32;
                break;
            case 0xF0:
                // LOCK
                break;
            case 0xF2:
                // REPNZ
                State.ContinueZeroFlagValue = false;
                break;
            case 0xF3:
                // REPZ
                State.ContinueZeroFlagValue = true;
                break;
            default:
                return false;
        }
        return true;
    }

    private byte ProcessPrefixes() {
        byte opcode = NextUint8();
        while (ProcessPrefix(opcode)) {
            opcode = NextUint8();
        }
        return opcode;
    }

    private void ProcessRep(byte opcode) {
        // repeat while zero flag is false for REPNZ (last bit is 0)
        // or while zero flag is true for REPZ (last bit is 1)
        bool? continueZeroFlagValue = State.ContinueZeroFlagValue;
        // For some instructions, zero flag is not to be checked
        bool checkZeroFlag = IsStringOpUpdatingFlags(opcode);
        ushort cx = State.CX;
        while (cx != 0) {
            // re-set the segment override that may have been cleared. No need to reset ip
            // as string instructions don't modify it and are only one byte.
            // Here we are sure that the opcode is a string because otherwise ProcessRep would not have been called.
            ExecOpcode(opcode);
            cx--;
            // Not all the string operations require checking the zero flag...
            if (checkZeroFlag && State.ZeroFlag != continueZeroFlagValue) {
                break;
            }
        }
        State.CX = cx;
    }
}
