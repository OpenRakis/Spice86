namespace Ix86.Emulator.Cpu;

using Ix86.Emulator.Function;
using Ix86.Emulator.IOPorts;
using Ix86.Emulator.Machine;
using Ix86.Emulator.Memory;

using System;
using System.Collections.Generic;

/// <summary>
/// Implementation of a 8086 CPU. <br /> It has some 80186, 80286 and 80386 instructions as some
/// program use them. <br /> It also has some x87 FPU instructions to support telling the programs
/// that x87 is not supported :) <br /> Some docs that helped the implementation: <ul> <li>
/// Instructions decoding: http://rubbermallet.org/8086%20notes.pdf and
/// http://ref.x86asm.net/coder32.html </li><li> Instructions implementation details:
/// https://www.felixcloutier.com/x86/ </li><li> Pure 8086 instructions:
/// https://jbwyatt.com/253/emu/8086_instruction_set.html </li></ul>
/// TODO: Complete it !
/// </summary>
public class Cpu
{
    private readonly State _state = new();
    private readonly Memory _memory;
    private readonly Stack _stack;
    //private static readonly ILogger<Cpu> _logger = LoggerFactory.CreateLogger(nameof(Cpu));

    public Cpu(Machine machine, bool debugMode)
    {
        _state = new();
        _memory = machine.GetMemory();
        _stack = new(_memory, _state);
    }

    public State GetState()
    {
        return _state;
    }

    internal Stack GetStack()
    {
        return _stack;
    }

    internal void NearRet(int v)
    {
        throw new NotImplementedException();
    }

    internal void FarRet(int v)
    {
        throw new NotImplementedException();
    }

    internal void InterruptRet()
    {
        throw new NotImplementedException();
    }

    internal StaticAddressesRecorder GetStaticAddressesRecorder()
    {
        throw new NotImplementedException();
    }
}
//        Arrays.asList(0x26, 0x2E, 0x36, 0x3E, 0x64, 0x65, 0xF0, 0xF2, 0xF3));

//    // Extract regIndex from opcode
//    private const int REG_INDEX_MASK = 0b111;

//    private const Set<int> STRING_OPCODES =
//        new HashSet<>(Arrays.asList(0xA4, 0xA5, 0xA6, 0xA7, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF, 0x6C, 0x6D, 0x6E, 0x6F));

//    private Alu alu;

//    private CallbackHandler callbackHandler;

//    // When true will crash if an interrupt targets code at 0000:0000
//    private bool errorOnUninitializedInterruptHandler;

//    // interrupt not generated by the code
//    private int externalInterruptVectorNumber;

//    private Boolean forceLog;

//    private FunctionHandler functionHandler;

//    private FunctionHandler functionHandlerInExternalInterrupt;

//    // Not the same depending on whether we are processing an external interrupt or not (call stack
//    // is not the same)
//    private FunctionHandler functionHandlerInUse;

//    // Value used to read parts of the instruction. CPU uses this internally and adjusts IP after
//    // instruction execution is done.
//    private int internalIp;

//    private IOPortDispatcher ioPortDispatcher;

//    private Machine machine;

//    private Memory memory;

//    private ModRM modRM;

//    private bool running = true;

//    private Stack stack;

//    private State state;

//    private String stateString = "";

//    private StaticAddressesRecorder staticAddressesRecorder;

//    public Cpu(Machine machine, bool debugMode)
//    {
//        this.machine = machine;
//        this.memory = machine.getMemory();
//        this.state = new State();
//        this.alu = new Alu(state);
//        this.stack = new Stack(memory, state);
//        this.functionHandler = new FunctionHandler(machine, debugMode);
//        this.functionHandlerInExternalInterrupt = new FunctionHandler(machine, debugMode);
//        this.functionHandlerInUse = functionHandler;
//        this.staticAddressesRecorder = new StaticAddressesRecorder(state, debugMode);
//        this.modRM = new ModRM(machine, this);
//    }

//    private throws InvalidOperationException
//    {
//        internalIp = state.getIP


//public void executeNextInstruction()


//public void externalInterrupt(int vectorNumber)
//    {
//        // hack: do not let the timer overwrite keyboard.
//        if (this.externalInterruptVectorNumber == null || this.externalInterruptVectorNumber != 9)
//        {
//            this.externalInterruptVectorNumber = vectorNumber;
//        }
//    }

//    public Alu getAlu()
//    {
//        return alu;
//    }

//    public FunctionHandler getFunctionHandler()
//    {
//        return this.functionHandler;
//    }

//    public FunctionHandler getFunctionHandlerInExternalInterrupt()
//    {
//        return functionHandlerInExternalInterrupt;
//    }

//    public FunctionHandler getFunctionHandlerInUse()
//    {
//        return functionHandlerInUse;
//    }

//    public Stack getStack()
//    {
//        return stack;
//    }

//    public State getState()
//    {
//        return state;
//    }

//    public StaticAddressesRecorder getStaticAddressesRecorder()
//    {
//        return staticAddressesRecorder;
//    }

//    public bool isRunning()
//    {
//        return running;
//    }

//    public void setCallbackHandler(CallbackHandler callbackHandler)
//    {
//        this.callbackHandler = callbackHandler;
//    }

//    public void setErrorOnUninitializedInterruptHandler(bool errorOnUninitializedInterruptHandler)
//    {
//        this.errorOnUninitializedInterruptHandler = errorOnUninitializedInterruptHandler;
//    }

//    public void setForceLog(bool forceLog)
//    {
//        this.forceLog = forceLog;
//    }

//    public void setIoPortDispatcher(IOPortDispatcher ioPortDispatcher)
//    {
//        this.ioPortDispatcher = ioPortDispatcher;
//    }

//    public void setRunning(bool running)
//    {
//        this.running = running;
//    }

//    private void addCurrentInstructionPrefix(Supplier<String> getLog)
//    {
//        // Optimization, do not calculate the log if it is not used
//        if (isLoggingEnabled())
//        {
//            state.addCurrentInstructionPrefix(getLog.get());
//        }
//    }

//    private bool isLoggingEnabled()
//    {
//        if (forceLog == null)
//        {
//            return LOGGER.isDebugEnabled();
//        }
//        return forceLog;
//    }

//    private void setCurrentInstructionName(Supplier<String> getLog)
//    {
//        // Optimization, do not calculate the log if it is not used
//        if (isLoggingEnabled())
//        {
//            state.setCurrentInstructionName(getLog.get());
//        }
//    }

//    private class);

//    ();
//    staticAddressesRecorder.reset();
//    if (isLoggingEnabled()) {
//      stateString = state.toString();
//      state.resetCurrentInstructionPrefix();
//      state.setCurrentInstructionName("");
//    }

//int opcode = processPrefixes();
//    if (isLoggingEnabled()) {
//      LOGGER.debug("Before execution: opcode {} {} ", ConvertUtils.toHex8(opcode),
//          stateString);
//    }
//    if (state.getContinueZeroFlagValue() != null && isStringOpcode(opcode))
//{
//    // continueZeroFlag is either true or false if a rep prefix has been encountered
//    processRep(opcode);
//}
//else
//{
//    execOpcode(opcode);
//}
//if (isLoggingEnabled())
//{
//    String instructionName = state.getCurrentInstructionNameWithPrefix();
//    LOGGER.debug("After execution of {} {}", instructionName, state);
//}
//state.clearPrefixes();
//staticAddressesRecorder.commit();
//state.incCycles();
//handleExternalInterrupt();
//state.setIP(internalIp);
//  }

//  private void handleExternalInterrupt() throws InvalidOperationException
//{
//    if (externalInterruptVectorNumber == null || !state.getInterruptFlag()) {
//        return;
//    }
//    if (isLoggingEnabled()) {
//        LOGGER.debug("Interrupted!, int {}", externalInterruptVectorNumber);
//    }
//    interrupt(externalInterruptVectorNumber, true);
//    externalInterruptVectorNumber = null;
//}

//private void processRep(int opcode) throws InvalidOperationException
//{
//    // repeat while zero flag is false for REPNZ (last bit is 0) or while zero flag is true for REPZ
//    // (last bit is 1)
//    bool continueZeroFlagValue = state.getContinueZeroFlagValue();

//    // For some instructions, zero flag is not to be checked
//    bool checkZeroFlag = isStringOpUpdatingFlags(opcode);
//    int cx = state.getCX();
//    while (cx != 0) {

//        // re-set the segment override that may have been cleared. No need to reset ip as string
//        // instructions don't modify it and are only one byte.
//        processString(opcode);
//        cx = cx - 1;

//        if (LOGGER.isTraceEnabled())
//        {
//            LOGGER.trace("REP {} Loop, CX={}, ZF={}, checkZeroFlag={}, continueZF={}",
//                state.getCurrentInstructionNameWithPrefix(),
//                ConvertUtils.toHex(cx), state.getZeroFlag(), checkZeroFlag, continueZeroFlagValue);
//        }

//        // Not all the string operations require checking the zero flag...
//        if (checkZeroFlag && state.getZeroFlag() != continueZeroFlagValue)
//        {
//            break;
//        }
//    }
//    state.setCX(cx);
//}

//private int processPrefixes() throws InvalidOperationException
//{
//    int opcode = nextUint8();
//    while (isPrefix(opcode)) {
//        processPrefix(opcode);
//        opcode = nextUint8();
//    }
//    return opcode;
//}

//private void processPrefix(int opcode) throws InvalidOperationException
//{
//    switch (opcode) {
//      case 0x26-> {
//            addCurrentInstructionPrefix(()-> "ES:");
//            state.setSegmentOverrideIndex(SegmentRegisters.ES_INDEX);
//        }
//      case 0x2E-> {
//            addCurrentInstructionPrefix(()-> "CS:");
//            state.setSegmentOverrideIndex(SegmentRegisters.CS_INDEX);
//        }
//      case 0x36-> {
//            addCurrentInstructionPrefix(()-> "SS:");
//            state.setSegmentOverrideIndex(SegmentRegisters.SS_INDEX);
//        }
//      case 0x3E-> {
//            addCurrentInstructionPrefix(()-> "DS:");
//            state.setSegmentOverrideIndex(SegmentRegisters.DS_INDEX);
//        }
//      case 0x64-> {
//            addCurrentInstructionPrefix(()-> "FS:");
//            state.setSegmentOverrideIndex(SegmentRegisters.FS_INDEX);
//        }
//      case 0x65-> {
//            addCurrentInstructionPrefix(()-> "GS:");
//            state.setSegmentOverrideIndex(SegmentRegisters.GS_INDEX);
//        }
//      case 0xF0->addCurrentInstructionPrefix(()-> "LOCK");
//      case 0xF2, 0xF3-> { // REPNZ, REPZ
//            bool continueZeroFlagValue = (opcode & 1) == 1;
//            state.setContinueZeroFlagValue(continueZeroFlagValue);
//            addCurrentInstructionPrefix(()-> "REP" + (continueZeroFlagValue ? "Z" : ""));
//        }
//        default-> throw new InvalidOperationException(machine,
//           "processPrefix Called with a non prefix opcode " + opcode);
//    }
//}

//private void execOpcode(int opcode) throws InvalidOperationException
//{
//    switch (opcode) {
//      case 0x00-> {
//            setCurrentInstructionName(()-> "ADD rmb rb");
//            modRM.read();
//            modRM.setRm8(alu.add8(modRM.getRm8(), modRM.getR8()));
//        }
//      case 0x01-> {
//            setCurrentInstructionName(()-> "ADD rmw rw");
//            modRM.read();
//            modRM.setRm16(alu.add16(modRM.getRm16(), modRM.getR16()));
//        }
//      case 0x02-> {
//            setCurrentInstructionName(()-> "ADD rb rmb");
//            modRM.read();
//            modRM.setR8(alu.add8(modRM.getR8(), modRM.getRm8()));
//        }
//      case 0x03-> {
//            setCurrentInstructionName(()-> "ADD rw rmw");
//            modRM.read();
//            modRM.setR16(alu.add16(modRM.getR16(), modRM.getRm16()));
//        }
//      case 0x04-> {
//            setCurrentInstructionName(()-> "ADD AL ib");
//            state.setAL(alu.add8(state.getAL(), nextUint8()));
//        }
//      case 0x05-> {
//            setCurrentInstructionName(()-> "ADD AX iw");
//            state.setAX(alu.add16(state.getAX(), nextUint16()));
//        }
//      case 0x06-> {
//            setCurrentInstructionName(()-> "PUSH ES");
//            stack.push(state.getES());
//        }
//      case 0x07-> {
//            setCurrentInstructionName(()-> "POP ES");
//            state.setES(stack.pop());
//        }
//      case 0x08-> {
//            setCurrentInstructionName(()-> "OR rmb rb");
//            modRM.read();
//            modRM.setRm8(alu.or8(modRM.getRm8(), modRM.getR8()));
//        }
//      case 0x09-> {
//            setCurrentInstructionName(()-> "OR rmw rw");
//            modRM.read();
//            modRM.setRm16(alu.or16(modRM.getRm16(), modRM.getR16()));
//        }
//      case 0x0A-> {
//            setCurrentInstructionName(()-> "OR rb rmb");
//            modRM.read();
//            modRM.setR8(alu.or8(modRM.getR8(), modRM.getRm8()));
//        }
//      case 0x0B-> {
//            setCurrentInstructionName(()-> "OR rw rmw");
//            modRM.read();
//            modRM.setR16(alu.or16(modRM.getR16(), modRM.getRm16()));
//        }
//      case 0x0C-> {
//            setCurrentInstructionName(()-> "OR AL ib");
//            state.setAL(alu.or8(state.getAL(), nextUint8()));
//        }
//      case 0x0D-> {
//            setCurrentInstructionName(()-> "OR AX iw");
//            state.setAX(alu.or16(state.getAX(), nextUint16()));
//        }
//      case 0x0E-> {
//            setCurrentInstructionName(()-> "PUSH CS");
//            stack.push(state.getCS());
//        }
//      case 0x0F->handleInvalidOpcode(opcode);
//      case 0x10-> {
//            setCurrentInstructionName(()-> "ADC rmb rb");
//            modRM.read();
//            modRM.setRm8(alu.adc8(modRM.getRm8(), modRM.getR8()));
//        }
//      case 0x11-> {
//            setCurrentInstructionName(()-> "ADC rmw rw");
//            modRM.read();
//            modRM.setRm16(alu.adc16(modRM.getRm16(), modRM.getR16()));
//        }
//      case 0x12-> {
//            setCurrentInstructionName(()-> "ADC rb rmb");
//            modRM.read();
//            modRM.setR8(alu.adc8(modRM.getR8(), modRM.getRm8()));
//        }
//      case 0x13-> {
//            setCurrentInstructionName(()-> "ADC rw rmw");
//            modRM.read();
//            modRM.setR16(alu.adc16(modRM.getR16(), modRM.getRm16()));
//        }
//      case 0x14-> {
//            setCurrentInstructionName(()-> "ADC AL ib");
//            state.setAL(alu.adc8(state.getAL(), nextUint8()));
//        }
//      case 0x15-> {
//            setCurrentInstructionName(()-> "ADC AX iw");
//            state.setAX(alu.adc16(state.getAX(), nextUint16()));
//        }
//      case 0x16-> {
//            setCurrentInstructionName(()-> "PUSH SS");
//            stack.push(state.getSS());
//        }
//      case 0x17-> {
//            setCurrentInstructionName(()-> "POP SS");
//            state.setSS(stack.pop());
//        }
//      case 0x18-> {
//            setCurrentInstructionName(()-> "SBB rmb rb");
//            modRM.read();
//            modRM.setRm8(alu.sbb8(modRM.getRm8(), modRM.getR8()));
//        }
//      case 0x19-> {
//            setCurrentInstructionName(()-> "SBB rmw rw");
//            modRM.read();
//            modRM.setRm16(alu.sbb16(modRM.getRm16(), modRM.getR16()));
//        }
//      case 0x1A-> {
//            setCurrentInstructionName(()-> "SBB rb rmb");
//            modRM.read();
//            modRM.setR8(alu.sbb8(modRM.getR8(), modRM.getRm8()));
//        }
//      case 0x1B-> {
//            setCurrentInstructionName(()-> "SBB rw rmw");
//            modRM.read();
//            modRM.setR16(alu.sbb16(modRM.getR16(), modRM.getRm16()));
//        }
//      case 0x1C-> {
//            setCurrentInstructionName(()-> "SBB AL ib");
//            state.setAL(alu.sbb8(state.getAL(), nextUint8()));
//        }
//      case 0x1D-> {
//            setCurrentInstructionName(()-> "SBB AX iw");
//            state.setAX(alu.sbb16(state.getAX(), nextUint16()));
//        }
//      case 0x1E-> {
//            setCurrentInstructionName(()-> "PUSH DS");
//            stack.push(state.getDS());
//        }
//      case 0x1F-> {
//            setCurrentInstructionName(()-> "POP DS");
//            state.setDS(stack.pop());
//        }
//      case 0x20-> {
//            setCurrentInstructionName(()-> "AND rmb rb");
//            modRM.read();
//            modRM.setRm8(alu.and8(modRM.getRm8(), modRM.getR8()));
//        }
//      case 0x21-> {
//            setCurrentInstructionName(()-> "AND rmw rw");
//            modRM.read();
//            modRM.setRm16(alu.and16(modRM.getRm16(), modRM.getR16()));
//        }
//      case 0x22-> {
//            setCurrentInstructionName(()-> "AND rb rmb");
//            modRM.read();
//            modRM.setR8(alu.and8(modRM.getR8(), modRM.getRm8()));
//        }
//      case 0x23-> {
//            setCurrentInstructionName(()-> "AND rw rmw");
//            modRM.read();
//            modRM.setR16(alu.and16(modRM.getR16(), modRM.getRm16()));
//        }
//      case 0x24-> {
//            setCurrentInstructionName(()-> "AND AL ib");
//            state.setAL(alu.and8(state.getAL(), nextUint8()));
//        }
//      case 0x25-> {
//            setCurrentInstructionName(()-> "AND AX iw");
//            state.setAX(alu.and16(state.getAX(), nextUint16()));
//        }
//      case 0x26->handleInvalidOpcodeBecausePrefix(opcode);
//      case 0x27-> {
//            setCurrentInstructionName(()-> "DAA");
//            int initialAL = state.getAL();
//            bool initialCF = state.getCarryFlag();
//            bool finalAuxillaryFlag = false;
//            bool finalCarryFlag = false;
//            if ((state.getAL() & 0x0F) > 9 || state.getAuxiliaryFlag())
//            {
//                state.setAL(state.getAL() + 6);
//                finalAuxillaryFlag = true;
//            }

//            if (initialAL > 0x99 || initialCF)
//            {
//                state.setAL(state.getAL() + 0x60);
//                finalCarryFlag = true;
//            }
//            else
//            {
//                finalCarryFlag = false;
//            }

//            // Undocumented behaviour
//            alu.updateFlags8(state.getAL());
//            state.setAuxiliaryFlag(finalAuxillaryFlag);
//            state.setCarryFlag(finalCarryFlag);
//        }
//      case 0x28-> {
//            setCurrentInstructionName(()-> "SUB rmb rb");
//            modRM.read();
//            modRM.setRm8(alu.sub8(modRM.getRm8(), modRM.getR8()));
//        }
//      case 0x29-> {
//            setCurrentInstructionName(()-> "SUB rmw rw");
//            modRM.read();
//            modRM.setRm16(alu.sub16(modRM.getRm16(), modRM.getR16()));
//        }
//      case 0x2A-> {
//            setCurrentInstructionName(()-> "SUB rb rmb");
//            modRM.read();
//            modRM.setR8(alu.sub8(modRM.getR8(), modRM.getRm8()));
//        }
//      case 0x2B-> {
//            setCurrentInstructionName(()-> "SUB rw rmw");
//            modRM.read();
//            modRM.setR16(alu.sub16(modRM.getR16(), modRM.getRm16()));
//        }
//      case 0x2C-> {
//            setCurrentInstructionName(()-> "SUB AL ib");
//            state.setAL(alu.sub8(state.getAL(), nextUint8()));
//        }
//      case 0x2D-> {
//            setCurrentInstructionName(()-> "SUB AX iw");
//            state.setAX(alu.sub16(state.getAX(), nextUint16()));
//        }
//      case 0x2E->handleInvalidOpcodeBecausePrefix(opcode);
//      case 0x2F-> {
//            setCurrentInstructionName(()-> "DAS");
//            int initialAL = state.getAL();
//            bool initialCF = state.getCarryFlag();
//            bool finalAuxillaryFlag = false;
//            bool finalCarryFlag = false;
//            state.setCarryFlag(false);
//            if ((state.getAL() & 0x0F) > 9 || state.getAuxiliaryFlag())
//            {
//                state.setAL(state.getAL() - 6);
//                finalCarryFlag = state.getCarryFlag() || initialCF;
//                finalAuxillaryFlag = true;
//            }
//            if (initialAL > 0x99 || initialCF)
//            {
//                state.setAL(state.getAL() - 0x60);
//                finalCarryFlag = true;
//            }

//            // Undocumented behaviour
//            alu.updateFlags8(state.getAL());
//            state.setAuxiliaryFlag(finalAuxillaryFlag);
//            state.setCarryFlag(finalCarryFlag);
//        }
//      case 0x30-> {
//            setCurrentInstructionName(()-> "XOR rmb rb");
//            modRM.read();
//            modRM.setRm8(alu.xor8(modRM.getRm8(), modRM.getR8()));
//        }
//      case 0x31-> {
//            setCurrentInstructionName(()-> "XOR rmw rw");
//            modRM.read();
//            modRM.setRm16(alu.xor16(modRM.getRm16(), modRM.getR16()));
//        }
//      case 0x32-> {
//            setCurrentInstructionName(()-> "XOR rb rmb");
//            modRM.read();
//            modRM.setR8(alu.xor8(modRM.getR8(), modRM.getRm8()));
//        }
//      case 0x33-> {
//            setCurrentInstructionName(()-> "XOR rw rmw");
//            modRM.read();
//            modRM.setR16(alu.xor16(modRM.getR16(), modRM.getRm16()));
//        }
//      case 0x34-> {
//            setCurrentInstructionName(()-> "XOR AL mb");
//            state.setAL(alu.xor8(state.getAL(), nextUint8()));
//        }
//      case 0x35-> {
//            setCurrentInstructionName(()-> "XOR AX mw");
//            state.setAX(alu.xor16(state.getAX(), nextUint16()));
//        }
//      case 0x36->handleInvalidOpcodeBecausePrefix(opcode);
//      case 0x37-> {
//            setCurrentInstructionName(()-> "AAA");
//            bool finalAuxillaryFlag = false;
//            bool finalCarryFlag = false;
//            if ((state.getAL() & 0x0F) > 9 || state.getAuxiliaryFlag())
//            {
//                state.setAX(state.getAX() + 0x106);
//                finalAuxillaryFlag = true;
//                finalCarryFlag = true;
//            }
//            state.setAL(state.getAL() & 0x0F);

//            // Undocumented behaviour
//            alu.updateFlags8(state.getAL());
//            state.setAuxiliaryFlag(finalAuxillaryFlag);
//            state.setCarryFlag(finalCarryFlag);
//        }
//      case 0x38-> {
//            setCurrentInstructionName(()-> "CMP rmb rb");
//            modRM.read();
//            alu.sub8(modRM.getRm8(), modRM.getR8());
//        }
//      case 0x39-> {
//            setCurrentInstructionName(()-> "CMP rmw rw");
//            modRM.read();
//            alu.sub16(modRM.getRm16(), modRM.getR16());
//        }
//      case 0x3A-> {
//            setCurrentInstructionName(()-> "CMP rb rmb");
//            modRM.read();
//            alu.sub8(modRM.getR8(), modRM.getRm8());
//        }
//      case 0x3B-> {
//            setCurrentInstructionName(()-> "CMP rw rmw");
//            modRM.read();
//            alu.sub16(modRM.getR16(), modRM.getRm16());
//        }
//      case 0x3C-> {
//            setCurrentInstructionName(()-> "CMP AL ib");
//            alu.sub8(state.getAL(), nextUint8());
//        }
//      case 0x3D-> {
//            setCurrentInstructionName(()-> "CMP AX iw");
//            alu.sub16(state.getAX(), nextUint16());
//        }
//      case 0x3E->handleInvalidOpcodeBecausePrefix(opcode);
//      case 0x3F-> {
//            setCurrentInstructionName(()-> "AAS");
//            bool finalAuxillaryFlag = false;
//            bool finalCarryFlag = false;
//            if ((state.getAL() & 0x0F) > 9 || state.getAuxiliaryFlag())
//            {
//                state.setAX(state.getAX() - 6);
//                state.setAH(state.getAH() - 1);
//                finalAuxillaryFlag = true;
//                finalCarryFlag = true;
//            }
//            state.setAL(state.getAL() & 0x0F);

//            // Undocumented behaviour
//            alu.updateFlags8(state.getAL());
//            state.setAuxiliaryFlag(finalAuxillaryFlag);
//            state.setCarryFlag(finalCarryFlag);
//        }
//      case 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47-> {
//            int regIndex = opcode & REG_INDEX_MASK;
//            setCurrentInstructionName(()-> "INC " + state.getRegisters().getRegName(regIndex));
//            state.getRegisters().setRegister(regIndex, alu.inc16(state.getRegisters().getRegister(regIndex)));
//        }
//      case 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F-> {
//            int regIndex = opcode & REG_INDEX_MASK;
//            setCurrentInstructionName(()-> "DEC " + state.getRegisters().getRegName(regIndex));
//            state.getRegisters().setRegister(regIndex, alu.dec16(state.getRegisters().getRegister(regIndex)));
//        }
//      case 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57-> {
//            int regIndex = opcode & REG_INDEX_MASK;
//            setCurrentInstructionName(()-> "PUSH " + state.getRegisters().getRegName(regIndex));
//            stack.push(state.getRegisters().getRegister(regIndex));
//        }
//      case 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F-> {
//            int regIndex = opcode & REG_INDEX_MASK;
//            setCurrentInstructionName(()-> "POP " + state.getRegisters().getRegName(regIndex));
//            state.getRegisters().setRegister(regIndex, stack.pop());
//        }
//      case 0x60-> {

//            // 80186
//            setCurrentInstructionName(()-> "PUSHA");
//            int sp = state.getSP();
//            stack.push(state.getAX());
//            stack.push(state.getCX());
//            stack.push(state.getDX());
//            stack.push(state.getBX());
//            stack.push(sp);
//            stack.push(state.getBP());
//            stack.push(state.getSI());
//            stack.push(state.getDI());
//        }
//      case 0x61-> {

//            // 80186
//            setCurrentInstructionName(()-> "POPA");
//            state.setDI(stack.pop());
//            state.setSI(stack.pop());
//            state.setBP(stack.pop());

//            // not restoring SP
//            stack.pop();
//            state.setBX(stack.pop());
//            state.setDX(stack.pop());
//            state.setCX(stack.pop());
//            state.setAX(stack.pop());
//        }
//      case 0x62, 0x63, 0x64, 0x65, 0x66, 0x67->handleInvalidOpcode(opcode);
//      case 0x68-> {

//            // 80186
//            int value = this.nextUint16();
//            setCurrentInstructionName(()-> "PUSH " + ConvertUtils.toHex16(value));
//            stack.push(value);
//        }
//      case 0x69-> {
//            modRM.read();
//            int value = this.nextUint16();
//            setCurrentInstructionName(()-> "IMUL16 rm16 " + ConvertUtils.toHex16(value));
//            int result = alu.imul16(value, modRM.getRm16());
//            modRM.setR16(result);
//        }
//      case 0x6A-> {

//            // 80186 sign extend it to 16 bits
//            int value = uint16(int8(this.nextUint8()));
//            setCurrentInstructionName(()-> "PUSH " + ConvertUtils.toHex16(value));
//            stack.push(value);
//        }
//      case 0x6B-> {
//            modRM.read();
//            int value = int8(this.nextUint8());
//            setCurrentInstructionName(()-> "IMUL8 rm16 " + ConvertUtils.toHex16(value));
//            int result = alu.imul16(value, modRM.getRm16());
//            modRM.setR16(result);
//        }
//      case 0x6C, 0x6D, 0x6E, 0x6F-> // INSB, INSW, OUTSB, OUTSW
//        processString(opcode);
//      case 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F->jcc(
//          opcode);
//      case 0x80, // GRP1 rmb ib, GRP1 rmw iw, GRP1 rmb ib, GRP1 rmw ib
//      0x81, 0x82, 0x83->grp1(opcode);
//      case 0x84-> {
//            setCurrentInstructionName(()-> "TEST rmb rb");
//            modRM.read();
//            alu.and8(modRM.getRm8(), modRM.getR8());
//        }
//      case 0x85-> {
//            setCurrentInstructionName(()-> "TEST rmw rw");
//            modRM.read();
//            alu.and16(modRM.getRm16(), modRM.getR16());
//        }
//      case 0x86-> {
//            setCurrentInstructionName(()-> "XCHG8");
//            modRM.read();
//            int value1 = modRM.getRm8();
//            int value2 = modRM.getR8();
//            modRM.setR8(value1);
//            modRM.setRm8(value2);
//        }
//      case 0x87-> {
//            setCurrentInstructionName(()-> "XCHG16");
//            modRM.read();
//            int value1 = modRM.getRm16();
//            int value2 = modRM.getR16();
//            modRM.setR16(value1);
//            modRM.setRm16(value2);
//        }
//      case 0x88-> {
//            setCurrentInstructionName(()-> "MOV rmb rb");
//            modRM.read();
//            modRM.setRm8(modRM.getR8());
//        }
//      case 0x89-> {
//            setCurrentInstructionName(()-> "MOV rmw rw");
//            modRM.read();
//            modRM.setRm16(uint16(modRM.getR16()));
//        }
//      case 0x8A-> {
//            setCurrentInstructionName(()-> "MOV rb, rmb");
//            modRM.read();
//            modRM.setR8(modRM.getRm8());
//        }
//      case 0x8B-> {
//            setCurrentInstructionName(()-> "MOV rw rmw");
//            modRM.read();
//            modRM.setR16(modRM.getRm16());
//        }
//      case 0x8C-> {
//            setCurrentInstructionName(()-> "MOV rmw sreg");
//            modRM.read();
//            modRM.setRm16(uint16(modRM.getSegmentRegister()));
//        }
//      case 0x8D-> {
//            setCurrentInstructionName(()-> "LEA");
//            modRM.read();
//            modRM.setR16(uint16(modRM.getMemoryOffset()));
//        }
//      case 0x8E-> {
//            setCurrentInstructionName(()-> "MOV sreg rmw");
//            modRM.read();
//            modRM.setSegmentRegister(modRM.getRm16());
//        }
//      case 0x8F-> {
//            setCurrentInstructionName(()-> "POP rmw");
//            modRM.read();
//            modRM.setRm16(stack.pop());
//        }
//      case 0x90->setCurrentInstructionName(()-> "NOP");
//      case 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97-> {
//            int regIndex = opcode & REG_INDEX_MASK;
//            setCurrentInstructionName(()-> "XCHG AX," + state.getRegisters().getRegName(regIndex));
//            int value1 = state.getAX();
//            int value2 = state.getRegisters().getRegister(regIndex);
//            state.setAX(value2);
//            state.getRegisters().setRegister(regIndex, value1);
//        }
//      case 0x98-> {

//            // Convert byte to word
//            setCurrentInstructionName(()-> "CBW");
//            state.setAX(uint16(int8(state.getAL())));
//        }
//      case 0x99-> {

//            // Sign extend AX into DX (word to dword)
//            setCurrentInstructionName(()-> "CWD");
//            if (state.getAX() >= 0x8000)
//            {
//                state.setDX(0xFFFF);
//            }
//            else
//            {
//                state.setDX(0);
//            }
//        }
//      case 0x9A-> { // FAR CALL
//            int ip = nextUint16();
//            int cs = nextUint16();
//            setCurrentInstructionName(()-> "FAR CALL");
//            farCall(state.getCS(), internalIp, cs, ip);
//        }

//      // Do nothing, this is to wait for the FPU which is not implemented
//      case 0x9B->setCurrentInstructionName(()-> "WAIT");
//      case 0x9C-> {
//            setCurrentInstructionName(()-> "PUSHF");
//            stack.push(state.getFlags().getFlagRegister());
//        }
//      case 0x9D-> {
//            setCurrentInstructionName(()-> "POPF");
//            state.getFlags().setFlagRegister(stack.pop());
//        }
//      case 0x9E-> {
//            setCurrentInstructionName(()-> "SAHF");
//            state.getFlags().setFlagRegister(state.getAH());
//        }
//      case 0x9F-> {
//            setCurrentInstructionName(()-> "LAHF");
//            state.setAH(state.getFlags().getFlagRegister());
//        }
//      case 0xA0-> {
//            setCurrentInstructionName(()-> "MOV AL moffs8");
//            state.setAL(memory.getUint8(getDsNextUint16Address()));
//            staticAddressesRecorder.setCurrentAddressOperation(ValueOperation.READ, OperandSize.BYTE8);
//        }
//      case 0xA1-> {
//            setCurrentInstructionName(()-> "MOV AX moffs16");
//            state.setAX(memory.getUint16(getDsNextUint16Address()));
//            staticAddressesRecorder.setCurrentAddressOperation(ValueOperation.READ, OperandSize.WORD16);
//        }
//      case 0xA2-> {
//            setCurrentInstructionName(()-> "MOV moffs8 AL");
//            memory.setUint8(getDsNextUint16Address(), state.getAL());
//            staticAddressesRecorder.setCurrentAddressOperation(ValueOperation.WRITE, OperandSize.BYTE8);
//        }
//      case 0xA3-> {
//            setCurrentInstructionName(()-> "MOV moffs16 AX");
//            memory.setUint16(getDsNextUint16Address(), state.getAX());
//            staticAddressesRecorder.setCurrentAddressOperation(ValueOperation.WRITE, OperandSize.WORD16);
//        }
//      case 0xA4, 0xA5, 0xA6, 0xA7->processString(opcode);
//      case 0xA8-> {
//            setCurrentInstructionName(()-> "TEST AL ib");
//            alu.and8(state.getAL(), nextUint8());
//        }
//      case 0xA9-> {
//            setCurrentInstructionName(()-> "TEST AX iw");
//            alu.and16(state.getAX(), nextUint16());
//        }
//      case 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF->processString(opcode);
//      case 0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7-> {
//            int regIndex = opcode & REG_INDEX_MASK;
//            setCurrentInstructionName(()-> "MOV " + state.getRegisters().getReg8Name(regIndex) + " ib");
//            state.getRegisters().setRegisterFromHighLowIndex8(regIndex, nextUint8());
//        }
//      case 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF-> {
//            int regIndex = opcode & REG_INDEX_MASK;
//            setCurrentInstructionName(()-> "MOV " + state.getRegisters().getRegName(regIndex) + " iw");
//            state.getRegisters().setRegister(regIndex, nextUint16());
//        }
//      case 0xC0-> {
//            modRM.read();
//            int count = this.nextUint8();
//            int value = modRM.getRm8();
//            setCurrentInstructionName(()-> "SHL rmb " + count);
//            modRM.setRm8(alu.shl8(value, count));
//        }
//      case 0xC1-> {
//            modRM.read();
//            int count = this.nextUint8();
//            int value = modRM.getRm16();
//            setCurrentInstructionName(()-> "SHL rmw " + count);
//            modRM.setRm16(alu.shl16(value, count));
//        }
//      case 0xC2-> {
//            int numberOfBytesToPop = nextUint8();
//            setCurrentInstructionName(()-> "RET and pop " + numberOfBytesToPop + " bytes");
//            nearRet(numberOfBytesToPop);
//        }
//      case 0xC3-> {
//            setCurrentInstructionName(()-> "RET");
//            nearRet(0);
//        }
//      case 0xC4, 0xC5-> {

//            // Copy segmented address that is in memory (32bits) into DS/ES and the specified register
//            modRM.read();
//            modRM.setR16(memory.getUint16(modRM.getMemoryAddress()));
//            int value = memory.getUint16(modRM.getMemoryAddress() + 2);
//            this.getStaticAddressesRecorder().setCurrentAddressOperation(ValueOperation.READ, OperandSize.DWORD32);
//            if (opcode == 0xC4)
//            {
//                // LES
//                setCurrentInstructionName(()-> "LES rw md");
//                state.setES(value);
//            }
//            else
//            {
//                // LDS
//                setCurrentInstructionName(()-> "LDS rw md");
//                state.setDS(value);
//            }
//        }
//      case 0xC6-> {
//            setCurrentInstructionName(()-> "MOV rmb ib");
//            modRM.read();
//            modRM.setRm8(nextUint8());
//        }
//      case 0xC7-> {
//            setCurrentInstructionName(()-> "MOV rmw iw");
//            modRM.read();
//            modRM.setRm16(nextUint16());
//        }
//      case 0xC8, 0xC9->handleInvalidOpcode(opcode);
//      case 0xCA-> {
//            int numberOfBytesToPop = nextUint8();
//            setCurrentInstructionName(()-> "RETF and pop " + numberOfBytesToPop + " bytes");
//            farRet(numberOfBytesToPop);
//        }
//      case 0xCB-> {
//            setCurrentInstructionName(()-> "RETF");
//            farRet(0);
//        }
//      case 0xCC-> {
//            setCurrentInstructionName(()-> "INT 3");
//            interrupt(3, false);
//        }
//      case 0xCD-> {
//            setCurrentInstructionName(()-> "INT ib");
//            interrupt(nextUint8(), false);
//        }
//      case 0xCE-> {
//            setCurrentInstructionName(()-> "INTO");
//            if (state.getOverflowFlag())
//            {
//                interrupt(4, false);
//            }
//        }
//      case 0xCF-> {
//            setCurrentInstructionName(()-> "IRET");
//            interruptRet();
//        }
//      case 0xD0, 0xD1, 0xD2, 0xD3-> // GRP2 rmb 1, GRP2 rmw 1, GRP2 rmb CL, GRP2 rmw CL
//        grp2(opcode);
//      case 0xD4-> {
//            setCurrentInstructionName(()-> "AAM ib");
//            int v1 = state.getAL();
//            int v2 = nextUint8();
//            if (v2 == 0)
//            {
//                handleDivisionError();
//                break;
//            }
//            int result = v1 % v2;
//            state.setAH(v1 / v2);
//            state.setAL(result);
//            alu.updateFlags8(result);
//        }
//      case 0xD5-> {
//            setCurrentInstructionName(()-> "AAD ib");
//            int result = uint8(state.getAL() + state.getAH() * nextUint8());
//            state.setAL(result);
//            state.setAH(0);
//            state.getFlags().setFlagRegister(0);
//            alu.updateFlags8(result);
//        }
//      case 0xD6->handleInvalidOpcode(opcode);
//      case 0xD7-> {
//            setCurrentInstructionName(()-> "XLAT");
//            int address = modRM.getAddress(SegmentRegisters.DS_INDEX, state.getBX()) + state.getAL();
//            state.setAL(memory.getUint8(address));
//        }
//      case 0xD8->handleInvalidOpcode(opcode);
//      case 0xD9-> {
//            modRM.read();
//            int groupIndex = modRM.getRegisterIndex();
//            switch (groupIndex)
//            {
//                case 0x7-> {

//                        // Set the control word to the value expected after init since FPU is not supported.
//                        modRM.setRm16(0x37F);
//                        setCurrentInstructionName(()-> "FNSTCW");
//                    }
//                default -> throw new InvalidGroupIndexException(machine, groupIndex);
//            }
//        }
//      case 0xDA->handleInvalidOpcode(opcode);
//      case 0xDB-> {
//            int opCodeNextByte = nextUint8();
//            if (opCodeNextByte != 0xE3)
//            {
//                int fullOpCode = (opcode << 8) | opCodeNextByte;
//                handleInvalidOpcode(fullOpCode);
//            }
//            setCurrentInstructionName(()-> "FNINIT");

//            // Do nothing, no FPU emulation, but this is used to detect FPU
//        }
//      case 0xDC->handleInvalidOpcode(opcode);
//      case 0xDD-> {
//            modRM.read();
//            int groupIndex = modRM.getRegisterIndex();
//            switch (groupIndex)
//            {
//                case 0x7-> {

//                        // Set non zero, means no FPU installed when called after FNINIT.
//                        modRM.setRm16(0xFF);
//                        setCurrentInstructionName(()-> "FNSTSW");
//                    }
//                default -> throw new InvalidGroupIndexException(machine, groupIndex);
//            }
//        }
//      case 0xDE, 0xDF->handleInvalidOpcode(opcode);
//      case 0xE0, 0xE1-> { // LOOPZ / LOOPNZ
//            bool zeroFlag = (opcode & 0x1) == 1;
//            int address = int8(nextUint8());
//            if (zeroFlag)
//            {
//                setCurrentInstructionName(()-> "LOOPZ " + address);
//            }
//            else
//            {
//                setCurrentInstructionName(()-> "LOOPNZ " + address);
//            }
//            int cx = state.getCX() - 1;
//            state.setCX(cx);
//            if (cx != 0 && state.getZeroFlag() == zeroFlag)
//            {
//                internalIp += address;
//            }
//        }
//      case 0xE2-> { // LOOP
//            setCurrentInstructionName(()-> "LOOP");
//            int address = int8(nextUint8());
//            int cx = state.getCX() - 1;
//            state.setCX(cx);
//            if (cx != 0)
//            {
//                internalIp += address;
//            }
//        }
//      case 0xE3-> // JCXZ
//        jcc(opcode);
//      case 0xE4-> {
//            int port = nextUint8();
//            setCurrentInstructionName(()-> "IN AL " + ConvertUtils.toHex8(port));
//            state.setAL(uint8(inb(port)));
//        }
//      case 0xE5-> {
//            int port = nextUint16();
//            setCurrentInstructionName(()-> "IN AL " + ConvertUtils.toHex16(port));
//            state.setAX(uint16(inw(port)));
//        }
//      case 0xE6-> {
//            int port = nextUint8();
//            int value = state.getAL();
//            setCurrentInstructionName(()-> "OUT " + ConvertUtils.toHex8(port) + " AL=" + ConvertUtils.toHex8(value));
//            outb(port, value);
//        }
//      case 0xE7-> {
//            int port = nextUint16();
//            int value = state.getAX();
//            setCurrentInstructionName(()-> "OUT " + ConvertUtils.toHex16(port) + " AX=" + ConvertUtils.toHex16(value));
//            outw(port, value);
//        }
//      case 0xE8-> {
//            setCurrentInstructionName(()-> "CALL NEAR");
//            int nextInstruction = internalIp + 2;
//            int offset = int16(nextUint16());
//            int callAddress = uint16(nextInstruction + offset);
//            nearCall(nextInstruction, callAddress);
//        }
//      case 0xE9-> {
//            int offset = int16(nextUint16());
//            jumpNear(internalIp + offset);
//        }
//      case 0xEA-> {
//            int ip = nextUint16();
//            int cs = nextUint16();
//            jumpFar(cs, ip);
//        }
//      case 0xEB-> {
//            int offset = int8(nextUint8());
//            jumpNear(internalIp + offset);
//        }
//      case 0xEC-> {
//            int port = state.getDX();
//            setCurrentInstructionName(()-> "IN AL DX=" + ConvertUtils.toHex16(port));
//            state.setAL(inb(port));
//        }
//      case 0xED-> {
//            int port = state.getDX();
//            setCurrentInstructionName(()-> "IN AX DX=" + ConvertUtils.toHex16(port));
//            state.setAX(inw(port));
//        }
//      case 0xEE-> {
//            int port = state.getDX();
//            int value = state.getAL();
//            setCurrentInstructionName(()-> "OUT DX=" + ConvertUtils.toHex16(port) + " AL=" + ConvertUtils.toHex8(value));
//            outb(port, value);
//        }
//      case 0xEF-> {
//            int port = state.getDX();
//            int value = state.getAX();
//            setCurrentInstructionName(()-> "OUT DX=" + ConvertUtils.toHex16(port) + " AX=" + ConvertUtils.toHex16(value));
//            outw(port, value);
//        }
//      case 0xF0, 0xF1->handleInvalidOpcode(opcode);
//      case 0xF2, 0xF3->handleInvalidOpcodeBecausePrefix(opcode);
//      case 0xF4-> {
//            setCurrentInstructionName(()-> "HLT");
//            LOGGER.info("HLT instruction encountered, halting!");
//            this.running = false;
//        }
//      case 0xF5-> {
//            setCurrentInstructionName(()-> "CMC");
//            state.setCarryFlag(!state.getCarryFlag());
//        }
//      case 0xF6-> // GRP3a rmb
//        grp3a();
//      case 0xF7-> // GRP3b rmw
//        grp3b();
//      case 0xF8-> {
//            setCurrentInstructionName(()-> "CLC");
//            state.setCarryFlag(false);
//        }
//      case 0xF9-> {
//            setCurrentInstructionName(()-> "STC");
//            state.setCarryFlag(true);
//        }
//      case 0xFA-> {
//            setCurrentInstructionName(()-> "CLI");
//            state.setInterruptFlag(false);
//        }
//      case 0xFB-> {
//            setCurrentInstructionName(()-> "STI");
//            state.setInterruptFlag(true);
//        }
//      case 0xFC-> {
//            setCurrentInstructionName(()-> "CLD");
//            state.setDirectionFlag(false);
//        }
//      case 0xFD-> {
//            setCurrentInstructionName(()-> "STD");
//            state.setDirectionFlag(true);
//        }
//      case 0xFE-> // GRP4 rmb
//        grp4();
//      case 0xFF-> // GRP5 rmw
//        grp5();
//        default->handleInvalidOpcode(opcode);
//    }
//}

//private void handleInvalidOpcodeBecausePrefix(int opcode) throws InvalidOpcodeException
//{
//    throw new InvalidOpcodeException(machine, opcode, true);
//  }

//  private void handleInvalidOpcode(int opcode) throws InvalidOpcodeException
//{
//    throw new InvalidOpcodeException(machine, opcode, false);
//  }

//  private int getDsNextUint16Address()
//{
//    return modRM.getAddress(SegmentRegisters.DS_INDEX, nextUint16(), true);
//}

//private bool isStringOpUpdatingFlags(int stringOpCode)
//{
//    return stringOpCode == 0xA6 // CMPSB
//        || stringOpCode == 0xA7 // CMPSW
//        || stringOpCode == 0xAE // SCASB
//        || stringOpCode == 0xAF; // SCASW
//}

///**
// * Jumps handling
// *
// * @param opcode
// * @throws InvalidOperationException
// */
//private void jcc(int opcode) throws InvalidOperationException
//{
//    int address = int8(nextUint8());
//    bool jump = switch (opcode) {
//      case 0x70->state.getOverflowFlag();
//      case 0x71-> !state.getOverflowFlag();
//      case 0x72->state.getCarryFlag();
//      case 0x73-> !state.getCarryFlag();
//      case 0x74->state.getZeroFlag();
//      case 0x75-> !state.getZeroFlag();
//      case 0x76->state.getCarryFlag() || state.getZeroFlag();
//      case 0x77-> !state.getCarryFlag() && !state.getZeroFlag();
//      case 0x78->state.getSignFlag();
//      case 0x79-> !state.getSignFlag();
//      case 0x7A->state.getParityFlag();
//      case 0x7B-> !state.getParityFlag();
//      case 0x7C->state.getSignFlag() != state.getOverflowFlag();
//      case 0x7D->state.getSignFlag() == state.getOverflowFlag();
//      case 0x7E->state.getZeroFlag() || state.getSignFlag() != state.getOverflowFlag();
//      case 0x7F-> !state.getZeroFlag() && state.getSignFlag() == state.getOverflowFlag();
//      case 0xE3->state.getCX() == 0;
//        default-> throw new InvalidOpcodeException(machine, opcode, false);
//    };
//    setCurrentInstructionName(() -> switch (opcode) {
//      case 0x70-> "JO";
//      case 0x71-> "JNO";
//      case 0x72-> "JB";
//      case 0x73-> "JNB";
//      case 0x74-> "JZ";
//      case 0x75-> "JNZ";
//      case 0x76-> "JBE";
//      case 0x77-> "JA";
//      case 0x78-> "JS";
//      case 0x79-> "JNS";
//      case 0x7A-> "JP";
//      case 0x7B-> "JPO";
//      case 0x7C-> "JL";
//      case 0x7D-> "JGE";
//      case 0x7E-> "JNG";
//      case 0x7F-> "JG";
//      case 0xE3-> "JCXZ";
//        default-> "";
//    } + " " + address + " jump?" + jump);
//    if (jump) {
//        internalIp += address;
//    }
//}

//private void grp1(int opcode) throws InvalidOperationException
//{
//    modRM.read();
//    int groupIndex = modRM.getRegisterIndex();
//    bool op1Byte = (opcode & 0b01) == 0;
//    bool op2Byte = (opcode & 0b11) != 1;
//    int op2;
//    if (op2Byte) {
//        if (op1Byte)
//        {
//            op2 = nextUint8();
//        }
//        else
//        {
//            // preserve sign in byte so that it can be extended later if needed
//            op2 = uint16(int8(nextUint8()));
//        }
//    } else {
//        op2 = nextUint16();
//    }
//    int op1 = getRm8Or16(op1Byte);
//    setCurrentInstructionName(() -> generateGrp1Name(groupIndex, op1Byte, op1, op2));
//    int res;
//    if (op1Byte) {
//        res = switch (groupIndex)
//        {
//            case 0->alu.add8(op1, op2);
//            case 1->alu.or8(op1, op2);
//            case 2->alu.adc8(op1, op2);
//            case 3->alu.sbb8(op1, op2);
//            case 4->alu.and8(op1, op2);
//            case 5->alu.sub8(op1, op2);
//            case 6->alu.xor8(op1, op2);
//            case 7->alu.sub8(op1, op2);
//            default -> throw new InvalidGroupIndexException(machine, groupIndex);
//        };
//    } else {
//        res = switch (groupIndex)
//        {
//            case 0->alu.add16(op1, op2);
//            case 1->alu.or16(op1, op2);
//            case 2->alu.adc16(op1, op2);
//            case 3->alu.sbb16(op1, op2);
//            case 4->alu.and16(op1, op2);
//            case 5->alu.sub16(op1, op2);
//            case 6->alu.xor16(op1, op2);
//            case 7->alu.sub16(op1, op2);
//            default -> throw new InvalidGroupIndexException(machine, groupIndex);
//        };
//    }

//    // 7 is CMP so no memory to set
//    if (groupIndex != 7) {
//        if (op1Byte)
//        {
//            modRM.setRm8(res);
//        }
//        else
//        {
//            modRM.setRm16(res);
//        }
//    }
//}

//private String generateGrp1Name(int groupIndex, bool op1Byte, int op1, int op2)
//{
//    String opName = switch (groupIndex)
//    {
//        case 0-> "ADD";
//        case 1-> "OR";
//        case 2-> "ADC";
//        case 3-> "SBB";
//        case 4-> "AND";
//        case 5-> "SUB";
//        case 6-> "XOR";
//        case 7-> "CMP";
//        default -> "";
//    };
//    return opName + generate8Or16Value(op1Byte, op1, op2);
//}

//private void grp2(int opcode) throws InvalidOperationException
//{
//    // GRP2 rmb 1
//    modRM.read();
//    int groupIndex = modRM.getRegisterIndex();
//    bool op1Byte = (opcode & 0b01) == 0;

//    bool valueIsCL = (opcode & 0b10) == 0b10;// if it 0b10, it is CL
//    int op2;
//    if (valueIsCL) {
//        op2 = state.getCL();
//    } else {
//        op2 = 1;
//    }
//    int op1 = getRm8Or16(op1Byte);
//    setCurrentInstructionName(() -> generateGrp2Name(groupIndex, op1Byte, op1, op2));
//    int res;
//    if (op1Byte) {
//        res = switch (groupIndex)
//        {
//            case 0->alu.rol8(op1, op2);
//            case 1->alu.ror8(op1, op2);
//            case 2->alu.rcl8(op1, op2);
//            case 3->alu.rcr8(op1, op2);
//            case 4->alu.shl8(op1, op2);
//            case 5->alu.shr8(op1, op2);
//            case 7->alu.sar8(op1, op2);
//            default -> throw new InvalidGroupIndexException(machine, groupIndex);
//        };
//    } else {
//        res = switch (groupIndex)
//        {
//            case 0->alu.rol16(op1, op2);
//            case 1->alu.ror16(op1, op2);
//            case 2->alu.rcl16(op1, op2);
//            case 3->alu.rcr16(op1, op2);
//            case 4->alu.shl16(op1, op2);
//            case 5->alu.shr16(op1, op2);
//            case 7->alu.sar16(op1, op2);
//            default -> throw new InvalidGroupIndexException(machine, groupIndex);
//        };
//    }
//    if (op1Byte) {
//        modRM.setRm8(res);
//    } else {
//        modRM.setRm16(res);
//    }
//}

//private int getRm8Or16(bool op1Byte)
//{
//    if (op1Byte)
//    {
//        return modRM.getRm8();
//    }
//    return modRM.getRm16();
//}

//private String generateGrp2Name(int groupIndex, bool op1Byte, int op1, int op2)
//{
//    String opName = switch (groupIndex)
//    {
//        case 0-> "ROL";
//        case 1-> "ROR";
//        case 2-> "RCL";
//        case 3-> "RCR";
//        case 4-> "SHL";
//        case 5-> "SHR";
//        case 7-> "SAR";
//        default -> "";
//    };
//    return opName + generate8Or16Value(op1Byte, op1, op2);
//}

//private String generate8Or16Value(bool op1Byte, int op1, int op2)
//{
//    String params = "(" + ConvertUtils.toHex8(op1) + "," + ConvertUtils.toHex8(op2) + ")";
//    if (op1Byte)
//    {
//        return "8 " + params;
//    }
//    return "16 " + params;
//}

//private void grp3a() throws InvalidOperationException
//{
//    modRM.read();
//    int groupIndex = modRM.getRegisterIndex();
//    switch (groupIndex) {
//      case 0-> {
//            setCurrentInstructionName(()-> "TEST8");
//            alu.and8(modRM.getRm8(), nextUint8());
//        }
//      case 2-> {
//            setCurrentInstructionName(()-> "NOT8");
//            modRM.setRm8(uint8(~modRM.getRm8()));
//        }
//      case 3-> {
//            setCurrentInstructionName(()-> "NEG8");
//            int value = modRM.getRm8();
//            value = alu.sub8(0, value);
//            modRM.setRm8(value);
//            state.setCarryFlag(value != 0);
//        }
//      case 4-> {
//            setCurrentInstructionName(()-> "MUL8");
//            int result = alu.mul8(state.getAL(), modRM.getRm8());

//            // Upper part of the result goes in AH
//            state.setAH(uint8(result >> 8));
//            state.setAL(uint8(result));
//        }
//      case 5-> {
//            setCurrentInstructionName(()-> "IMUL8");
//            int result = alu.imul8(state.getAL(), modRM.getRm8());

//            // Upper part of the result goes in AH
//            state.setAH(uint8(result >> 8));
//            state.setAL(uint8(result));
//        }
//      case 6-> {
//            setCurrentInstructionName(()-> "DIV8");
//            int v1 = state.getAX();
//            int v2 = modRM.getRm8();
//            int result = alu.div8(v1, v2);
//            if (result == null)
//            {
//                handleDivisionError();
//                break;
//            }
//            state.setAL(result);
//            state.setAH(v1 % v2);
//        }
//      case 7-> {
//            setCurrentInstructionName(()-> "IDIV8");
//            int v1 = int16(state.getAX());
//            int v2 = int8(modRM.getRm8());
//            int result = alu.idiv8(v1, v2);
//            if (result == null)
//            {
//                handleDivisionError();
//                break;
//            }
//            state.setAL(result);
//            state.setAH(int16(v1) % int8(v2));
//        }
//        default-> throw new InvalidGroupIndexException(machine, groupIndex);
//    }
//}

//private void handleDivisionError() throws InvalidOperationException
//{
//    // Reset IP because instruction is not finished (this is how an actual CPU behaves)
//    internalIp = state.getIP();
//    interrupt(0, false);
//}

//private void grp3b() throws InvalidOperationException
//{
//    modRM.read();
//    int groupIndex = modRM.getRegisterIndex();
//    switch (groupIndex) {
//      case 0-> {
//            setCurrentInstructionName(()-> "TEST16");
//            alu.and16(modRM.getRm16(), nextUint16());
//        }
//      case 2-> {
//            setCurrentInstructionName(()-> "NOT16");
//            modRM.setRm16(uint16(~modRM.getRm16()));
//        }
//      case 3-> {
//            setCurrentInstructionName(()-> "NEG16");
//            int value = modRM.getRm16();
//            value = alu.sub16(0, value);
//            modRM.setRm16(value);
//            state.setCarryFlag(value != 0);
//        }
//      case 4-> {
//            setCurrentInstructionName(()-> "MUL16");
//            int result = alu.mul16(state.getAX(), modRM.getRm16());

//            // Upper part of the result goes in DX
//            state.setDX(result >>> 16);
//            state.setAX(result);
//        }
//      case 5-> {
//            setCurrentInstructionName(()-> "IMUL16");
//            int result = alu.imul16(state.getAX(), modRM.getRm16());

//            // Upper part of the result goes in DX
//            state.setDX(result >>> 16);
//            state.setAX(result);
//        }
//      case 6-> {
//            setCurrentInstructionName(()-> "DIV16");
//            int v1 = (state.getDX() << 16) | state.getAX();
//            int v2 = modRM.getRm16();
//            int result = alu.div16(v1, v2);
//            if (result == null)
//            {
//                handleDivisionError();
//                break;
//            }
//            state.setAX(result);
//            state.setDX((int)(uint32(v1) % uint32(v2)));
//        }
//      case 7-> {
//            setCurrentInstructionName(()-> "IDIV16");

//            // no sign extension for v1 as it is already a 32bit value
//            int v1 = (state.getDX() << 16) | state.getAX();
//            int v2 = int16(modRM.getRm16());
//            int result = alu.idiv16(v1, v2);
//            if (result == null)
//            {
//                handleDivisionError();
//                break;
//            }
//            state.setAX(result);
//            state.setDX(v1 % v2);
//        }
//        default-> throw new InvalidGroupIndexException(machine, groupIndex);
//    }
//}

//private void grp4() throws InvalidOperationException
//{
//    modRM.read();
//    int groupIndex = modRM.getRegisterIndex();
//    switch (groupIndex) {
//      case 0-> {
//            setCurrentInstructionName(()-> "INC");
//            modRM.setRm8(alu.inc8(modRM.getRm8()));
//        }
//      case 1-> {
//            setCurrentInstructionName(()-> "DEC");
//            modRM.setRm8(alu.dec8(modRM.getRm8()));
//        }
//      case 7->

//        // Callback, emulator specific instruction FE38 like in dosbox to allow interrupts to be
//        // overridden by the program
//        callback(this.nextUint16());
//        default-> throw new InvalidGroupIndexException(machine, groupIndex);
//    }
//}

//private void grp5() throws InvalidOperationException
//{
//    modRM.read();
//    int groupIndex = modRM.getRegisterIndex();
//    switch (groupIndex) {
//      case 0-> {
//            setCurrentInstructionName(()-> "INC");
//            modRM.setRm16(alu.inc16(modRM.getRm16()));
//        }
//      case 1-> {
//            setCurrentInstructionName(()-> "DEC");
//            modRM.setRm16(alu.dec16(modRM.getRm16()));
//        }
//      case 2-> {
//            setCurrentInstructionName(()-> "NEAR CALL");
//            int callAddress = modRM.getRm16();
//            nearCall(internalIp, callAddress);
//        }
//      case 3-> {
//            setCurrentInstructionName(()-> "FAR CALL");
//            int ipAddress = modRM.getMemoryAddress();
//            this.getStaticAddressesRecorder().setCurrentAddressOperation(ValueOperation.READ, OperandSize.DWORD32PTR);
//            int ip = memory.getUint16(ipAddress);
//            int cs = memory.getUint16(ipAddress + 2);
//            farCall(state.getCS(), internalIp, cs, ip);
//        }
//      case 4-> {
//            int ip = modRM.getRm16();
//            jumpNear(ip);
//        }
//      case 5-> {
//            int ipAddress = modRM.getMemoryAddress();
//            this.getStaticAddressesRecorder().setCurrentAddressOperation(ValueOperation.READ, OperandSize.DWORD32PTR);
//            int ip = memory.getUint16(ipAddress);
//            int cs = memory.getUint16(ipAddress + 2);
//            jumpFar(cs, ip);
//        }
//      case 6-> {
//            setCurrentInstructionName(()-> "PUSH");
//            stack.push(modRM.getRm16());
//        }
//        default-> throw new InvalidGroupIndexException(machine, groupIndex);
//    }
//}

//private void jumpNear(int ip)
//{
//    setCurrentInstructionName(
//        ()-> "JMP NEAR " + ConvertUtils.toSegmentedAddressRepresentation(state.getCS(), ip));
//    handleJump(state.getCS(), ip);
//}

//private void jumpFar(int cs, int ip)
//{
//    setCurrentInstructionName(
//        ()-> "JMP FAR " + ConvertUtils.toSegmentedAddressRepresentation(cs, ip));
//    handleJump(cs, ip);
//}

//private void handleJump(int cs, int ip)
//{
//    internalIp = ip;
//    state.setCS(cs);
//}

//private void nearCall(int returnIP, int callIP) throws InvalidOperationException
//{
//    stack.push(returnIP);
//    internalIp = callIP;
//    handleCall(CallType.NEAR, state.getCS(), returnIP, state.getCS(), callIP);
//}

//private void farCall(int returnCS, int returnIP, int targetCS, int targetIP) throws InvalidOperationException
//{
//    stack.push(returnCS);
//    stack.push(returnIP);
//    state.setCS(targetCS);
//    internalIp = targetIP;
//    handleCall(CallType.FAR, returnCS, returnIP, targetCS, targetIP);
//}

//private void handleCall(CallType callType, int returnCS, int returnIP, int targetCS, int targetIP)
//      throws InvalidOperationException
//{
//    if (isLoggingEnabled()) {
//        LOGGER.debug("CALL {}, will return to {}", ConvertUtils.toSegmentedAddressRepresentation(targetCS, targetIP),
//            ConvertUtils.toSegmentedAddressRepresentation(returnCS, returnIP));
//    }
//    functionHandlerInUse.call(callType, targetCS, targetIP, returnCS, returnIP);
//}

//public void nearRet(int numberOfBytesToPop)
//{
//    functionHandlerInUse.ret(CallType.NEAR);
//    internalIp = stack.pop();
//    state.setSP(numberOfBytesToPop + state.getSP());
//}

//public void farRet(int numberOfBytesToPop)
//{
//    functionHandlerInUse.ret(CallType.FAR);
//    internalIp = stack.pop();
//    state.setCS(stack.pop());
//    state.setSP(numberOfBytesToPop + state.getSP());
//}

//private bool isStringOpcode(int opcode)
//{
//    return STRING_OPCODES.contains(opcode);
//}

//private bool isPrefix(int opcode)
//{
//    return PREFIXES_OPCODES.contains(opcode);
//}

//private void processString(int opcode) throws InvalidOperationException
//{
//    int diff = (state.getDirectionFlag() ? -1 : 1) << (opcode & 1);

//    switch (opcode) {
//      case 0xA4-> {
//            setCurrentInstructionName(()-> "MOVSB");
//            int value = memory.getUint8(getMemoryAddressOverridableDsSi());
//            memory.setUint8(getMemoryAddressEsDi(), value);
//            state.setSI(state.getSI() + diff);
//            state.setDI(state.getDI() + diff);
//        }
//      case 0xA5-> {
//            setCurrentInstructionName(()-> "MOVSW");
//            int value = memory.getUint16(getMemoryAddressOverridableDsSi());
//            memory.setUint16(getMemoryAddressEsDi(), value);
//            state.setSI(state.getSI() + diff);
//            state.setDI(state.getDI() + diff);
//        }
//      case 0xA6-> {
//            setCurrentInstructionName(()-> "CMPSB");
//            int value = memory.getUint8(getMemoryAddressOverridableDsSi());
//            alu.sub8(value, memory.getUint8(getMemoryAddressEsDi()));
//            state.setSI(state.getSI() + diff);
//            state.setDI(state.getDI() + diff);
//        }
//      case 0xA7-> {
//            setCurrentInstructionName(()-> "CMPSW");
//            int value = memory.getUint16(getMemoryAddressOverridableDsSi());
//            alu.sub16(value, memory.getUint16(getMemoryAddressEsDi()));
//            state.setSI(state.getSI() + diff);
//            state.setDI(state.getDI() + diff);
//        }
//      case 0xAA-> {
//            setCurrentInstructionName(()-> "STOSB");
//            memory.setUint8(getMemoryAddressEsDi(), state.getAL());
//            state.setDI(state.getDI() + diff);
//        }
//      case 0xAB-> {
//            setCurrentInstructionName(()-> "STOSW");
//            memory.setUint16(getMemoryAddressEsDi(), state.getAX());
//            state.setDI(state.getDI() + diff);
//        }
//      case 0xAC-> {
//            setCurrentInstructionName(()-> "LODSB");
//            int value = memory.getUint8(getMemoryAddressOverridableDsSi());
//            state.setAL(value);
//            state.setSI(state.getSI() + diff);
//        }
//      case 0xAD-> {
//            setCurrentInstructionName(()-> "LODSW");
//            int value = memory.getUint16(getMemoryAddressOverridableDsSi());
//            state.setAX(value);
//            state.setSI(state.getSI() + diff);
//        }
//      case 0xAE-> {
//            setCurrentInstructionName(()-> "SCASB");
//            alu.sub8(state.getAL(), memory.getUint8(getMemoryAddressEsDi()));
//            state.setDI(state.getDI() + diff);
//        }
//      case 0xAF-> {
//            setCurrentInstructionName(()-> "SCASW");
//            alu.sub16(state.getAX(), memory.getUint16(getMemoryAddressEsDi()));
//            state.setDI(state.getDI() + diff);
//        }
//      case 0x6C-> {
//            setCurrentInstructionName(()-> "INSB");
//            int port = state.getDX();
//            int value = inb(port);
//            memory.setUint8(getMemoryAddressEsDi(), value);
//            state.setSI(state.getSI() + diff);
//        }
//      case 0x6D-> {
//            setCurrentInstructionName(()-> "INSW");
//            int port = state.getDX();
//            int value = inw(port);
//            memory.setUint16(getMemoryAddressEsDi(), value);
//            state.setSI(state.getSI() + diff);
//        }
//      case 0x6E-> {
//            setCurrentInstructionName(()-> "OUTSB");
//            int port = state.getDX();
//            int value = memory.getUint8(getMemoryAddressOverridableDsSi());
//            outb(port, value);
//            state.setSI(state.getSI() + diff);
//        }
//      case 0x6F-> {
//            setCurrentInstructionName(()-> "OUTSW");
//            int port = state.getDX();
//            int value = memory.getUint16(getMemoryAddressOverridableDsSi());
//            outw(port, value);
//            state.setSI(state.getSI() + diff);
//        }
//        default->handleInvalidOpcode(opcode);
//    }
//}

//private int getMemoryAddressOverridableDsSi()
//{
//    return modRM.getAddress(SegmentRegisters.DS_INDEX, state.getSI());
//}

//private int getMemoryAddressEsDi()
//{
//    return MemoryUtils.toPhysicalAddress(state.getES(), state.getDI());
//}

//private void outb(int port, int val) throws InvalidOperationException
//{
//    if (ioPortDispatcher != null) {
//        ioPortDispatcher.outb(uint16(port), uint8(val));
//    }
//}

//private void outw(int port, int val) throws InvalidOperationException
//{
//    if (ioPortDispatcher != null) {
//        ioPortDispatcher.outw(uint16(port), uint16(val));
//    }
//}

//private int inb(int port) throws InvalidOperationException
//{
//    if (ioPortDispatcher != null) {
//        return uint8(ioPortDispatcher.inb(uint16(port)));
//    }
//    return 0;
//}

//private int inw(int port) throws InvalidOperationException
//{
//    if (ioPortDispatcher != null) {
//        return uint16(ioPortDispatcher.inw(uint16(port)));
//    }
//    return 0;
//}

//private void interrupt(int vectorNumber, bool external) throws InvalidOperationException
//{
//    int targetIP = memory.getUint16(4 * vectorNumber);
//    int targetCS = memory.getUint16(4 * vectorNumber + 2);
//    if (errorOnUninitializedInterruptHandler && targetCS == 0 && targetIP == 0) {
//        throw new UnhandledOperationException(machine,
//            "Int was called but vector was not initialized for vectorNumber=" + ConvertUtils.toHex(vectorNumber));
//    }
//    int returnCS = state.getCS();
//    int returnIP = internalIp;
//    if (isLoggingEnabled()) {
//        LOGGER.debug("int {} handler found in memory, {}", ConvertUtils.toHex(vectorNumber),
//            ConvertUtils.toSegmentedAddressRepresentation(targetCS, targetIP));
//    }
//    stack.push(state.getFlags().getFlagRegister());
//    stack.push(returnCS);
//    stack.push(returnIP);
//    state.setInterruptFlag(false);
//    internalIp = targetIP;
//    state.setCS(targetCS);
//    bool recordReturn = true;
//    if (external) {
//        this.functionHandlerInUse = functionHandlerInExternalInterrupt;
//        recordReturn = false;
//    }
//    this.functionHandlerInUse.icall(CallType.INTERRUPT, targetCS, targetIP, returnCS, returnIP, vectorNumber,
//        recordReturn);
//}

//public void interruptRet()
//{
//    this.functionHandlerInUse.ret(CallType.INTERRUPT);
//    internalIp = stack.pop();
//    state.setCS(stack.pop());
//    state.getFlags().setFlagRegister(stack.pop());
//    this.functionHandlerInUse = functionHandler;
//}

//public void setFlagOnInterruptStack(int flagMask, bool flagValue)
//{
//    int flagsAddress = MemoryUtils.toPhysicalAddress(state.getSS(), state.getSP() + 4);
//    int value = memory.getUint16(flagsAddress);
//    if (flagValue)
//    {
//        value = value | flagMask;
//    }
//    else
//    {
//        value = value & ~flagMask;
//    }
//    memory.setUint16(flagsAddress, value);
//}

//private void callback(int callbackIndex) throws UnhandledOperationException
//{
//    setCurrentInstructionName(() -> "CALLBACK " + callbackIndex);
//    if (isLoggingEnabled()) {
//        LOGGER.debug("callback {}", ConvertUtils.toHex16(callbackIndex));
//    }
//    callbackHandler.run(callbackIndex);
//}

//public int nextUint8()
//{
//    int res = memory.getUint8(getInternalIpPhysicalAddress());
//    internalIp++;
//    return res;
//}

//public int nextUint16()
//{
//    int res = memory.getUint16(getInternalIpPhysicalAddress());
//    internalIp += 2;
//    return res;
//}

//private int getInternalIpPhysicalAddress()
//{
//    return MemoryUtils.toPhysicalAddress(state.getCS(), internalIp);
//}
//}